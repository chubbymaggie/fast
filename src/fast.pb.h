// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fast.proto

#ifndef PROTOBUF_fast_2eproto__INCLUDED
#define PROTOBUF_fast_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace fast {
class Element;
class ElementDefaultTypeInternal;
extern ElementDefaultTypeInternal _Element_default_instance_;
class Element_Literal;
class Element_LiteralDefaultTypeInternal;
extern Element_LiteralDefaultTypeInternal _Element_Literal_default_instance_;
class Element_Unit;
class Element_UnitDefaultTypeInternal;
extern Element_UnitDefaultTypeInternal _Element_Unit_default_instance_;
}  // namespace fast

namespace fast {

namespace protobuf_fast_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_fast_2eproto

enum Element_Unit_LanguageType {
  Element_Unit_LanguageType_ALL = 0,
  Element_Unit_LanguageType_OO = 1,
  Element_Unit_LanguageType_CXX = 2,
  Element_Unit_LanguageType_C = 3,
  Element_Unit_LanguageType_C_FAMILY = 4,
  Element_Unit_LanguageType_JAVA = 5,
  Element_Unit_LanguageType_CSHARP = 6,
  Element_Unit_LanguageType_OBJECTIVE_C = 7,
  Element_Unit_LanguageType_Element_Unit_LanguageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Element_Unit_LanguageType_Element_Unit_LanguageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Element_Unit_LanguageType_IsValid(int value);
const Element_Unit_LanguageType Element_Unit_LanguageType_LanguageType_MIN = Element_Unit_LanguageType_ALL;
const Element_Unit_LanguageType Element_Unit_LanguageType_LanguageType_MAX = Element_Unit_LanguageType_OBJECTIVE_C;
const int Element_Unit_LanguageType_LanguageType_ARRAYSIZE = Element_Unit_LanguageType_LanguageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Element_Unit_LanguageType_descriptor();
inline const ::std::string& Element_Unit_LanguageType_Name(Element_Unit_LanguageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Element_Unit_LanguageType_descriptor(), value);
}
inline bool Element_Unit_LanguageType_Parse(
    const ::std::string& name, Element_Unit_LanguageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Element_Unit_LanguageType>(
    Element_Unit_LanguageType_descriptor(), name, value);
}
enum Element_Literal_LiteralType {
  Element_Literal_LiteralType_number_type = 0,
  Element_Literal_LiteralType_char_type = 1,
  Element_Literal_LiteralType_string_type = 2,
  Element_Literal_LiteralType_boolean_type = 3,
  Element_Literal_LiteralType_null_type = 4,
  Element_Literal_LiteralType_Element_Literal_LiteralType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Element_Literal_LiteralType_Element_Literal_LiteralType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Element_Literal_LiteralType_IsValid(int value);
const Element_Literal_LiteralType Element_Literal_LiteralType_LiteralType_MIN = Element_Literal_LiteralType_number_type;
const Element_Literal_LiteralType Element_Literal_LiteralType_LiteralType_MAX = Element_Literal_LiteralType_null_type;
const int Element_Literal_LiteralType_LiteralType_ARRAYSIZE = Element_Literal_LiteralType_LiteralType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Element_Literal_LiteralType_descriptor();
inline const ::std::string& Element_Literal_LiteralType_Name(Element_Literal_LiteralType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Element_Literal_LiteralType_descriptor(), value);
}
inline bool Element_Literal_LiteralType_Parse(
    const ::std::string& name, Element_Literal_LiteralType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Element_Literal_LiteralType>(
    Element_Literal_LiteralType_descriptor(), name, value);
}
enum Element_Kind {
  Element_Kind_UNIT_KIND = 0,
  Element_Kind_DECL = 1,
  Element_Kind_DECL_STMT = 2,
  Element_Kind_INIT = 3,
  Element_Kind_EXPR = 4,
  Element_Kind_EXPR_STMT = 5,
  Element_Kind_COMMENT = 6,
  Element_Kind_CALL = 7,
  Element_Kind_CONTROL = 8,
  Element_Kind_INCR = 9,
  Element_Kind_NONE = 10,
  Element_Kind_VARIABLE = 11,
  Element_Kind_FUNCTION = 12,
  Element_Kind_FUNCTION_DECL = 13,
  Element_Kind_CONSTRUCTOR = 14,
  Element_Kind_CONSTRUCTOR_DECL = 15,
  Element_Kind_DESTRUCTOR = 16,
  Element_Kind_DESTRUCTOR_DECL = 17,
  Element_Kind_MACRO = 18,
  Element_Kind_SINGLE_MACRO = 19,
  Element_Kind_NULLOPERATOR = 20,
  Element_Kind_ENUM_DEFN = 21,
  Element_Kind_ENUM_DECL = 22,
  Element_Kind_GLOBAL_ATTRIBUTE = 23,
  Element_Kind_PROPERTY_ACCESSOR = 24,
  Element_Kind_PROPERTY_ACCESSOR_DECL = 25,
  Element_Kind_EXPRESSION = 26,
  Element_Kind_CLASS_DEFN = 27,
  Element_Kind_CLASS_DECL = 28,
  Element_Kind_UNION_DEFN = 29,
  Element_Kind_UNION_DECL = 30,
  Element_Kind_STRUCT_DEFN = 31,
  Element_Kind_STRUCT_DECL = 32,
  Element_Kind_INTERFACE_DEFN = 33,
  Element_Kind_INTERFACE_DECL = 34,
  Element_Kind_ACCESS_REGION = 35,
  Element_Kind_USING = 36,
  Element_Kind_OPERATOR_FUNCTION = 37,
  Element_Kind_OPERATOR_FUNCTION_DECL = 38,
  Element_Kind_EVENT = 39,
  Element_Kind_PROPERTY = 40,
  Element_Kind_ANNOTATION_DEFN = 41,
  Element_Kind_GLOBAL_TEMPLATE = 42,
  Element_Kind_UNIT = 43,
  Element_Kind_TART_ELEMENT_TOKEN = 44,
  Element_Kind_NOP = 45,
  Element_Kind_STRING = 46,
  Element_Kind_CHAR = 47,
  Element_Kind_LITERAL = 48,
  Element_Kind_BOOLEAN = 49,
  Element_Kind_NULL_ = 50,
  Element_Kind_COMPLEX = 51,
  Element_Kind_OPERATOR = 52,
  Element_Kind_MODIFIER = 53,
  Element_Kind_NAME = 54,
  Element_Kind_ONAME = 55,
  Element_Kind_CNAME = 56,
  Element_Kind_TYPE = 57,
  Element_Kind_TYPEPREV = 58,
  Element_Kind_CONDITION = 59,
  Element_Kind_BLOCK = 60,
  Element_Kind_PSEUDO_BLOCK = 61,
  Element_Kind_INDEX = 62,
  Element_Kind_ENUM = 63,
  Element_Kind_ENUM_DECLARATION = 64,
  Element_Kind_IF_STATEMENT = 65,
  Element_Kind_TERNARY = 66,
  Element_Kind_THEN = 67,
  Element_Kind_ELSE = 68,
  Element_Kind_ELSEIF = 69,
  Element_Kind_WHILE_STATEMENT = 70,
  Element_Kind_DO_STATEMENT = 71,
  Element_Kind_FOR_STATEMENT = 72,
  Element_Kind_FOREACH_STATEMENT = 73,
  Element_Kind_FOR_CONTROL = 74,
  Element_Kind_FOR_INITIALIZATION = 75,
  Element_Kind_FOR_CONDITION = 76,
  Element_Kind_FOR_INCREMENT = 77,
  Element_Kind_FOR_LIKE_CONTROL = 78,
  Element_Kind_EXPRESSION_STATEMENT = 79,
  Element_Kind_FUNCTION_CALL = 81,
  Element_Kind_DECLARATION_STATEMENT = 82,
  Element_Kind_DECLARATION = 83,
  Element_Kind_DECLARATION_INITIALIZATION = 84,
  Element_Kind_DECLARATION_RANGE = 85,
  Element_Kind_RANGE = 86,
  Element_Kind_GOTO_STATEMENT = 87,
  Element_Kind_CONTINUE_STATEMENT = 88,
  Element_Kind_BREAK_STATEMENT = 89,
  Element_Kind_LABEL_STATEMENT = 90,
  Element_Kind_LABEL = 91,
  Element_Kind_SWITCH = 92,
  Element_Kind_CASE = 93,
  Element_Kind_DEFAULT = 94,
  Element_Kind_FUNCTION_DEFINITION = 95,
  Element_Kind_FUNCTION_DECLARATION = 96,
  Element_Kind_LAMBDA = 97,
  Element_Kind_FUNCTION_LAMBDA = 98,
  Element_Kind_FUNCTION_SPECIFIER = 99,
  Element_Kind_RETURN_STATEMENT = 100,
  Element_Kind_PARAMETER_LIST = 101,
  Element_Kind_PARAMETER = 102,
  Element_Kind_KRPARAMETER_LIST = 103,
  Element_Kind_KRPARAMETER = 104,
  Element_Kind_ARGUMENT_LIST = 105,
  Element_Kind_ARGUMENT = 106,
  Element_Kind_PSEUDO_PARAMETER_LIST = 107,
  Element_Kind_INDEXER_PARAMETER_LIST = 108,
  Element_Kind_CLASS = 109,
  Element_Kind_CLASS_DECLARATION = 110,
  Element_Kind_STRUCT = 111,
  Element_Kind_STRUCT_DECLARATION = 112,
  Element_Kind_UNION = 113,
  Element_Kind_UNION_DECLARATION = 114,
  Element_Kind_DERIVATION_LIST = 115,
  Element_Kind_PUBLIC_ACCESS = 116,
  Element_Kind_PUBLIC_ACCESS_DEFAULT = 117,
  Element_Kind_PRIVATE_ACCESS = 118,
  Element_Kind_PRIVATE_ACCESS_DEFAULT = 119,
  Element_Kind_PROTECTED_ACCESS = 120,
  Element_Kind_PROTECTED_ACCESS_DEFAULT = 121,
  Element_Kind_MEMBER_INIT_LIST = 122,
  Element_Kind_MEMBER_INITIALIZATION_LIST = 123,
  Element_Kind_MEMBER_INITIALIZATION = 124,
  Element_Kind_CONSTRUCTOR_DEFINITION = 125,
  Element_Kind_CONSTRUCTOR_DECLARATION = 126,
  Element_Kind_DESTRUCTOR_DEFINITION = 127,
  Element_Kind_DESTRUCTOR_DECLARATION = 128,
  Element_Kind_FRIEND = 129,
  Element_Kind_CLASS_SPECIFIER = 130,
  Element_Kind_TRY_BLOCK = 131,
  Element_Kind_CATCH_BLOCK = 132,
  Element_Kind_FINALLY_BLOCK = 133,
  Element_Kind_THROW_STATEMENT = 134,
  Element_Kind_THROW_SPECIFIER = 135,
  Element_Kind_THROW_SPECIFIER_JAVA = 136,
  Element_Kind_TEMPLATE = 137,
  Element_Kind_GENERIC_ARGUMENT = 138,
  Element_Kind_GENERIC_ARGUMENT_LIST = 139,
  Element_Kind_TEMPLATE_PARAMETER = 140,
  Element_Kind_TEMPLATE_PARAMETER_LIST = 141,
  Element_Kind_GENERIC_PARAMETER = 142,
  Element_Kind_GENERIC_PARAMETER_LIST = 143,
  Element_Kind_TYPEDEF = 144,
  Element_Kind_ASM = 145,
  Element_Kind_MACRO_CALL = 146,
  Element_Kind_SIZEOF_CALL = 147,
  Element_Kind_EXTERN = 148,
  Element_Kind_NAMESPACE = 149,
  Element_Kind_USING_DIRECTIVE = 150,
  Element_Kind_DIRECTIVE = 151,
  Element_Kind_ATOMIC = 152,
  Element_Kind_STATIC_ASSERT_STATEMENT = 153,
  Element_Kind_GENERIC_SELECTION = 154,
  Element_Kind_GENERIC_SELECTOR = 155,
  Element_Kind_GENERIC_ASSOCIATION_LIST = 156,
  Element_Kind_GENERIC_ASSOCIATION = 157,
  Element_Kind_ALIGNAS = 158,
  Element_Kind_DECLTYPE = 159,
  Element_Kind_CAPTURE = 160,
  Element_Kind_LAMBDA_CAPTURE = 161,
  Element_Kind_NOEXCEPT = 162,
  Element_Kind_TYPENAME = 163,
  Element_Kind_ALIGNOF = 164,
  Element_Kind_TYPEID = 165,
  Element_Kind_SIZEOF_PACK = 166,
  Element_Kind_ENUM_CLASS = 167,
  Element_Kind_ENUM_CLASS_DECLARATION = 168,
  Element_Kind_REF_QUALIFIER = 171,
  Element_Kind_SIGNAL_ACCESS = 172,
  Element_Kind_FOREVER_STATEMENT = 173,
  Element_Kind_EMIT_STATEMENT = 174,
  Element_Kind_CPP_DIRECTIVE = 175,
  Element_Kind_CPP_FILENAME = 176,
  Element_Kind_FILE = 177,
  Element_Kind_NUMBER = 178,
  Element_Kind_CPP_NUMBER = 179,
  Element_Kind_CPP_LITERAL = 180,
  Element_Kind_CPP_MACRO_DEFN = 181,
  Element_Kind_CPP_MACRO_VALUE = 182,
  Element_Kind_ERROR = 183,
  Element_Kind_CPP_ERROR = 184,
  Element_Kind_CPP_WARNING = 185,
  Element_Kind_CPP_PRAGMA = 186,
  Element_Kind_CPP_INCLUDE = 187,
  Element_Kind_CPP_DEFINE = 188,
  Element_Kind_CPP_UNDEF = 189,
  Element_Kind_CPP_LINE = 190,
  Element_Kind_CPP_IF = 191,
  Element_Kind_CPP_IFDEF = 192,
  Element_Kind_CPP_IFNDEF = 193,
  Element_Kind_CPP_THEN = 194,
  Element_Kind_CPP_ELSE = 195,
  Element_Kind_CPP_ELIF = 196,
  Element_Kind_CPP_EMPTY = 197,
  Element_Kind_CPP_REGION = 198,
  Element_Kind_CPP_ENDREGION = 199,
  Element_Kind_USING_STMT = 200,
  Element_Kind_ESCAPE = 201,
  Element_Kind_VALUE = 202,
  Element_Kind_CPP_IMPORT = 203,
  Element_Kind_CPP_ENDIF = 204,
  Element_Kind_MARKER = 205,
  Element_Kind_ERROR_PARSE = 206,
  Element_Kind_ERROR_MODE = 207,
  Element_Kind_IMPLEMENTS = 208,
  Element_Kind_EXTENDS = 209,
  Element_Kind_IMPORT = 210,
  Element_Kind_PACKAGE = 211,
  Element_Kind_ASSERT_STATEMENT = 212,
  Element_Kind_INTERFACE = 213,
  Element_Kind_INTERFACE_DECLARATION = 214,
  Element_Kind_SYNCHRONIZED_STATEMENT = 215,
  Element_Kind_ANNOTATION = 216,
  Element_Kind_STATIC_BLOCK = 218,
  Element_Kind_CHECKED_STATEMENT = 219,
  Element_Kind_UNCHECKED_STATEMENT = 220,
  Element_Kind_ATTRIBUTE = 221,
  Element_Kind_TARGET = 222,
  Element_Kind_UNSAFE_STATEMENT = 223,
  Element_Kind_LOCK_STATEMENT = 224,
  Element_Kind_FIXED_STATEMENT = 225,
  Element_Kind_TYPEOF = 226,
  Element_Kind_USING_STATEMENT = 227,
  Element_Kind_FUNCTION_DELEGATE = 228,
  Element_Kind_CONSTRAINT = 230,
  Element_Kind_LINQ = 231,
  Element_Kind_FROM = 232,
  Element_Kind_WHERE = 233,
  Element_Kind_SELECT = 234,
  Element_Kind_LET = 235,
  Element_Kind_ORDERBY = 236,
  Element_Kind_JOIN = 237,
  Element_Kind_GROUP = 238,
  Element_Kind_IN = 239,
  Element_Kind_ON = 240,
  Element_Kind_EQUALS = 241,
  Element_Kind_BY = 242,
  Element_Kind_INTO = 243,
  Element_Kind_EMPTY = 244,
  Element_Kind_EMPTY_STMT = 245,
  Element_Kind_RECEIVER = 246,
  Element_Kind_MESSAGE = 247,
  Element_Kind_SELECTOR = 248,
  Element_Kind_PROTOCOL_LIST = 249,
  Element_Kind_CATEGORY = 250,
  Element_Kind_PROTOCOL = 251,
  Element_Kind_REQUIRED_DEFAULT = 252,
  Element_Kind_REQUIRED = 253,
  Element_Kind_OPTIONAL = 254,
  Element_Kind_ATTRIBUTE_LIST = 256,
  Element_Kind_SYNTHESIZE = 257,
  Element_Kind_DYNAMIC = 258,
  Element_Kind_ENCODE = 259,
  Element_Kind_AUTORELEASEPOOL = 260,
  Element_Kind_COMPATIBILITY_ALIAS = 261,
  Element_Kind_NIL = 262,
  Element_Kind_CLASS_INTERFACE = 263,
  Element_Kind_CLASS_IMPLEMENTATION = 264,
  Element_Kind_PROTOCOL_DECLARATION = 265,
  Element_Kind_CAST = 266,
  Element_Kind_CONST_CAST = 267,
  Element_Kind_DYNAMIC_CAST = 268,
  Element_Kind_REINTERPRET_CAST = 269,
  Element_Kind_STATIC_CAST = 270,
  Element_Kind_POSITION = 271,
  Element_Kind_CUDA_ARGUMENT_LIST = 272,
  Element_Kind_OMP_DIRECTIVE = 273,
  Element_Kind_OMP_NAME = 274,
  Element_Kind_OMP_CLAUSE = 275,
  Element_Kind_OMP_ARGUMENT_LIST = 276,
  Element_Kind_OMP_ARGUMENT = 277,
  Element_Kind_OMP_EXPRESSION = 278,
  Element_Kind_END_ELEMENT_TOKEN = 279,
  Element_Kind_MAIN = 280,
  Element_Kind_BREAK = 281,
  Element_Kind_CONTINUE = 282,
  Element_Kind_WHILE = 283,
  Element_Kind_DO = 284,
  Element_Kind_FOR = 285,
  Element_Kind_IF = 286,
  Element_Kind_GOTO = 293,
  Element_Kind_VISUAL_CXX_ASM = 295,
  Element_Kind_SIZEOF = 296,
  Element_Kind_AUTO = 298,
  Element_Kind_REGISTER = 299,
  Element_Kind_RESTRICT = 300,
  Element_Kind_IMAGINARY = 304,
  Element_Kind_NORETURN = 305,
  Element_Kind_STATIC_ASSERT = 306,
  Element_Kind_CRESTRICT = 307,
  Element_Kind_CXX_TRY = 308,
  Element_Kind_CXX_CATCH = 309,
  Element_Kind_CXX_CLASS = 310,
  Element_Kind_CONSTEXPR = 311,
  Element_Kind_THREAD_LOCAL = 313,
  Element_Kind_NULLPTR = 314,
  Element_Kind_VOID = 326,
  Element_Kind_RETURN = 327,
  Element_Kind_INCLUDE = 328,
  Element_Kind_DEFINE = 329,
  Element_Kind_ELIF = 330,
  Element_Kind_ENDIF = 331,
  Element_Kind_ERRORPREC = 332,
  Element_Kind_WARNING = 333,
  Element_Kind_IFDEF = 334,
  Element_Kind_IFNDEF = 335,
  Element_Kind_LINE = 336,
  Element_Kind_PRAGMA = 337,
  Element_Kind_UNDEF = 338,
  Element_Kind_INLINE = 339,
  Element_Kind_MACRO_TYPE_NAME = 340,
  Element_Kind_MACRO_CASE = 341,
  Element_Kind_MACRO_LABEL = 342,
  Element_Kind_SPECIFIER = 344,
  Element_Kind_TRY = 345,
  Element_Kind_CATCH = 346,
  Element_Kind_THROW = 347,
  Element_Kind_THROWS = 348,
  Element_Kind_PUBLIC = 350,
  Element_Kind_PRIVATE = 351,
  Element_Kind_PROTECTED = 352,
  Element_Kind_VIRTUAL = 353,
  Element_Kind_EXPLICIT = 356,
  Element_Kind_FOREVER = 357,
  Element_Kind_SIGNAL = 358,
  Element_Kind_EMIT = 359,
  Element_Kind_NEW = 363,
  Element_Kind_DELETE = 364,
  Element_Kind_STATIC = 365,
  Element_Kind_CONST = 366,
  Element_Kind_MUTABLE = 367,
  Element_Kind_VOLATILE = 368,
  Element_Kind_TRANSIENT = 369,
  Element_Kind_FINALLY = 372,
  Element_Kind_FINAL = 376,
  Element_Kind_ABSTRACT = 377,
  Element_Kind_SUPER = 378,
  Element_Kind_SYNCHRONIZED = 379,
  Element_Kind_NATIVE = 380,
  Element_Kind_STRICTFP = 381,
  Element_Kind_NULLLITERAL = 382,
  Element_Kind_ASSERT = 383,
  Element_Kind_FOREACH = 384,
  Element_Kind_REF = 385,
  Element_Kind_OUT = 386,
  Element_Kind_LOCK = 388,
  Element_Kind_IS = 389,
  Element_Kind_INTERNAL = 390,
  Element_Kind_SEALED = 391,
  Element_Kind_OVERRIDE = 392,
  Element_Kind_IMPLICIT = 393,
  Element_Kind_STACKALLOC = 394,
  Element_Kind_AS = 395,
  Element_Kind_DELEGATE = 396,
  Element_Kind_FIXED = 397,
  Element_Kind_CHECKED = 398,
  Element_Kind_UNCHECKED = 399,
  Element_Kind_REGION = 400,
  Element_Kind_ENDREGION = 401,
  Element_Kind_UNSAFE = 402,
  Element_Kind_READONLY = 403,
  Element_Kind_GET = 404,
  Element_Kind_SET = 405,
  Element_Kind_ADD = 406,
  Element_Kind_REMOVE = 407,
  Element_Kind_YIELD = 408,
  Element_Kind_PARTIAL = 409,
  Element_Kind_AWAIT = 410,
  Element_Kind_ASYNC = 412,
  Element_Kind_THIS = 413,
  Element_Kind_PARAMS = 414,
  Element_Kind_ALIAS = 416,
  Element_Kind_ASCENDING = 422,
  Element_Kind_DESCENDING = 423,
  Element_Kind_ATINTERFACE = 430,
  Element_Kind_ATIMPLEMENTATION = 431,
  Element_Kind_ATEND = 432,
  Element_Kind_ATPROTOCOL = 433,
  Element_Kind_ATREQUIRED = 434,
  Element_Kind_ATOPTIONAL = 435,
  Element_Kind_ATCLASS = 441,
  Element_Kind_WEAK = 443,
  Element_Kind_STRONG = 444,
  Element_Kind_OMP_OMP = 448,
  Element_Kind_SPECIAL_CHARS = 449,
  Element_Kind_Element_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Element_Kind_Element_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Element_Kind_IsValid(int value);
const Element_Kind Element_Kind_Kind_MIN = Element_Kind_UNIT_KIND;
const Element_Kind Element_Kind_Kind_MAX = Element_Kind_SPECIAL_CHARS;
const int Element_Kind_Kind_ARRAYSIZE = Element_Kind_Kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Element_Kind_descriptor();
inline const ::std::string& Element_Kind_Name(Element_Kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Element_Kind_descriptor(), value);
}
inline bool Element_Kind_Parse(
    const ::std::string& name, Element_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Element_Kind>(
    Element_Kind_descriptor(), name, value);
}
// ===================================================================

class Element_Unit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Element.Unit) */ {
 public:
  Element_Unit();
  virtual ~Element_Unit();

  Element_Unit(const Element_Unit& from);

  inline Element_Unit& operator=(const Element_Unit& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Element_Unit& default_instance();

  static inline const Element_Unit* internal_default_instance() {
    return reinterpret_cast<const Element_Unit*>(
               &_Element_Unit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Element_Unit* other);

  // implements Message ----------------------------------------------

  inline Element_Unit* New() const PROTOBUF_FINAL { return New(NULL); }

  Element_Unit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Element_Unit& from);
  void MergeFrom(const Element_Unit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Element_Unit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Element_Unit_LanguageType LanguageType;
  static const LanguageType ALL =
    Element_Unit_LanguageType_ALL;
  static const LanguageType OO =
    Element_Unit_LanguageType_OO;
  static const LanguageType CXX =
    Element_Unit_LanguageType_CXX;
  static const LanguageType C =
    Element_Unit_LanguageType_C;
  static const LanguageType C_FAMILY =
    Element_Unit_LanguageType_C_FAMILY;
  static const LanguageType JAVA =
    Element_Unit_LanguageType_JAVA;
  static const LanguageType CSHARP =
    Element_Unit_LanguageType_CSHARP;
  static const LanguageType OBJECTIVE_C =
    Element_Unit_LanguageType_OBJECTIVE_C;
  static inline bool LanguageType_IsValid(int value) {
    return Element_Unit_LanguageType_IsValid(value);
  }
  static const LanguageType LanguageType_MIN =
    Element_Unit_LanguageType_LanguageType_MIN;
  static const LanguageType LanguageType_MAX =
    Element_Unit_LanguageType_LanguageType_MAX;
  static const int LanguageType_ARRAYSIZE =
    Element_Unit_LanguageType_LanguageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LanguageType_descriptor() {
    return Element_Unit_LanguageType_descriptor();
  }
  static inline const ::std::string& LanguageType_Name(LanguageType value) {
    return Element_Unit_LanguageType_Name(value);
  }
  static inline bool LanguageType_Parse(const ::std::string& name,
      LanguageType* value) {
    return Element_Unit_LanguageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string filename = 1;
  void clear_filename();
  static const int kFilenameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // string revision = 2;
  void clear_revision();
  static const int kRevisionFieldNumber = 2;
  const ::std::string& revision() const;
  void set_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_revision(::std::string&& value);
  #endif
  void set_revision(const char* value);
  void set_revision(const char* value, size_t size);
  ::std::string* mutable_revision();
  ::std::string* release_revision();
  void set_allocated_revision(::std::string* revision);

  // .fast.Element.Unit.LanguageType language = 3;
  void clear_language();
  static const int kLanguageFieldNumber = 3;
  ::fast::Element_Unit_LanguageType language() const;
  void set_language(::fast::Element_Unit_LanguageType value);

  // int32 item = 4;
  void clear_item();
  static const int kItemFieldNumber = 4;
  ::google::protobuf::int32 item() const;
  void set_item(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fast.Element.Unit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::google::protobuf::internal::ArenaStringPtr revision_;
  int language_;
  ::google::protobuf::int32 item_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Element_Literal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Element.Literal) */ {
 public:
  Element_Literal();
  virtual ~Element_Literal();

  Element_Literal(const Element_Literal& from);

  inline Element_Literal& operator=(const Element_Literal& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Element_Literal& default_instance();

  static inline const Element_Literal* internal_default_instance() {
    return reinterpret_cast<const Element_Literal*>(
               &_Element_Literal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Element_Literal* other);

  // implements Message ----------------------------------------------

  inline Element_Literal* New() const PROTOBUF_FINAL { return New(NULL); }

  Element_Literal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Element_Literal& from);
  void MergeFrom(const Element_Literal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Element_Literal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Element_Literal_LiteralType LiteralType;
  static const LiteralType number_type =
    Element_Literal_LiteralType_number_type;
  static const LiteralType char_type =
    Element_Literal_LiteralType_char_type;
  static const LiteralType string_type =
    Element_Literal_LiteralType_string_type;
  static const LiteralType boolean_type =
    Element_Literal_LiteralType_boolean_type;
  static const LiteralType null_type =
    Element_Literal_LiteralType_null_type;
  static inline bool LiteralType_IsValid(int value) {
    return Element_Literal_LiteralType_IsValid(value);
  }
  static const LiteralType LiteralType_MIN =
    Element_Literal_LiteralType_LiteralType_MIN;
  static const LiteralType LiteralType_MAX =
    Element_Literal_LiteralType_LiteralType_MAX;
  static const int LiteralType_ARRAYSIZE =
    Element_Literal_LiteralType_LiteralType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LiteralType_descriptor() {
    return Element_Literal_LiteralType_descriptor();
  }
  static inline const ::std::string& LiteralType_Name(LiteralType value) {
    return Element_Literal_LiteralType_Name(value);
  }
  static inline bool LiteralType_Parse(const ::std::string& name,
      LiteralType* value) {
    return Element_Literal_LiteralType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .fast.Element.Literal.LiteralType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::fast::Element_Literal_LiteralType type() const;
  void set_type(::fast::Element_Literal_LiteralType value);

  // @@protoc_insertion_point(class_scope:fast.Element.Literal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Element : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Element) */ {
 public:
  Element();
  virtual ~Element();

  Element(const Element& from);

  inline Element& operator=(const Element& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Element& default_instance();

  enum ExtraCase {
    kUnit = 5,
    kLiteral = 6,
    EXTRA_NOT_SET = 0,
  };

  static inline const Element* internal_default_instance() {
    return reinterpret_cast<const Element*>(
               &_Element_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Element* other);

  // implements Message ----------------------------------------------

  inline Element* New() const PROTOBUF_FINAL { return New(NULL); }

  Element* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Element& from);
  void MergeFrom(const Element& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Element* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Element_Unit Unit;
  typedef Element_Literal Literal;

  typedef Element_Kind Kind;
  static const Kind UNIT_KIND =
    Element_Kind_UNIT_KIND;
  static const Kind DECL =
    Element_Kind_DECL;
  static const Kind DECL_STMT =
    Element_Kind_DECL_STMT;
  static const Kind INIT =
    Element_Kind_INIT;
  static const Kind EXPR =
    Element_Kind_EXPR;
  static const Kind EXPR_STMT =
    Element_Kind_EXPR_STMT;
  static const Kind COMMENT =
    Element_Kind_COMMENT;
  static const Kind CALL =
    Element_Kind_CALL;
  static const Kind CONTROL =
    Element_Kind_CONTROL;
  static const Kind INCR =
    Element_Kind_INCR;
  static const Kind NONE =
    Element_Kind_NONE;
  static const Kind VARIABLE =
    Element_Kind_VARIABLE;
  static const Kind FUNCTION =
    Element_Kind_FUNCTION;
  static const Kind FUNCTION_DECL =
    Element_Kind_FUNCTION_DECL;
  static const Kind CONSTRUCTOR =
    Element_Kind_CONSTRUCTOR;
  static const Kind CONSTRUCTOR_DECL =
    Element_Kind_CONSTRUCTOR_DECL;
  static const Kind DESTRUCTOR =
    Element_Kind_DESTRUCTOR;
  static const Kind DESTRUCTOR_DECL =
    Element_Kind_DESTRUCTOR_DECL;
  static const Kind MACRO =
    Element_Kind_MACRO;
  static const Kind SINGLE_MACRO =
    Element_Kind_SINGLE_MACRO;
  static const Kind NULLOPERATOR =
    Element_Kind_NULLOPERATOR;
  static const Kind ENUM_DEFN =
    Element_Kind_ENUM_DEFN;
  static const Kind ENUM_DECL =
    Element_Kind_ENUM_DECL;
  static const Kind GLOBAL_ATTRIBUTE =
    Element_Kind_GLOBAL_ATTRIBUTE;
  static const Kind PROPERTY_ACCESSOR =
    Element_Kind_PROPERTY_ACCESSOR;
  static const Kind PROPERTY_ACCESSOR_DECL =
    Element_Kind_PROPERTY_ACCESSOR_DECL;
  static const Kind EXPRESSION =
    Element_Kind_EXPRESSION;
  static const Kind CLASS_DEFN =
    Element_Kind_CLASS_DEFN;
  static const Kind CLASS_DECL =
    Element_Kind_CLASS_DECL;
  static const Kind UNION_DEFN =
    Element_Kind_UNION_DEFN;
  static const Kind UNION_DECL =
    Element_Kind_UNION_DECL;
  static const Kind STRUCT_DEFN =
    Element_Kind_STRUCT_DEFN;
  static const Kind STRUCT_DECL =
    Element_Kind_STRUCT_DECL;
  static const Kind INTERFACE_DEFN =
    Element_Kind_INTERFACE_DEFN;
  static const Kind INTERFACE_DECL =
    Element_Kind_INTERFACE_DECL;
  static const Kind ACCESS_REGION =
    Element_Kind_ACCESS_REGION;
  static const Kind USING =
    Element_Kind_USING;
  static const Kind OPERATOR_FUNCTION =
    Element_Kind_OPERATOR_FUNCTION;
  static const Kind OPERATOR_FUNCTION_DECL =
    Element_Kind_OPERATOR_FUNCTION_DECL;
  static const Kind EVENT =
    Element_Kind_EVENT;
  static const Kind PROPERTY =
    Element_Kind_PROPERTY;
  static const Kind ANNOTATION_DEFN =
    Element_Kind_ANNOTATION_DEFN;
  static const Kind GLOBAL_TEMPLATE =
    Element_Kind_GLOBAL_TEMPLATE;
  static const Kind UNIT =
    Element_Kind_UNIT;
  static const Kind TART_ELEMENT_TOKEN =
    Element_Kind_TART_ELEMENT_TOKEN;
  static const Kind NOP =
    Element_Kind_NOP;
  static const Kind STRING =
    Element_Kind_STRING;
  static const Kind CHAR =
    Element_Kind_CHAR;
  static const Kind LITERAL =
    Element_Kind_LITERAL;
  static const Kind BOOLEAN =
    Element_Kind_BOOLEAN;
  static const Kind NULL_ =
    Element_Kind_NULL_;
  static const Kind COMPLEX =
    Element_Kind_COMPLEX;
  static const Kind OPERATOR =
    Element_Kind_OPERATOR;
  static const Kind MODIFIER =
    Element_Kind_MODIFIER;
  static const Kind NAME =
    Element_Kind_NAME;
  static const Kind ONAME =
    Element_Kind_ONAME;
  static const Kind CNAME =
    Element_Kind_CNAME;
  static const Kind TYPE =
    Element_Kind_TYPE;
  static const Kind TYPEPREV =
    Element_Kind_TYPEPREV;
  static const Kind CONDITION =
    Element_Kind_CONDITION;
  static const Kind BLOCK =
    Element_Kind_BLOCK;
  static const Kind PSEUDO_BLOCK =
    Element_Kind_PSEUDO_BLOCK;
  static const Kind INDEX =
    Element_Kind_INDEX;
  static const Kind ENUM =
    Element_Kind_ENUM;
  static const Kind ENUM_DECLARATION =
    Element_Kind_ENUM_DECLARATION;
  static const Kind IF_STATEMENT =
    Element_Kind_IF_STATEMENT;
  static const Kind TERNARY =
    Element_Kind_TERNARY;
  static const Kind THEN =
    Element_Kind_THEN;
  static const Kind ELSE =
    Element_Kind_ELSE;
  static const Kind ELSEIF =
    Element_Kind_ELSEIF;
  static const Kind WHILE_STATEMENT =
    Element_Kind_WHILE_STATEMENT;
  static const Kind DO_STATEMENT =
    Element_Kind_DO_STATEMENT;
  static const Kind FOR_STATEMENT =
    Element_Kind_FOR_STATEMENT;
  static const Kind FOREACH_STATEMENT =
    Element_Kind_FOREACH_STATEMENT;
  static const Kind FOR_CONTROL =
    Element_Kind_FOR_CONTROL;
  static const Kind FOR_INITIALIZATION =
    Element_Kind_FOR_INITIALIZATION;
  static const Kind FOR_CONDITION =
    Element_Kind_FOR_CONDITION;
  static const Kind FOR_INCREMENT =
    Element_Kind_FOR_INCREMENT;
  static const Kind FOR_LIKE_CONTROL =
    Element_Kind_FOR_LIKE_CONTROL;
  static const Kind EXPRESSION_STATEMENT =
    Element_Kind_EXPRESSION_STATEMENT;
  static const Kind FUNCTION_CALL =
    Element_Kind_FUNCTION_CALL;
  static const Kind DECLARATION_STATEMENT =
    Element_Kind_DECLARATION_STATEMENT;
  static const Kind DECLARATION =
    Element_Kind_DECLARATION;
  static const Kind DECLARATION_INITIALIZATION =
    Element_Kind_DECLARATION_INITIALIZATION;
  static const Kind DECLARATION_RANGE =
    Element_Kind_DECLARATION_RANGE;
  static const Kind RANGE =
    Element_Kind_RANGE;
  static const Kind GOTO_STATEMENT =
    Element_Kind_GOTO_STATEMENT;
  static const Kind CONTINUE_STATEMENT =
    Element_Kind_CONTINUE_STATEMENT;
  static const Kind BREAK_STATEMENT =
    Element_Kind_BREAK_STATEMENT;
  static const Kind LABEL_STATEMENT =
    Element_Kind_LABEL_STATEMENT;
  static const Kind LABEL =
    Element_Kind_LABEL;
  static const Kind SWITCH =
    Element_Kind_SWITCH;
  static const Kind CASE =
    Element_Kind_CASE;
  static const Kind DEFAULT =
    Element_Kind_DEFAULT;
  static const Kind FUNCTION_DEFINITION =
    Element_Kind_FUNCTION_DEFINITION;
  static const Kind FUNCTION_DECLARATION =
    Element_Kind_FUNCTION_DECLARATION;
  static const Kind LAMBDA =
    Element_Kind_LAMBDA;
  static const Kind FUNCTION_LAMBDA =
    Element_Kind_FUNCTION_LAMBDA;
  static const Kind FUNCTION_SPECIFIER =
    Element_Kind_FUNCTION_SPECIFIER;
  static const Kind RETURN_STATEMENT =
    Element_Kind_RETURN_STATEMENT;
  static const Kind PARAMETER_LIST =
    Element_Kind_PARAMETER_LIST;
  static const Kind PARAMETER =
    Element_Kind_PARAMETER;
  static const Kind KRPARAMETER_LIST =
    Element_Kind_KRPARAMETER_LIST;
  static const Kind KRPARAMETER =
    Element_Kind_KRPARAMETER;
  static const Kind ARGUMENT_LIST =
    Element_Kind_ARGUMENT_LIST;
  static const Kind ARGUMENT =
    Element_Kind_ARGUMENT;
  static const Kind PSEUDO_PARAMETER_LIST =
    Element_Kind_PSEUDO_PARAMETER_LIST;
  static const Kind INDEXER_PARAMETER_LIST =
    Element_Kind_INDEXER_PARAMETER_LIST;
  static const Kind CLASS =
    Element_Kind_CLASS;
  static const Kind CLASS_DECLARATION =
    Element_Kind_CLASS_DECLARATION;
  static const Kind STRUCT =
    Element_Kind_STRUCT;
  static const Kind STRUCT_DECLARATION =
    Element_Kind_STRUCT_DECLARATION;
  static const Kind UNION =
    Element_Kind_UNION;
  static const Kind UNION_DECLARATION =
    Element_Kind_UNION_DECLARATION;
  static const Kind DERIVATION_LIST =
    Element_Kind_DERIVATION_LIST;
  static const Kind PUBLIC_ACCESS =
    Element_Kind_PUBLIC_ACCESS;
  static const Kind PUBLIC_ACCESS_DEFAULT =
    Element_Kind_PUBLIC_ACCESS_DEFAULT;
  static const Kind PRIVATE_ACCESS =
    Element_Kind_PRIVATE_ACCESS;
  static const Kind PRIVATE_ACCESS_DEFAULT =
    Element_Kind_PRIVATE_ACCESS_DEFAULT;
  static const Kind PROTECTED_ACCESS =
    Element_Kind_PROTECTED_ACCESS;
  static const Kind PROTECTED_ACCESS_DEFAULT =
    Element_Kind_PROTECTED_ACCESS_DEFAULT;
  static const Kind MEMBER_INIT_LIST =
    Element_Kind_MEMBER_INIT_LIST;
  static const Kind MEMBER_INITIALIZATION_LIST =
    Element_Kind_MEMBER_INITIALIZATION_LIST;
  static const Kind MEMBER_INITIALIZATION =
    Element_Kind_MEMBER_INITIALIZATION;
  static const Kind CONSTRUCTOR_DEFINITION =
    Element_Kind_CONSTRUCTOR_DEFINITION;
  static const Kind CONSTRUCTOR_DECLARATION =
    Element_Kind_CONSTRUCTOR_DECLARATION;
  static const Kind DESTRUCTOR_DEFINITION =
    Element_Kind_DESTRUCTOR_DEFINITION;
  static const Kind DESTRUCTOR_DECLARATION =
    Element_Kind_DESTRUCTOR_DECLARATION;
  static const Kind FRIEND =
    Element_Kind_FRIEND;
  static const Kind CLASS_SPECIFIER =
    Element_Kind_CLASS_SPECIFIER;
  static const Kind TRY_BLOCK =
    Element_Kind_TRY_BLOCK;
  static const Kind CATCH_BLOCK =
    Element_Kind_CATCH_BLOCK;
  static const Kind FINALLY_BLOCK =
    Element_Kind_FINALLY_BLOCK;
  static const Kind THROW_STATEMENT =
    Element_Kind_THROW_STATEMENT;
  static const Kind THROW_SPECIFIER =
    Element_Kind_THROW_SPECIFIER;
  static const Kind THROW_SPECIFIER_JAVA =
    Element_Kind_THROW_SPECIFIER_JAVA;
  static const Kind TEMPLATE =
    Element_Kind_TEMPLATE;
  static const Kind GENERIC_ARGUMENT =
    Element_Kind_GENERIC_ARGUMENT;
  static const Kind GENERIC_ARGUMENT_LIST =
    Element_Kind_GENERIC_ARGUMENT_LIST;
  static const Kind TEMPLATE_PARAMETER =
    Element_Kind_TEMPLATE_PARAMETER;
  static const Kind TEMPLATE_PARAMETER_LIST =
    Element_Kind_TEMPLATE_PARAMETER_LIST;
  static const Kind GENERIC_PARAMETER =
    Element_Kind_GENERIC_PARAMETER;
  static const Kind GENERIC_PARAMETER_LIST =
    Element_Kind_GENERIC_PARAMETER_LIST;
  static const Kind TYPEDEF =
    Element_Kind_TYPEDEF;
  static const Kind ASM =
    Element_Kind_ASM;
  static const Kind MACRO_CALL =
    Element_Kind_MACRO_CALL;
  static const Kind SIZEOF_CALL =
    Element_Kind_SIZEOF_CALL;
  static const Kind EXTERN =
    Element_Kind_EXTERN;
  static const Kind NAMESPACE =
    Element_Kind_NAMESPACE;
  static const Kind USING_DIRECTIVE =
    Element_Kind_USING_DIRECTIVE;
  static const Kind DIRECTIVE =
    Element_Kind_DIRECTIVE;
  static const Kind ATOMIC =
    Element_Kind_ATOMIC;
  static const Kind STATIC_ASSERT_STATEMENT =
    Element_Kind_STATIC_ASSERT_STATEMENT;
  static const Kind GENERIC_SELECTION =
    Element_Kind_GENERIC_SELECTION;
  static const Kind GENERIC_SELECTOR =
    Element_Kind_GENERIC_SELECTOR;
  static const Kind GENERIC_ASSOCIATION_LIST =
    Element_Kind_GENERIC_ASSOCIATION_LIST;
  static const Kind GENERIC_ASSOCIATION =
    Element_Kind_GENERIC_ASSOCIATION;
  static const Kind ALIGNAS =
    Element_Kind_ALIGNAS;
  static const Kind DECLTYPE =
    Element_Kind_DECLTYPE;
  static const Kind CAPTURE =
    Element_Kind_CAPTURE;
  static const Kind LAMBDA_CAPTURE =
    Element_Kind_LAMBDA_CAPTURE;
  static const Kind NOEXCEPT =
    Element_Kind_NOEXCEPT;
  static const Kind TYPENAME =
    Element_Kind_TYPENAME;
  static const Kind ALIGNOF =
    Element_Kind_ALIGNOF;
  static const Kind TYPEID =
    Element_Kind_TYPEID;
  static const Kind SIZEOF_PACK =
    Element_Kind_SIZEOF_PACK;
  static const Kind ENUM_CLASS =
    Element_Kind_ENUM_CLASS;
  static const Kind ENUM_CLASS_DECLARATION =
    Element_Kind_ENUM_CLASS_DECLARATION;
  static const Kind REF_QUALIFIER =
    Element_Kind_REF_QUALIFIER;
  static const Kind SIGNAL_ACCESS =
    Element_Kind_SIGNAL_ACCESS;
  static const Kind FOREVER_STATEMENT =
    Element_Kind_FOREVER_STATEMENT;
  static const Kind EMIT_STATEMENT =
    Element_Kind_EMIT_STATEMENT;
  static const Kind CPP_DIRECTIVE =
    Element_Kind_CPP_DIRECTIVE;
  static const Kind CPP_FILENAME =
    Element_Kind_CPP_FILENAME;
  static const Kind FILE =
    Element_Kind_FILE;
  static const Kind NUMBER =
    Element_Kind_NUMBER;
  static const Kind CPP_NUMBER =
    Element_Kind_CPP_NUMBER;
  static const Kind CPP_LITERAL =
    Element_Kind_CPP_LITERAL;
  static const Kind CPP_MACRO_DEFN =
    Element_Kind_CPP_MACRO_DEFN;
  static const Kind CPP_MACRO_VALUE =
    Element_Kind_CPP_MACRO_VALUE;
  static const Kind ERROR =
    Element_Kind_ERROR;
  static const Kind CPP_ERROR =
    Element_Kind_CPP_ERROR;
  static const Kind CPP_WARNING =
    Element_Kind_CPP_WARNING;
  static const Kind CPP_PRAGMA =
    Element_Kind_CPP_PRAGMA;
  static const Kind CPP_INCLUDE =
    Element_Kind_CPP_INCLUDE;
  static const Kind CPP_DEFINE =
    Element_Kind_CPP_DEFINE;
  static const Kind CPP_UNDEF =
    Element_Kind_CPP_UNDEF;
  static const Kind CPP_LINE =
    Element_Kind_CPP_LINE;
  static const Kind CPP_IF =
    Element_Kind_CPP_IF;
  static const Kind CPP_IFDEF =
    Element_Kind_CPP_IFDEF;
  static const Kind CPP_IFNDEF =
    Element_Kind_CPP_IFNDEF;
  static const Kind CPP_THEN =
    Element_Kind_CPP_THEN;
  static const Kind CPP_ELSE =
    Element_Kind_CPP_ELSE;
  static const Kind CPP_ELIF =
    Element_Kind_CPP_ELIF;
  static const Kind CPP_EMPTY =
    Element_Kind_CPP_EMPTY;
  static const Kind CPP_REGION =
    Element_Kind_CPP_REGION;
  static const Kind CPP_ENDREGION =
    Element_Kind_CPP_ENDREGION;
  static const Kind USING_STMT =
    Element_Kind_USING_STMT;
  static const Kind ESCAPE =
    Element_Kind_ESCAPE;
  static const Kind VALUE =
    Element_Kind_VALUE;
  static const Kind CPP_IMPORT =
    Element_Kind_CPP_IMPORT;
  static const Kind CPP_ENDIF =
    Element_Kind_CPP_ENDIF;
  static const Kind MARKER =
    Element_Kind_MARKER;
  static const Kind ERROR_PARSE =
    Element_Kind_ERROR_PARSE;
  static const Kind ERROR_MODE =
    Element_Kind_ERROR_MODE;
  static const Kind IMPLEMENTS =
    Element_Kind_IMPLEMENTS;
  static const Kind EXTENDS =
    Element_Kind_EXTENDS;
  static const Kind IMPORT =
    Element_Kind_IMPORT;
  static const Kind PACKAGE =
    Element_Kind_PACKAGE;
  static const Kind ASSERT_STATEMENT =
    Element_Kind_ASSERT_STATEMENT;
  static const Kind INTERFACE =
    Element_Kind_INTERFACE;
  static const Kind INTERFACE_DECLARATION =
    Element_Kind_INTERFACE_DECLARATION;
  static const Kind SYNCHRONIZED_STATEMENT =
    Element_Kind_SYNCHRONIZED_STATEMENT;
  static const Kind ANNOTATION =
    Element_Kind_ANNOTATION;
  static const Kind STATIC_BLOCK =
    Element_Kind_STATIC_BLOCK;
  static const Kind CHECKED_STATEMENT =
    Element_Kind_CHECKED_STATEMENT;
  static const Kind UNCHECKED_STATEMENT =
    Element_Kind_UNCHECKED_STATEMENT;
  static const Kind ATTRIBUTE =
    Element_Kind_ATTRIBUTE;
  static const Kind TARGET =
    Element_Kind_TARGET;
  static const Kind UNSAFE_STATEMENT =
    Element_Kind_UNSAFE_STATEMENT;
  static const Kind LOCK_STATEMENT =
    Element_Kind_LOCK_STATEMENT;
  static const Kind FIXED_STATEMENT =
    Element_Kind_FIXED_STATEMENT;
  static const Kind TYPEOF =
    Element_Kind_TYPEOF;
  static const Kind USING_STATEMENT =
    Element_Kind_USING_STATEMENT;
  static const Kind FUNCTION_DELEGATE =
    Element_Kind_FUNCTION_DELEGATE;
  static const Kind CONSTRAINT =
    Element_Kind_CONSTRAINT;
  static const Kind LINQ =
    Element_Kind_LINQ;
  static const Kind FROM =
    Element_Kind_FROM;
  static const Kind WHERE =
    Element_Kind_WHERE;
  static const Kind SELECT =
    Element_Kind_SELECT;
  static const Kind LET =
    Element_Kind_LET;
  static const Kind ORDERBY =
    Element_Kind_ORDERBY;
  static const Kind JOIN =
    Element_Kind_JOIN;
  static const Kind GROUP =
    Element_Kind_GROUP;
  static const Kind IN =
    Element_Kind_IN;
  static const Kind ON =
    Element_Kind_ON;
  static const Kind EQUALS =
    Element_Kind_EQUALS;
  static const Kind BY =
    Element_Kind_BY;
  static const Kind INTO =
    Element_Kind_INTO;
  static const Kind EMPTY =
    Element_Kind_EMPTY;
  static const Kind EMPTY_STMT =
    Element_Kind_EMPTY_STMT;
  static const Kind RECEIVER =
    Element_Kind_RECEIVER;
  static const Kind MESSAGE =
    Element_Kind_MESSAGE;
  static const Kind SELECTOR =
    Element_Kind_SELECTOR;
  static const Kind PROTOCOL_LIST =
    Element_Kind_PROTOCOL_LIST;
  static const Kind CATEGORY =
    Element_Kind_CATEGORY;
  static const Kind PROTOCOL =
    Element_Kind_PROTOCOL;
  static const Kind REQUIRED_DEFAULT =
    Element_Kind_REQUIRED_DEFAULT;
  static const Kind REQUIRED =
    Element_Kind_REQUIRED;
  static const Kind OPTIONAL =
    Element_Kind_OPTIONAL;
  static const Kind ATTRIBUTE_LIST =
    Element_Kind_ATTRIBUTE_LIST;
  static const Kind SYNTHESIZE =
    Element_Kind_SYNTHESIZE;
  static const Kind DYNAMIC =
    Element_Kind_DYNAMIC;
  static const Kind ENCODE =
    Element_Kind_ENCODE;
  static const Kind AUTORELEASEPOOL =
    Element_Kind_AUTORELEASEPOOL;
  static const Kind COMPATIBILITY_ALIAS =
    Element_Kind_COMPATIBILITY_ALIAS;
  static const Kind NIL =
    Element_Kind_NIL;
  static const Kind CLASS_INTERFACE =
    Element_Kind_CLASS_INTERFACE;
  static const Kind CLASS_IMPLEMENTATION =
    Element_Kind_CLASS_IMPLEMENTATION;
  static const Kind PROTOCOL_DECLARATION =
    Element_Kind_PROTOCOL_DECLARATION;
  static const Kind CAST =
    Element_Kind_CAST;
  static const Kind CONST_CAST =
    Element_Kind_CONST_CAST;
  static const Kind DYNAMIC_CAST =
    Element_Kind_DYNAMIC_CAST;
  static const Kind REINTERPRET_CAST =
    Element_Kind_REINTERPRET_CAST;
  static const Kind STATIC_CAST =
    Element_Kind_STATIC_CAST;
  static const Kind POSITION =
    Element_Kind_POSITION;
  static const Kind CUDA_ARGUMENT_LIST =
    Element_Kind_CUDA_ARGUMENT_LIST;
  static const Kind OMP_DIRECTIVE =
    Element_Kind_OMP_DIRECTIVE;
  static const Kind OMP_NAME =
    Element_Kind_OMP_NAME;
  static const Kind OMP_CLAUSE =
    Element_Kind_OMP_CLAUSE;
  static const Kind OMP_ARGUMENT_LIST =
    Element_Kind_OMP_ARGUMENT_LIST;
  static const Kind OMP_ARGUMENT =
    Element_Kind_OMP_ARGUMENT;
  static const Kind OMP_EXPRESSION =
    Element_Kind_OMP_EXPRESSION;
  static const Kind END_ELEMENT_TOKEN =
    Element_Kind_END_ELEMENT_TOKEN;
  static const Kind MAIN =
    Element_Kind_MAIN;
  static const Kind BREAK =
    Element_Kind_BREAK;
  static const Kind CONTINUE =
    Element_Kind_CONTINUE;
  static const Kind WHILE =
    Element_Kind_WHILE;
  static const Kind DO =
    Element_Kind_DO;
  static const Kind FOR =
    Element_Kind_FOR;
  static const Kind IF =
    Element_Kind_IF;
  static const Kind GOTO =
    Element_Kind_GOTO;
  static const Kind VISUAL_CXX_ASM =
    Element_Kind_VISUAL_CXX_ASM;
  static const Kind SIZEOF =
    Element_Kind_SIZEOF;
  static const Kind AUTO =
    Element_Kind_AUTO;
  static const Kind REGISTER =
    Element_Kind_REGISTER;
  static const Kind RESTRICT =
    Element_Kind_RESTRICT;
  static const Kind IMAGINARY =
    Element_Kind_IMAGINARY;
  static const Kind NORETURN =
    Element_Kind_NORETURN;
  static const Kind STATIC_ASSERT =
    Element_Kind_STATIC_ASSERT;
  static const Kind CRESTRICT =
    Element_Kind_CRESTRICT;
  static const Kind CXX_TRY =
    Element_Kind_CXX_TRY;
  static const Kind CXX_CATCH =
    Element_Kind_CXX_CATCH;
  static const Kind CXX_CLASS =
    Element_Kind_CXX_CLASS;
  static const Kind CONSTEXPR =
    Element_Kind_CONSTEXPR;
  static const Kind THREAD_LOCAL =
    Element_Kind_THREAD_LOCAL;
  static const Kind NULLPTR =
    Element_Kind_NULLPTR;
  static const Kind VOID =
    Element_Kind_VOID;
  static const Kind RETURN =
    Element_Kind_RETURN;
  static const Kind INCLUDE =
    Element_Kind_INCLUDE;
  static const Kind DEFINE =
    Element_Kind_DEFINE;
  static const Kind ELIF =
    Element_Kind_ELIF;
  static const Kind ENDIF =
    Element_Kind_ENDIF;
  static const Kind ERRORPREC =
    Element_Kind_ERRORPREC;
  static const Kind WARNING =
    Element_Kind_WARNING;
  static const Kind IFDEF =
    Element_Kind_IFDEF;
  static const Kind IFNDEF =
    Element_Kind_IFNDEF;
  static const Kind LINE =
    Element_Kind_LINE;
  static const Kind PRAGMA =
    Element_Kind_PRAGMA;
  static const Kind UNDEF =
    Element_Kind_UNDEF;
  static const Kind INLINE =
    Element_Kind_INLINE;
  static const Kind MACRO_TYPE_NAME =
    Element_Kind_MACRO_TYPE_NAME;
  static const Kind MACRO_CASE =
    Element_Kind_MACRO_CASE;
  static const Kind MACRO_LABEL =
    Element_Kind_MACRO_LABEL;
  static const Kind SPECIFIER =
    Element_Kind_SPECIFIER;
  static const Kind TRY =
    Element_Kind_TRY;
  static const Kind CATCH =
    Element_Kind_CATCH;
  static const Kind THROW =
    Element_Kind_THROW;
  static const Kind THROWS =
    Element_Kind_THROWS;
  static const Kind PUBLIC =
    Element_Kind_PUBLIC;
  static const Kind PRIVATE =
    Element_Kind_PRIVATE;
  static const Kind PROTECTED =
    Element_Kind_PROTECTED;
  static const Kind VIRTUAL =
    Element_Kind_VIRTUAL;
  static const Kind EXPLICIT =
    Element_Kind_EXPLICIT;
  static const Kind FOREVER =
    Element_Kind_FOREVER;
  static const Kind SIGNAL =
    Element_Kind_SIGNAL;
  static const Kind EMIT =
    Element_Kind_EMIT;
  static const Kind NEW =
    Element_Kind_NEW;
  static const Kind DELETE =
    Element_Kind_DELETE;
  static const Kind STATIC =
    Element_Kind_STATIC;
  static const Kind CONST =
    Element_Kind_CONST;
  static const Kind MUTABLE =
    Element_Kind_MUTABLE;
  static const Kind VOLATILE =
    Element_Kind_VOLATILE;
  static const Kind TRANSIENT =
    Element_Kind_TRANSIENT;
  static const Kind FINALLY =
    Element_Kind_FINALLY;
  static const Kind FINAL =
    Element_Kind_FINAL;
  static const Kind ABSTRACT =
    Element_Kind_ABSTRACT;
  static const Kind SUPER =
    Element_Kind_SUPER;
  static const Kind SYNCHRONIZED =
    Element_Kind_SYNCHRONIZED;
  static const Kind NATIVE =
    Element_Kind_NATIVE;
  static const Kind STRICTFP =
    Element_Kind_STRICTFP;
  static const Kind NULLLITERAL =
    Element_Kind_NULLLITERAL;
  static const Kind ASSERT =
    Element_Kind_ASSERT;
  static const Kind FOREACH =
    Element_Kind_FOREACH;
  static const Kind REF =
    Element_Kind_REF;
  static const Kind OUT =
    Element_Kind_OUT;
  static const Kind LOCK =
    Element_Kind_LOCK;
  static const Kind IS =
    Element_Kind_IS;
  static const Kind INTERNAL =
    Element_Kind_INTERNAL;
  static const Kind SEALED =
    Element_Kind_SEALED;
  static const Kind OVERRIDE =
    Element_Kind_OVERRIDE;
  static const Kind IMPLICIT =
    Element_Kind_IMPLICIT;
  static const Kind STACKALLOC =
    Element_Kind_STACKALLOC;
  static const Kind AS =
    Element_Kind_AS;
  static const Kind DELEGATE =
    Element_Kind_DELEGATE;
  static const Kind FIXED =
    Element_Kind_FIXED;
  static const Kind CHECKED =
    Element_Kind_CHECKED;
  static const Kind UNCHECKED =
    Element_Kind_UNCHECKED;
  static const Kind REGION =
    Element_Kind_REGION;
  static const Kind ENDREGION =
    Element_Kind_ENDREGION;
  static const Kind UNSAFE =
    Element_Kind_UNSAFE;
  static const Kind READONLY =
    Element_Kind_READONLY;
  static const Kind GET =
    Element_Kind_GET;
  static const Kind SET =
    Element_Kind_SET;
  static const Kind ADD =
    Element_Kind_ADD;
  static const Kind REMOVE =
    Element_Kind_REMOVE;
  static const Kind YIELD =
    Element_Kind_YIELD;
  static const Kind PARTIAL =
    Element_Kind_PARTIAL;
  static const Kind AWAIT =
    Element_Kind_AWAIT;
  static const Kind ASYNC =
    Element_Kind_ASYNC;
  static const Kind THIS =
    Element_Kind_THIS;
  static const Kind PARAMS =
    Element_Kind_PARAMS;
  static const Kind ALIAS =
    Element_Kind_ALIAS;
  static const Kind ASCENDING =
    Element_Kind_ASCENDING;
  static const Kind DESCENDING =
    Element_Kind_DESCENDING;
  static const Kind ATINTERFACE =
    Element_Kind_ATINTERFACE;
  static const Kind ATIMPLEMENTATION =
    Element_Kind_ATIMPLEMENTATION;
  static const Kind ATEND =
    Element_Kind_ATEND;
  static const Kind ATPROTOCOL =
    Element_Kind_ATPROTOCOL;
  static const Kind ATREQUIRED =
    Element_Kind_ATREQUIRED;
  static const Kind ATOPTIONAL =
    Element_Kind_ATOPTIONAL;
  static const Kind ATCLASS =
    Element_Kind_ATCLASS;
  static const Kind WEAK =
    Element_Kind_WEAK;
  static const Kind STRONG =
    Element_Kind_STRONG;
  static const Kind OMP_OMP =
    Element_Kind_OMP_OMP;
  static const Kind SPECIAL_CHARS =
    Element_Kind_SPECIAL_CHARS;
  static inline bool Kind_IsValid(int value) {
    return Element_Kind_IsValid(value);
  }
  static const Kind Kind_MIN =
    Element_Kind_Kind_MIN;
  static const Kind Kind_MAX =
    Element_Kind_Kind_MAX;
  static const int Kind_ARRAYSIZE =
    Element_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Kind_descriptor() {
    return Element_Kind_descriptor();
  }
  static inline const ::std::string& Kind_Name(Kind value) {
    return Element_Kind_Name(value);
  }
  static inline bool Kind_Parse(const ::std::string& name,
      Kind* value) {
    return Element_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .fast.Element child = 4;
  int child_size() const;
  void clear_child();
  static const int kChildFieldNumber = 4;
  const ::fast::Element& child(int index) const;
  ::fast::Element* mutable_child(int index);
  ::fast::Element* add_child();
  ::google::protobuf::RepeatedPtrField< ::fast::Element >*
      mutable_child();
  const ::google::protobuf::RepeatedPtrField< ::fast::Element >&
      child() const;

  // string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // string tail = 3;
  void clear_tail();
  static const int kTailFieldNumber = 3;
  const ::std::string& tail() const;
  void set_tail(const ::std::string& value);
  #if LANG_CXX11
  void set_tail(::std::string&& value);
  #endif
  void set_tail(const char* value);
  void set_tail(const char* value, size_t size);
  ::std::string* mutable_tail();
  ::std::string* release_tail();
  void set_allocated_tail(::std::string* tail);

  // .fast.Element.Kind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::fast::Element_Kind kind() const;
  void set_kind(::fast::Element_Kind value);

  // int32 line = 7;
  void clear_line();
  static const int kLineFieldNumber = 7;
  ::google::protobuf::int32 line() const;
  void set_line(::google::protobuf::int32 value);

  // int32 column = 8;
  void clear_column();
  static const int kColumnFieldNumber = 8;
  ::google::protobuf::int32 column() const;
  void set_column(::google::protobuf::int32 value);

  // .fast.Element.Unit unit = 5;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 5;
  const ::fast::Element_Unit& unit() const;
  ::fast::Element_Unit* mutable_unit();
  ::fast::Element_Unit* release_unit();
  void set_allocated_unit(::fast::Element_Unit* unit);

  // .fast.Element.Literal literal = 6;
  bool has_literal() const;
  void clear_literal();
  static const int kLiteralFieldNumber = 6;
  const ::fast::Element_Literal& literal() const;
  ::fast::Element_Literal* mutable_literal();
  ::fast::Element_Literal* release_literal();
  void set_allocated_literal(::fast::Element_Literal* literal);

  ExtraCase extra_case() const;
  // @@protoc_insertion_point(class_scope:fast.Element)
 private:
  void set_has_unit();
  void set_has_literal();

  inline bool has_extra() const;
  void clear_extra();
  inline void clear_has_extra();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fast::Element > child_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr tail_;
  int kind_;
  ::google::protobuf::int32 line_;
  ::google::protobuf::int32 column_;
  union ExtraUnion {
    ExtraUnion() {}
    ::fast::Element_Unit* unit_;
    ::fast::Element_Literal* literal_;
  } extra_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_fast_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Element_Unit

// string filename = 1;
inline void Element_Unit::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Element_Unit::filename() const {
  // @@protoc_insertion_point(field_get:fast.Element.Unit.filename)
  return filename_.GetNoArena();
}
inline void Element_Unit::set_filename(const ::std::string& value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Element.Unit.filename)
}
#if LANG_CXX11
inline void Element_Unit::set_filename(::std::string&& value) {
  
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Element.Unit.filename)
}
#endif
inline void Element_Unit::set_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Element.Unit.filename)
}
inline void Element_Unit::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Element.Unit.filename)
}
inline ::std::string* Element_Unit::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:fast.Element.Unit.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Element_Unit::release_filename() {
  // @@protoc_insertion_point(field_release:fast.Element.Unit.filename)
  
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Element_Unit::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:fast.Element.Unit.filename)
}

// string revision = 2;
inline void Element_Unit::clear_revision() {
  revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Element_Unit::revision() const {
  // @@protoc_insertion_point(field_get:fast.Element.Unit.revision)
  return revision_.GetNoArena();
}
inline void Element_Unit::set_revision(const ::std::string& value) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Element.Unit.revision)
}
#if LANG_CXX11
inline void Element_Unit::set_revision(::std::string&& value) {
  
  revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Element.Unit.revision)
}
#endif
inline void Element_Unit::set_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Element.Unit.revision)
}
inline void Element_Unit::set_revision(const char* value, size_t size) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Element.Unit.revision)
}
inline ::std::string* Element_Unit::mutable_revision() {
  
  // @@protoc_insertion_point(field_mutable:fast.Element.Unit.revision)
  return revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Element_Unit::release_revision() {
  // @@protoc_insertion_point(field_release:fast.Element.Unit.revision)
  
  return revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Element_Unit::set_allocated_revision(::std::string* revision) {
  if (revision != NULL) {
    
  } else {
    
  }
  revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), revision);
  // @@protoc_insertion_point(field_set_allocated:fast.Element.Unit.revision)
}

// .fast.Element.Unit.LanguageType language = 3;
inline void Element_Unit::clear_language() {
  language_ = 0;
}
inline ::fast::Element_Unit_LanguageType Element_Unit::language() const {
  // @@protoc_insertion_point(field_get:fast.Element.Unit.language)
  return static_cast< ::fast::Element_Unit_LanguageType >(language_);
}
inline void Element_Unit::set_language(::fast::Element_Unit_LanguageType value) {
  
  language_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.Unit.language)
}

// int32 item = 4;
inline void Element_Unit::clear_item() {
  item_ = 0;
}
inline ::google::protobuf::int32 Element_Unit::item() const {
  // @@protoc_insertion_point(field_get:fast.Element.Unit.item)
  return item_;
}
inline void Element_Unit::set_item(::google::protobuf::int32 value) {
  
  item_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.Unit.item)
}

// -------------------------------------------------------------------

// Element_Literal

// .fast.Element.Literal.LiteralType type = 1;
inline void Element_Literal::clear_type() {
  type_ = 0;
}
inline ::fast::Element_Literal_LiteralType Element_Literal::type() const {
  // @@protoc_insertion_point(field_get:fast.Element.Literal.type)
  return static_cast< ::fast::Element_Literal_LiteralType >(type_);
}
inline void Element_Literal::set_type(::fast::Element_Literal_LiteralType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.Literal.type)
}

// -------------------------------------------------------------------

// Element

// .fast.Element.Kind kind = 1;
inline void Element::clear_kind() {
  kind_ = 0;
}
inline ::fast::Element_Kind Element::kind() const {
  // @@protoc_insertion_point(field_get:fast.Element.kind)
  return static_cast< ::fast::Element_Kind >(kind_);
}
inline void Element::set_kind(::fast::Element_Kind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.kind)
}

// string text = 2;
inline void Element::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Element::text() const {
  // @@protoc_insertion_point(field_get:fast.Element.text)
  return text_.GetNoArena();
}
inline void Element::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Element.text)
}
#if LANG_CXX11
inline void Element::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Element.text)
}
#endif
inline void Element::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Element.text)
}
inline void Element::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Element.text)
}
inline ::std::string* Element::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:fast.Element.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Element::release_text() {
  // @@protoc_insertion_point(field_release:fast.Element.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Element::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:fast.Element.text)
}

// string tail = 3;
inline void Element::clear_tail() {
  tail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Element::tail() const {
  // @@protoc_insertion_point(field_get:fast.Element.tail)
  return tail_.GetNoArena();
}
inline void Element::set_tail(const ::std::string& value) {
  
  tail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Element.tail)
}
#if LANG_CXX11
inline void Element::set_tail(::std::string&& value) {
  
  tail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Element.tail)
}
#endif
inline void Element::set_tail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Element.tail)
}
inline void Element::set_tail(const char* value, size_t size) {
  
  tail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Element.tail)
}
inline ::std::string* Element::mutable_tail() {
  
  // @@protoc_insertion_point(field_mutable:fast.Element.tail)
  return tail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Element::release_tail() {
  // @@protoc_insertion_point(field_release:fast.Element.tail)
  
  return tail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Element::set_allocated_tail(::std::string* tail) {
  if (tail != NULL) {
    
  } else {
    
  }
  tail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tail);
  // @@protoc_insertion_point(field_set_allocated:fast.Element.tail)
}

// repeated .fast.Element child = 4;
inline int Element::child_size() const {
  return child_.size();
}
inline void Element::clear_child() {
  child_.Clear();
}
inline const ::fast::Element& Element::child(int index) const {
  // @@protoc_insertion_point(field_get:fast.Element.child)
  return child_.Get(index);
}
inline ::fast::Element* Element::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Element.child)
  return child_.Mutable(index);
}
inline ::fast::Element* Element::add_child() {
  // @@protoc_insertion_point(field_add:fast.Element.child)
  return child_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Element >*
Element::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:fast.Element.child)
  return &child_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Element >&
Element::child() const {
  // @@protoc_insertion_point(field_list:fast.Element.child)
  return child_;
}

// .fast.Element.Unit unit = 5;
inline bool Element::has_unit() const {
  return extra_case() == kUnit;
}
inline void Element::set_has_unit() {
  _oneof_case_[0] = kUnit;
}
inline void Element::clear_unit() {
  if (has_unit()) {
    delete extra_.unit_;
    clear_has_extra();
  }
}
inline  const ::fast::Element_Unit& Element::unit() const {
  // @@protoc_insertion_point(field_get:fast.Element.unit)
  return has_unit()
      ? *extra_.unit_
      : ::fast::Element_Unit::default_instance();
}
inline ::fast::Element_Unit* Element::mutable_unit() {
  if (!has_unit()) {
    clear_extra();
    set_has_unit();
    extra_.unit_ = new ::fast::Element_Unit;
  }
  // @@protoc_insertion_point(field_mutable:fast.Element.unit)
  return extra_.unit_;
}
inline ::fast::Element_Unit* Element::release_unit() {
  // @@protoc_insertion_point(field_release:fast.Element.unit)
  if (has_unit()) {
    clear_has_extra();
    ::fast::Element_Unit* temp = extra_.unit_;
    extra_.unit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Element::set_allocated_unit(::fast::Element_Unit* unit) {
  clear_extra();
  if (unit) {
    set_has_unit();
    extra_.unit_ = unit;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Element.unit)
}

// .fast.Element.Literal literal = 6;
inline bool Element::has_literal() const {
  return extra_case() == kLiteral;
}
inline void Element::set_has_literal() {
  _oneof_case_[0] = kLiteral;
}
inline void Element::clear_literal() {
  if (has_literal()) {
    delete extra_.literal_;
    clear_has_extra();
  }
}
inline  const ::fast::Element_Literal& Element::literal() const {
  // @@protoc_insertion_point(field_get:fast.Element.literal)
  return has_literal()
      ? *extra_.literal_
      : ::fast::Element_Literal::default_instance();
}
inline ::fast::Element_Literal* Element::mutable_literal() {
  if (!has_literal()) {
    clear_extra();
    set_has_literal();
    extra_.literal_ = new ::fast::Element_Literal;
  }
  // @@protoc_insertion_point(field_mutable:fast.Element.literal)
  return extra_.literal_;
}
inline ::fast::Element_Literal* Element::release_literal() {
  // @@protoc_insertion_point(field_release:fast.Element.literal)
  if (has_literal()) {
    clear_has_extra();
    ::fast::Element_Literal* temp = extra_.literal_;
    extra_.literal_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Element::set_allocated_literal(::fast::Element_Literal* literal) {
  clear_extra();
  if (literal) {
    set_has_literal();
    extra_.literal_ = literal;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Element.literal)
}

// int32 line = 7;
inline void Element::clear_line() {
  line_ = 0;
}
inline ::google::protobuf::int32 Element::line() const {
  // @@protoc_insertion_point(field_get:fast.Element.line)
  return line_;
}
inline void Element::set_line(::google::protobuf::int32 value) {
  
  line_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.line)
}

// int32 column = 8;
inline void Element::clear_column() {
  column_ = 0;
}
inline ::google::protobuf::int32 Element::column() const {
  // @@protoc_insertion_point(field_get:fast.Element.column)
  return column_;
}
inline void Element::set_column(::google::protobuf::int32 value) {
  
  column_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.column)
}

inline bool Element::has_extra() const {
  return extra_case() != EXTRA_NOT_SET;
}
inline void Element::clear_has_extra() {
  _oneof_case_[0] = EXTRA_NOT_SET;
}
inline Element::ExtraCase Element::extra_case() const {
  return Element::ExtraCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace fast

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::fast::Element_Unit_LanguageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fast::Element_Unit_LanguageType>() {
  return ::fast::Element_Unit_LanguageType_descriptor();
}
template <> struct is_proto_enum< ::fast::Element_Literal_LiteralType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fast::Element_Literal_LiteralType>() {
  return ::fast::Element_Literal_LiteralType_descriptor();
}
template <> struct is_proto_enum< ::fast::Element_Kind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fast::Element_Kind>() {
  return ::fast::Element_Kind_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_fast_2eproto__INCLUDED
