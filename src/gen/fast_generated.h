// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FAST__FAST__DATA_H_
#define FLATBUFFERS_GENERATED_FAST__FAST__DATA_H_

#include "flatbuffers/flatbuffers.h"

namespace _fast {

struct Element;

namespace _Element {

struct Anonymous0;

struct Anonymous1;

struct Unit;

struct Literal;

}  // namespace _Element

struct Delta;

namespace _Delta {

struct Diff;

namespace _Diff {

struct Anonymous2;

struct Match;

struct Add;

struct Del;

struct Move;

struct Update;

}  // namespace _Diff
}  // namespace _Delta

struct Pairs;

namespace _Pairs {

struct Pair;

namespace _Pair {

struct Diff;

}  // namespace _Pair
}  // namespace _Pairs

struct Log;

namespace _Log {

struct Commit;

namespace _Commit {

struct Anonymous3;

struct Committer;

struct Diff;

namespace _Diff {

struct Hunk;

namespace _Hunk {

struct ModLine;

}  // namespace _Hunk
}  // namespace _Diff
}  // namespace _Commit

struct Author;

}  // namespace _Log

struct Slices;

namespace _Slices {

struct Slice;

namespace _Slice {

struct SourceFile;

namespace _SourceFile {

struct Function;

namespace _Function {

struct Variable;

namespace _Variable {

struct Position;

struct FunctionDecl;

}  // namespace _Variable
}  // namespace _Function
}  // namespace _SourceFile
}  // namespace _Slice
}  // namespace _Slices

struct Data;

namespace _Data {

struct Anonymous4;

}  // namespace _Data

enum SmaliKind {
  SmaliKind_smali_file = 0,
  SmaliKind_class_spec = 1,
  SmaliKind_super_spec = 2,
  SmaliKind_implements_spec = 3,
  SmaliKind_source_spec = 4,
  SmaliKind_access_list = 5,
  SmaliKind_field = 6,
  SmaliKind_method = 7,
  SmaliKind_statements_and_directives = 8,
  SmaliKind_ordered_method_item = 9,
  SmaliKind_registers_directive = 10,
  SmaliKind_param_list_or_id = 11,
  SmaliKind_simple_name = 12,
  SmaliKind_member_name = 13,
  SmaliKind_method_prototype = 14,
  SmaliKind_param_list_or_id_primitive_type = 15,
  SmaliKind_param_list = 16,
  SmaliKind_array_descriptor = 17,
  SmaliKind_type_descriptor = 18,
  SmaliKind_nonvoid_type_descriptor = 19,
  SmaliKind_reference_type_descriptor = 20,
  SmaliKind_integer_literal = 21,
  SmaliKind_float_literal = 22,
  SmaliKind_double_literal = 23,
  SmaliKind_literal = 24,
  SmaliKind_parsed_integer_literal = 25,
  SmaliKind_integral_literal = 26,
  SmaliKind_fixed_32bit_literal = 27,
  SmaliKind_fixed_literal = 28,
  SmaliKind_array_literal = 29,
  SmaliKind_annotation_element = 30,
  SmaliKind_annotation = 31,
  SmaliKind_subannotation = 32,
  SmaliKind_enum_literal = 33,
  SmaliKind_type_field_method_literal = 34,
  SmaliKind_method_reference = 35,
  SmaliKind_field_reference = 36,
  SmaliKind_label = 37,
  SmaliKind_label_ref = 38,
  SmaliKind_register_list = 39,
  SmaliKind_register_range = 40,
  SmaliKind_verification_error_reference = 41,
  SmaliKind_catch_directive = 42,
  SmaliKind_catchall_directive = 43,
  SmaliKind_parameter_directive = 44,
  SmaliKind_debug_directive = 45,
  SmaliKind_line_directive = 46,
  SmaliKind_local_directive = 47,
  SmaliKind_end_local_directive = 48,
  SmaliKind_restart_local_directive = 49,
  SmaliKind_prologue_directive = 50,
  SmaliKind_epilogue_directive = 51,
  SmaliKind_source_directive = 52,
  SmaliKind_instruction_format12x = 53,
  SmaliKind_instruction_format22s = 54,
  SmaliKind_instruction_format31i = 55,
  SmaliKind_instruction = 56,
  SmaliKind_insn_format10t = 57,
  SmaliKind_insn_format10x = 58,
  SmaliKind_insn_format10x_odex = 59,
  SmaliKind_insn_format11n = 60,
  SmaliKind_insn_format11x = 61,
  SmaliKind_insn_format12x = 62,
  SmaliKind_insn_format20bc = 63,
  SmaliKind_insn_format20t = 64,
  SmaliKind_insn_format21c_field = 65,
  SmaliKind_insn_format21c_field_odex = 66,
  SmaliKind_insn_format21c_string = 67,
  SmaliKind_insn_format21c_type = 68,
  SmaliKind_insn_format21ih = 69,
  SmaliKind_insn_format21lh = 70,
  SmaliKind_insn_format21s = 71,
  SmaliKind_insn_format21t = 72,
  SmaliKind_insn_format22b = 73,
  SmaliKind_insn_format22c_field = 74,
  SmaliKind_insn_format22c_field_odex = 75,
  SmaliKind_insn_format22c_type = 76,
  SmaliKind_insn_format22cs_field = 77,
  SmaliKind_insn_format22s = 78,
  SmaliKind_insn_format22t = 79,
  SmaliKind_insn_format22x = 80,
  SmaliKind_insn_format23x = 81,
  SmaliKind_insn_format30t = 82,
  SmaliKind_insn_format31c = 83,
  SmaliKind_insn_format31i = 84,
  SmaliKind_insn_format31t = 85,
  SmaliKind_insn_format32x = 86,
  SmaliKind_insn_format35c_method = 87,
  SmaliKind_insn_format35c_type = 88,
  SmaliKind_insn_format35c_method_odex = 89,
  SmaliKind_insn_format35mi_method = 90,
  SmaliKind_insn_format35ms_method = 91,
  SmaliKind_insn_format3rc_method = 92,
  SmaliKind_insn_format3rc_method_odex = 93,
  SmaliKind_insn_format3rc_type = 94,
  SmaliKind_insn_format3rmi_method = 95,
  SmaliKind_insn_format3rms_method = 96,
  SmaliKind_insn_format45cc_method = 97,
  SmaliKind_insn_format4rcc_method = 98,
  SmaliKind_insn_format51l = 99,
  SmaliKind_insn_array_data_directive = 100,
  SmaliKind_insn_packed_switch_directive = 101,
  SmaliKind_insn_sparse_switch_directive = 102,
  SmaliKind_MIN = SmaliKind_smali_file,
  SmaliKind_MAX = SmaliKind_insn_sparse_switch_directive
};

inline SmaliKind (&EnumValuesSmaliKind())[103] {
  static SmaliKind values[] = {
    SmaliKind_smali_file,
    SmaliKind_class_spec,
    SmaliKind_super_spec,
    SmaliKind_implements_spec,
    SmaliKind_source_spec,
    SmaliKind_access_list,
    SmaliKind_field,
    SmaliKind_method,
    SmaliKind_statements_and_directives,
    SmaliKind_ordered_method_item,
    SmaliKind_registers_directive,
    SmaliKind_param_list_or_id,
    SmaliKind_simple_name,
    SmaliKind_member_name,
    SmaliKind_method_prototype,
    SmaliKind_param_list_or_id_primitive_type,
    SmaliKind_param_list,
    SmaliKind_array_descriptor,
    SmaliKind_type_descriptor,
    SmaliKind_nonvoid_type_descriptor,
    SmaliKind_reference_type_descriptor,
    SmaliKind_integer_literal,
    SmaliKind_float_literal,
    SmaliKind_double_literal,
    SmaliKind_literal,
    SmaliKind_parsed_integer_literal,
    SmaliKind_integral_literal,
    SmaliKind_fixed_32bit_literal,
    SmaliKind_fixed_literal,
    SmaliKind_array_literal,
    SmaliKind_annotation_element,
    SmaliKind_annotation,
    SmaliKind_subannotation,
    SmaliKind_enum_literal,
    SmaliKind_type_field_method_literal,
    SmaliKind_method_reference,
    SmaliKind_field_reference,
    SmaliKind_label,
    SmaliKind_label_ref,
    SmaliKind_register_list,
    SmaliKind_register_range,
    SmaliKind_verification_error_reference,
    SmaliKind_catch_directive,
    SmaliKind_catchall_directive,
    SmaliKind_parameter_directive,
    SmaliKind_debug_directive,
    SmaliKind_line_directive,
    SmaliKind_local_directive,
    SmaliKind_end_local_directive,
    SmaliKind_restart_local_directive,
    SmaliKind_prologue_directive,
    SmaliKind_epilogue_directive,
    SmaliKind_source_directive,
    SmaliKind_instruction_format12x,
    SmaliKind_instruction_format22s,
    SmaliKind_instruction_format31i,
    SmaliKind_instruction,
    SmaliKind_insn_format10t,
    SmaliKind_insn_format10x,
    SmaliKind_insn_format10x_odex,
    SmaliKind_insn_format11n,
    SmaliKind_insn_format11x,
    SmaliKind_insn_format12x,
    SmaliKind_insn_format20bc,
    SmaliKind_insn_format20t,
    SmaliKind_insn_format21c_field,
    SmaliKind_insn_format21c_field_odex,
    SmaliKind_insn_format21c_string,
    SmaliKind_insn_format21c_type,
    SmaliKind_insn_format21ih,
    SmaliKind_insn_format21lh,
    SmaliKind_insn_format21s,
    SmaliKind_insn_format21t,
    SmaliKind_insn_format22b,
    SmaliKind_insn_format22c_field,
    SmaliKind_insn_format22c_field_odex,
    SmaliKind_insn_format22c_type,
    SmaliKind_insn_format22cs_field,
    SmaliKind_insn_format22s,
    SmaliKind_insn_format22t,
    SmaliKind_insn_format22x,
    SmaliKind_insn_format23x,
    SmaliKind_insn_format30t,
    SmaliKind_insn_format31c,
    SmaliKind_insn_format31i,
    SmaliKind_insn_format31t,
    SmaliKind_insn_format32x,
    SmaliKind_insn_format35c_method,
    SmaliKind_insn_format35c_type,
    SmaliKind_insn_format35c_method_odex,
    SmaliKind_insn_format35mi_method,
    SmaliKind_insn_format35ms_method,
    SmaliKind_insn_format3rc_method,
    SmaliKind_insn_format3rc_method_odex,
    SmaliKind_insn_format3rc_type,
    SmaliKind_insn_format3rmi_method,
    SmaliKind_insn_format3rms_method,
    SmaliKind_insn_format45cc_method,
    SmaliKind_insn_format4rcc_method,
    SmaliKind_insn_format51l,
    SmaliKind_insn_array_data_directive,
    SmaliKind_insn_packed_switch_directive,
    SmaliKind_insn_sparse_switch_directive
  };
  return values;
}

inline const char **EnumNamesSmaliKind() {
  static const char *names[] = {
    "smali_file",
    "class_spec",
    "super_spec",
    "implements_spec",
    "source_spec",
    "access_list",
    "field",
    "method",
    "statements_and_directives",
    "ordered_method_item",
    "registers_directive",
    "param_list_or_id",
    "simple_name",
    "member_name",
    "method_prototype",
    "param_list_or_id_primitive_type",
    "param_list",
    "array_descriptor",
    "type_descriptor",
    "nonvoid_type_descriptor",
    "reference_type_descriptor",
    "integer_literal",
    "float_literal",
    "double_literal",
    "literal",
    "parsed_integer_literal",
    "integral_literal",
    "fixed_32bit_literal",
    "fixed_literal",
    "array_literal",
    "annotation_element",
    "annotation",
    "subannotation",
    "enum_literal",
    "type_field_method_literal",
    "method_reference",
    "field_reference",
    "label",
    "label_ref",
    "register_list",
    "register_range",
    "verification_error_reference",
    "catch_directive",
    "catchall_directive",
    "parameter_directive",
    "debug_directive",
    "line_directive",
    "local_directive",
    "end_local_directive",
    "restart_local_directive",
    "prologue_directive",
    "epilogue_directive",
    "source_directive",
    "instruction_format12x",
    "instruction_format22s",
    "instruction_format31i",
    "instruction",
    "insn_format10t",
    "insn_format10x",
    "insn_format10x_odex",
    "insn_format11n",
    "insn_format11x",
    "insn_format12x",
    "insn_format20bc",
    "insn_format20t",
    "insn_format21c_field",
    "insn_format21c_field_odex",
    "insn_format21c_string",
    "insn_format21c_type",
    "insn_format21ih",
    "insn_format21lh",
    "insn_format21s",
    "insn_format21t",
    "insn_format22b",
    "insn_format22c_field",
    "insn_format22c_field_odex",
    "insn_format22c_type",
    "insn_format22cs_field",
    "insn_format22s",
    "insn_format22t",
    "insn_format22x",
    "insn_format23x",
    "insn_format30t",
    "insn_format31c",
    "insn_format31i",
    "insn_format31t",
    "insn_format32x",
    "insn_format35c_method",
    "insn_format35c_type",
    "insn_format35c_method_odex",
    "insn_format35mi_method",
    "insn_format35ms_method",
    "insn_format3rc_method",
    "insn_format3rc_method_odex",
    "insn_format3rc_type",
    "insn_format3rmi_method",
    "insn_format3rms_method",
    "insn_format45cc_method",
    "insn_format4rcc_method",
    "insn_format51l",
    "insn_array_data_directive",
    "insn_packed_switch_directive",
    "insn_sparse_switch_directive",
    nullptr
  };
  return names;
}

inline const char *EnumNameSmaliKind(SmaliKind e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSmaliKind()[index];
}

namespace _Element {

enum Kind {
  Kind_UNIT_KIND = 0,
  Kind_DECL = 1,
  Kind_DECL_STMT = 2,
  Kind_INIT = 3,
  Kind_EXPR = 4,
  Kind_EXPR_STMT = 5,
  Kind_COMMENT = 6,
  Kind_CALL = 7,
  Kind_CONTROL = 8,
  Kind_INCR = 9,
  Kind_NONE = 10,
  Kind_VARIABLE = 11,
  Kind_FUNCTION = 12,
  Kind_FUNCTION_DECL = 13,
  Kind_CONSTRUCTOR = 14,
  Kind_CONSTRUCTOR_DECL = 15,
  Kind_DESTRUCTOR = 16,
  Kind_DESTRUCTOR_DECL = 17,
  Kind_MACRO = 18,
  Kind_SINGLE_MACRO = 19,
  Kind_NULLOPERATOR = 20,
  Kind_ENUM_DEFN = 21,
  Kind_ENUM_DECL = 22,
  Kind_GLOBAL_ATTRIBUTE = 23,
  Kind_PROPERTY_ACCESSOR = 24,
  Kind_PROPERTY_ACCESSOR_DECL = 25,
  Kind_EXPRESSION = 26,
  Kind_CLASS_DEFN = 27,
  Kind_CLASS_DECL = 28,
  Kind_UNION_DEFN = 29,
  Kind_UNION_DECL = 30,
  Kind_STRUCT_DEFN = 31,
  Kind_STRUCT_DECL = 32,
  Kind_INTERFACE_DEFN = 33,
  Kind_INTERFACE_DECL = 34,
  Kind_ACCESS_REGION = 35,
  Kind_USING = 36,
  Kind_OPERATOR_FUNCTION = 37,
  Kind_OPERATOR_FUNCTION_DECL = 38,
  Kind_EVENT = 39,
  Kind_PROPERTY = 40,
  Kind_ANNOTATION_DEFN = 41,
  Kind_GLOBAL_TEMPLATE = 42,
  Kind_UNIT = 43,
  Kind_TART_ELEMENT_TOKEN = 44,
  Kind_NOP = 45,
  Kind_STRING = 46,
  Kind_CHAR = 47,
  Kind_LITERAL = 48,
  Kind_BOOLEAN = 49,
  Kind_NULL = 50,
  Kind_COMPLEX = 51,
  Kind_OPERATOR = 52,
  Kind_MODIFIER = 53,
  Kind_NAME = 54,
  Kind_ONAME = 55,
  Kind_CNAME = 56,
  Kind_TYPE = 57,
  Kind_TYPEPREV = 58,
  Kind_CONDITION = 59,
  Kind_BLOCK = 60,
  Kind_PSEUDO_BLOCK = 61,
  Kind_INDEX = 62,
  Kind_ENUM = 63,
  Kind_ENUM_DECLARATION = 64,
  Kind_IF_STATEMENT = 65,
  Kind_TERNARY = 66,
  Kind_THEN = 67,
  Kind_ELSE = 68,
  Kind_ELSEIF = 69,
  Kind_WHILE_STATEMENT = 70,
  Kind_DO_STATEMENT = 71,
  Kind_FOR_STATEMENT = 72,
  Kind_FOREACH_STATEMENT = 73,
  Kind_FOR_CONTROL = 74,
  Kind_FOR_INITIALIZATION = 75,
  Kind_FOR_CONDITION = 76,
  Kind_FOR_INCREMENT = 77,
  Kind_FOR_LIKE_CONTROL = 78,
  Kind_EXPRESSION_STATEMENT = 79,
  Kind_FUNCTION_CALL = 81,
  Kind_DECLARATION_STATEMENT = 82,
  Kind_DECLARATION = 83,
  Kind_DECLARATION_INITIALIZATION = 84,
  Kind_DECLARATION_RANGE = 85,
  Kind_RANGE = 86,
  Kind_GOTO_STATEMENT = 87,
  Kind_CONTINUE_STATEMENT = 88,
  Kind_BREAK_STATEMENT = 89,
  Kind_LABEL_STATEMENT = 90,
  Kind_LABEL = 91,
  Kind_SWITCH = 92,
  Kind_CASE = 93,
  Kind_DEFAULT = 94,
  Kind_FUNCTION_DEFINITION = 95,
  Kind_FUNCTION_DECLARATION = 96,
  Kind_LAMBDA = 97,
  Kind_FUNCTION_LAMBDA = 98,
  Kind_FUNCTION_SPECIFIER = 99,
  Kind_RETURN_STATEMENT = 100,
  Kind_PARAMETER_LIST = 101,
  Kind_PARAMETER = 102,
  Kind_KRPARAMETER_LIST = 103,
  Kind_KRPARAMETER = 104,
  Kind_ARGUMENT_LIST = 105,
  Kind_ARGUMENT = 106,
  Kind_PSEUDO_PARAMETER_LIST = 107,
  Kind_INDEXER_PARAMETER_LIST = 108,
  Kind_CLASS = 109,
  Kind_CLASS_DECLARATION = 110,
  Kind_STRUCT = 111,
  Kind_STRUCT_DECLARATION = 112,
  Kind_UNION = 113,
  Kind_UNION_DECLARATION = 114,
  Kind_DERIVATION_LIST = 115,
  Kind_PUBLIC_ACCESS = 116,
  Kind_PUBLIC_ACCESS_DEFAULT = 117,
  Kind_PRIVATE_ACCESS = 118,
  Kind_PRIVATE_ACCESS_DEFAULT = 119,
  Kind_PROTECTED_ACCESS = 120,
  Kind_PROTECTED_ACCESS_DEFAULT = 121,
  Kind_MEMBER_INIT_LIST = 122,
  Kind_MEMBER_INITIALIZATION_LIST = 123,
  Kind_MEMBER_INITIALIZATION = 124,
  Kind_CONSTRUCTOR_DEFINITION = 125,
  Kind_CONSTRUCTOR_DECLARATION = 126,
  Kind_DESTRUCTOR_DEFINITION = 127,
  Kind_DESTRUCTOR_DECLARATION = 128,
  Kind_FRIEND = 129,
  Kind_CLASS_SPECIFIER = 130,
  Kind_TRY_BLOCK = 131,
  Kind_CATCH_BLOCK = 132,
  Kind_FINALLY_BLOCK = 133,
  Kind_THROW_STATEMENT = 134,
  Kind_THROW_SPECIFIER = 135,
  Kind_THROW_SPECIFIER_JAVA = 136,
  Kind_TEMPLATE = 137,
  Kind_GENERIC_ARGUMENT = 138,
  Kind_GENERIC_ARGUMENT_LIST = 139,
  Kind_TEMPLATE_PARAMETER = 140,
  Kind_TEMPLATE_PARAMETER_LIST = 141,
  Kind_GENERIC_PARAMETER = 142,
  Kind_GENERIC_PARAMETER_LIST = 143,
  Kind_TYPEDEF = 144,
  Kind_ASM = 145,
  Kind_MACRO_CALL = 146,
  Kind_SIZEOF_CALL = 147,
  Kind_EXTERN = 148,
  Kind_NAMESPACE = 149,
  Kind_USING_DIRECTIVE = 150,
  Kind_DIRECTIVE = 151,
  Kind_ATOMIC = 152,
  Kind_STATIC_ASSERT_STATEMENT = 153,
  Kind_GENERIC_SELECTION = 154,
  Kind_GENERIC_SELECTOR = 155,
  Kind_GENERIC_ASSOCIATION_LIST = 156,
  Kind_GENERIC_ASSOCIATION = 157,
  Kind_ALIGNAS = 158,
  Kind_DECLTYPE = 159,
  Kind_CAPTURE = 160,
  Kind_LAMBDA_CAPTURE = 161,
  Kind_NOEXCEPT = 162,
  Kind_TYPENAME = 163,
  Kind_ALIGNOF = 164,
  Kind_TYPEID = 165,
  Kind_SIZEOF_PACK = 166,
  Kind_ENUM_CLASS = 167,
  Kind_ENUM_CLASS_DECLARATION = 168,
  Kind_REF_QUALIFIER = 171,
  Kind_SIGNAL_ACCESS = 172,
  Kind_FOREVER_STATEMENT = 173,
  Kind_EMIT_STATEMENT = 174,
  Kind_CPP_DIRECTIVE = 175,
  Kind_CPP_FILENAME = 176,
  Kind_FILE = 177,
  Kind_NUMBER = 178,
  Kind_CPP_NUMBER = 179,
  Kind_CPP_LITERAL = 180,
  Kind_CPP_MACRO_DEFN = 181,
  Kind_CPP_MACRO_VALUE = 182,
  Kind_ERROR = 183,
  Kind_CPP_ERROR = 184,
  Kind_CPP_WARNING = 185,
  Kind_CPP_PRAGMA = 186,
  Kind_CPP_INCLUDE = 187,
  Kind_CPP_DEFINE = 188,
  Kind_CPP_UNDEF = 189,
  Kind_CPP_LINE = 190,
  Kind_CPP_IF = 191,
  Kind_CPP_IFDEF = 192,
  Kind_CPP_IFNDEF = 193,
  Kind_CPP_THEN = 194,
  Kind_CPP_ELSE = 195,
  Kind_CPP_ELIF = 196,
  Kind_CPP_EMPTY = 197,
  Kind_CPP_REGION = 198,
  Kind_CPP_ENDREGION = 199,
  Kind_USING_STMT = 200,
  Kind_ESCAPE = 201,
  Kind_VALUE = 202,
  Kind_CPP_IMPORT = 203,
  Kind_CPP_ENDIF = 204,
  Kind_MARKER = 205,
  Kind_ERROR_PARSE = 206,
  Kind_ERROR_MODE = 207,
  Kind_IMPLEMENTS = 208,
  Kind_EXTENDS = 209,
  Kind_IMPORT = 210,
  Kind_PACKAGE = 211,
  Kind_ASSERT_STATEMENT = 212,
  Kind_INTERFACE = 213,
  Kind_INTERFACE_DECLARATION = 214,
  Kind_SYNCHRONIZED_STATEMENT = 215,
  Kind_ANNOTATION = 216,
  Kind_STATIC_BLOCK = 218,
  Kind_CHECKED_STATEMENT = 219,
  Kind_UNCHECKED_STATEMENT = 220,
  Kind_ATTRIBUTE = 221,
  Kind_TARGET = 222,
  Kind_UNSAFE_STATEMENT = 223,
  Kind_LOCK_STATEMENT = 224,
  Kind_FIXED_STATEMENT = 225,
  Kind_TYPEOF = 226,
  Kind_USING_STATEMENT = 227,
  Kind_FUNCTION_DELEGATE = 228,
  Kind_CONSTRAINT = 230,
  Kind_LINQ = 231,
  Kind_FROM = 232,
  Kind_WHERE = 233,
  Kind_SELECT = 234,
  Kind_LET = 235,
  Kind_ORDERBY = 236,
  Kind_JOIN = 237,
  Kind_GROUP = 238,
  Kind_IN = 239,
  Kind_ON = 240,
  Kind_EQUALS = 241,
  Kind_BY = 242,
  Kind_INTO = 243,
  Kind_EMPTY = 244,
  Kind_EMPTY_STMT = 245,
  Kind_RECEIVER = 246,
  Kind_MESSAGE = 247,
  Kind_SELECTOR = 248,
  Kind_PROTOCOL_LIST = 249,
  Kind_CATEGORY = 250,
  Kind_PROTOCOL = 251,
  Kind_REQUIRED_DEFAULT = 252,
  Kind_REQUIRED = 253,
  Kind_OPTIONAL = 254,
  Kind_ATTRIBUTE_LIST = 256,
  Kind_SYNTHESIZE = 257,
  Kind_DYNAMIC = 258,
  Kind_ENCODE = 259,
  Kind_AUTORELEASEPOOL = 260,
  Kind_COMPATIBILITY_ALIAS = 261,
  Kind_NIL = 262,
  Kind_CLASS_INTERFACE = 263,
  Kind_CLASS_IMPLEMENTATION = 264,
  Kind_PROTOCOL_DECLARATION = 265,
  Kind_CAST = 266,
  Kind_CONST_CAST = 267,
  Kind_DYNAMIC_CAST = 268,
  Kind_REINTERPRET_CAST = 269,
  Kind_STATIC_CAST = 270,
  Kind_POSITION = 271,
  Kind_CUDA_ARGUMENT_LIST = 272,
  Kind_OMP_DIRECTIVE = 273,
  Kind_OMP_NAME = 274,
  Kind_OMP_CLAUSE = 275,
  Kind_OMP_ARGUMENT_LIST = 276,
  Kind_OMP_ARGUMENT = 277,
  Kind_OMP_EXPRESSION = 278,
  Kind_END_ELEMENT_TOKEN = 279,
  Kind_MAIN = 280,
  Kind_BREAK = 281,
  Kind_CONTINUE = 282,
  Kind_WHILE = 283,
  Kind_DO = 284,
  Kind_FOR = 285,
  Kind_IF = 286,
  Kind_GOTO = 293,
  Kind_VISUAL_CXX_ASM = 295,
  Kind_SIZEOF = 296,
  Kind_AUTO = 298,
  Kind_REGISTER = 299,
  Kind_RESTRICT = 300,
  Kind_IMAGINARY = 304,
  Kind_NORETURN = 305,
  Kind_STATIC_ASSERT = 306,
  Kind_CRESTRICT = 307,
  Kind_CXX_TRY = 308,
  Kind_CXX_CATCH = 309,
  Kind_CXX_CLASS = 310,
  Kind_CONSTEXPR = 311,
  Kind_THREAD_LOCAL = 313,
  Kind_NULLPTR = 314,
  Kind_VOID = 326,
  Kind_RETURN = 327,
  Kind_INCLUDE = 328,
  Kind_DEFINE = 329,
  Kind_ELIF = 330,
  Kind_ENDIF = 331,
  Kind_ERRORPREC = 332,
  Kind_WARNING = 333,
  Kind_IFDEF = 334,
  Kind_IFNDEF = 335,
  Kind_LINE = 336,
  Kind_PRAGMA = 337,
  Kind_UNDEF = 338,
  Kind_INLINE = 339,
  Kind_MACRO_TYPE_NAME = 340,
  Kind_MACRO_CASE = 341,
  Kind_MACRO_LABEL = 342,
  Kind_SPECIFIER = 344,
  Kind_TRY = 345,
  Kind_CATCH = 346,
  Kind_THROW = 347,
  Kind_THROWS = 348,
  Kind_PUBLIC = 350,
  Kind_PRIVATE = 351,
  Kind_PROTECTED = 352,
  Kind_VIRTUAL = 353,
  Kind_EXPLICIT = 356,
  Kind_FOREVER = 357,
  Kind_SIGNAL = 358,
  Kind_EMIT = 359,
  Kind_NEW = 363,
  Kind_DELETE = 364,
  Kind_STATIC = 365,
  Kind_CONST = 366,
  Kind_MUTABLE = 367,
  Kind_VOLATILE = 368,
  Kind_TRANSIENT = 369,
  Kind_FINALLY = 372,
  Kind_FINAL = 376,
  Kind_ABSTRACT = 377,
  Kind_SUPER = 378,
  Kind_SYNCHRONIZED = 379,
  Kind_NATIVE = 380,
  Kind_STRICTFP = 381,
  Kind_NULLLITERAL = 382,
  Kind_ASSERT = 383,
  Kind_FOREACH = 384,
  Kind_REF = 385,
  Kind_OUT = 386,
  Kind_LOCK = 388,
  Kind_IS = 389,
  Kind_INTERNAL = 390,
  Kind_SEALED = 391,
  Kind_OVERRIDE = 392,
  Kind_IMPLICIT = 393,
  Kind_STACKALLOC = 394,
  Kind_AS = 395,
  Kind_DELEGATE = 396,
  Kind_FIXED = 397,
  Kind_CHECKED = 398,
  Kind_UNCHECKED = 399,
  Kind_REGION = 400,
  Kind_ENDREGION = 401,
  Kind_UNSAFE = 402,
  Kind_READONLY = 403,
  Kind_GET = 404,
  Kind_SET = 405,
  Kind_ADD = 406,
  Kind_REMOVE = 407,
  Kind_YIELD = 408,
  Kind_PARTIAL = 409,
  Kind_AWAIT = 410,
  Kind_ASYNC = 412,
  Kind_THIS = 413,
  Kind_PARAMS = 414,
  Kind_ALIAS = 416,
  Kind_ASCENDING = 422,
  Kind_DESCENDING = 423,
  Kind_ATINTERFACE = 430,
  Kind_ATIMPLEMENTATION = 431,
  Kind_ATEND = 432,
  Kind_ATPROTOCOL = 433,
  Kind_ATREQUIRED = 434,
  Kind_ATOPTIONAL = 435,
  Kind_ATCLASS = 441,
  Kind_WEAK = 443,
  Kind_STRONG = 444,
  Kind_OMP_OMP = 448,
  Kind_SPECIAL_CHARS = 449,
  Kind_MIN = Kind_UNIT_KIND,
  Kind_MAX = Kind_SPECIAL_CHARS
};

inline Kind (&EnumValuesKind())[386] {
  static Kind values[] = {
    Kind_UNIT_KIND,
    Kind_DECL,
    Kind_DECL_STMT,
    Kind_INIT,
    Kind_EXPR,
    Kind_EXPR_STMT,
    Kind_COMMENT,
    Kind_CALL,
    Kind_CONTROL,
    Kind_INCR,
    Kind_NONE,
    Kind_VARIABLE,
    Kind_FUNCTION,
    Kind_FUNCTION_DECL,
    Kind_CONSTRUCTOR,
    Kind_CONSTRUCTOR_DECL,
    Kind_DESTRUCTOR,
    Kind_DESTRUCTOR_DECL,
    Kind_MACRO,
    Kind_SINGLE_MACRO,
    Kind_NULLOPERATOR,
    Kind_ENUM_DEFN,
    Kind_ENUM_DECL,
    Kind_GLOBAL_ATTRIBUTE,
    Kind_PROPERTY_ACCESSOR,
    Kind_PROPERTY_ACCESSOR_DECL,
    Kind_EXPRESSION,
    Kind_CLASS_DEFN,
    Kind_CLASS_DECL,
    Kind_UNION_DEFN,
    Kind_UNION_DECL,
    Kind_STRUCT_DEFN,
    Kind_STRUCT_DECL,
    Kind_INTERFACE_DEFN,
    Kind_INTERFACE_DECL,
    Kind_ACCESS_REGION,
    Kind_USING,
    Kind_OPERATOR_FUNCTION,
    Kind_OPERATOR_FUNCTION_DECL,
    Kind_EVENT,
    Kind_PROPERTY,
    Kind_ANNOTATION_DEFN,
    Kind_GLOBAL_TEMPLATE,
    Kind_UNIT,
    Kind_TART_ELEMENT_TOKEN,
    Kind_NOP,
    Kind_STRING,
    Kind_CHAR,
    Kind_LITERAL,
    Kind_BOOLEAN,
    Kind_NULL,
    Kind_COMPLEX,
    Kind_OPERATOR,
    Kind_MODIFIER,
    Kind_NAME,
    Kind_ONAME,
    Kind_CNAME,
    Kind_TYPE,
    Kind_TYPEPREV,
    Kind_CONDITION,
    Kind_BLOCK,
    Kind_PSEUDO_BLOCK,
    Kind_INDEX,
    Kind_ENUM,
    Kind_ENUM_DECLARATION,
    Kind_IF_STATEMENT,
    Kind_TERNARY,
    Kind_THEN,
    Kind_ELSE,
    Kind_ELSEIF,
    Kind_WHILE_STATEMENT,
    Kind_DO_STATEMENT,
    Kind_FOR_STATEMENT,
    Kind_FOREACH_STATEMENT,
    Kind_FOR_CONTROL,
    Kind_FOR_INITIALIZATION,
    Kind_FOR_CONDITION,
    Kind_FOR_INCREMENT,
    Kind_FOR_LIKE_CONTROL,
    Kind_EXPRESSION_STATEMENT,
    Kind_FUNCTION_CALL,
    Kind_DECLARATION_STATEMENT,
    Kind_DECLARATION,
    Kind_DECLARATION_INITIALIZATION,
    Kind_DECLARATION_RANGE,
    Kind_RANGE,
    Kind_GOTO_STATEMENT,
    Kind_CONTINUE_STATEMENT,
    Kind_BREAK_STATEMENT,
    Kind_LABEL_STATEMENT,
    Kind_LABEL,
    Kind_SWITCH,
    Kind_CASE,
    Kind_DEFAULT,
    Kind_FUNCTION_DEFINITION,
    Kind_FUNCTION_DECLARATION,
    Kind_LAMBDA,
    Kind_FUNCTION_LAMBDA,
    Kind_FUNCTION_SPECIFIER,
    Kind_RETURN_STATEMENT,
    Kind_PARAMETER_LIST,
    Kind_PARAMETER,
    Kind_KRPARAMETER_LIST,
    Kind_KRPARAMETER,
    Kind_ARGUMENT_LIST,
    Kind_ARGUMENT,
    Kind_PSEUDO_PARAMETER_LIST,
    Kind_INDEXER_PARAMETER_LIST,
    Kind_CLASS,
    Kind_CLASS_DECLARATION,
    Kind_STRUCT,
    Kind_STRUCT_DECLARATION,
    Kind_UNION,
    Kind_UNION_DECLARATION,
    Kind_DERIVATION_LIST,
    Kind_PUBLIC_ACCESS,
    Kind_PUBLIC_ACCESS_DEFAULT,
    Kind_PRIVATE_ACCESS,
    Kind_PRIVATE_ACCESS_DEFAULT,
    Kind_PROTECTED_ACCESS,
    Kind_PROTECTED_ACCESS_DEFAULT,
    Kind_MEMBER_INIT_LIST,
    Kind_MEMBER_INITIALIZATION_LIST,
    Kind_MEMBER_INITIALIZATION,
    Kind_CONSTRUCTOR_DEFINITION,
    Kind_CONSTRUCTOR_DECLARATION,
    Kind_DESTRUCTOR_DEFINITION,
    Kind_DESTRUCTOR_DECLARATION,
    Kind_FRIEND,
    Kind_CLASS_SPECIFIER,
    Kind_TRY_BLOCK,
    Kind_CATCH_BLOCK,
    Kind_FINALLY_BLOCK,
    Kind_THROW_STATEMENT,
    Kind_THROW_SPECIFIER,
    Kind_THROW_SPECIFIER_JAVA,
    Kind_TEMPLATE,
    Kind_GENERIC_ARGUMENT,
    Kind_GENERIC_ARGUMENT_LIST,
    Kind_TEMPLATE_PARAMETER,
    Kind_TEMPLATE_PARAMETER_LIST,
    Kind_GENERIC_PARAMETER,
    Kind_GENERIC_PARAMETER_LIST,
    Kind_TYPEDEF,
    Kind_ASM,
    Kind_MACRO_CALL,
    Kind_SIZEOF_CALL,
    Kind_EXTERN,
    Kind_NAMESPACE,
    Kind_USING_DIRECTIVE,
    Kind_DIRECTIVE,
    Kind_ATOMIC,
    Kind_STATIC_ASSERT_STATEMENT,
    Kind_GENERIC_SELECTION,
    Kind_GENERIC_SELECTOR,
    Kind_GENERIC_ASSOCIATION_LIST,
    Kind_GENERIC_ASSOCIATION,
    Kind_ALIGNAS,
    Kind_DECLTYPE,
    Kind_CAPTURE,
    Kind_LAMBDA_CAPTURE,
    Kind_NOEXCEPT,
    Kind_TYPENAME,
    Kind_ALIGNOF,
    Kind_TYPEID,
    Kind_SIZEOF_PACK,
    Kind_ENUM_CLASS,
    Kind_ENUM_CLASS_DECLARATION,
    Kind_REF_QUALIFIER,
    Kind_SIGNAL_ACCESS,
    Kind_FOREVER_STATEMENT,
    Kind_EMIT_STATEMENT,
    Kind_CPP_DIRECTIVE,
    Kind_CPP_FILENAME,
    Kind_FILE,
    Kind_NUMBER,
    Kind_CPP_NUMBER,
    Kind_CPP_LITERAL,
    Kind_CPP_MACRO_DEFN,
    Kind_CPP_MACRO_VALUE,
    Kind_ERROR,
    Kind_CPP_ERROR,
    Kind_CPP_WARNING,
    Kind_CPP_PRAGMA,
    Kind_CPP_INCLUDE,
    Kind_CPP_DEFINE,
    Kind_CPP_UNDEF,
    Kind_CPP_LINE,
    Kind_CPP_IF,
    Kind_CPP_IFDEF,
    Kind_CPP_IFNDEF,
    Kind_CPP_THEN,
    Kind_CPP_ELSE,
    Kind_CPP_ELIF,
    Kind_CPP_EMPTY,
    Kind_CPP_REGION,
    Kind_CPP_ENDREGION,
    Kind_USING_STMT,
    Kind_ESCAPE,
    Kind_VALUE,
    Kind_CPP_IMPORT,
    Kind_CPP_ENDIF,
    Kind_MARKER,
    Kind_ERROR_PARSE,
    Kind_ERROR_MODE,
    Kind_IMPLEMENTS,
    Kind_EXTENDS,
    Kind_IMPORT,
    Kind_PACKAGE,
    Kind_ASSERT_STATEMENT,
    Kind_INTERFACE,
    Kind_INTERFACE_DECLARATION,
    Kind_SYNCHRONIZED_STATEMENT,
    Kind_ANNOTATION,
    Kind_STATIC_BLOCK,
    Kind_CHECKED_STATEMENT,
    Kind_UNCHECKED_STATEMENT,
    Kind_ATTRIBUTE,
    Kind_TARGET,
    Kind_UNSAFE_STATEMENT,
    Kind_LOCK_STATEMENT,
    Kind_FIXED_STATEMENT,
    Kind_TYPEOF,
    Kind_USING_STATEMENT,
    Kind_FUNCTION_DELEGATE,
    Kind_CONSTRAINT,
    Kind_LINQ,
    Kind_FROM,
    Kind_WHERE,
    Kind_SELECT,
    Kind_LET,
    Kind_ORDERBY,
    Kind_JOIN,
    Kind_GROUP,
    Kind_IN,
    Kind_ON,
    Kind_EQUALS,
    Kind_BY,
    Kind_INTO,
    Kind_EMPTY,
    Kind_EMPTY_STMT,
    Kind_RECEIVER,
    Kind_MESSAGE,
    Kind_SELECTOR,
    Kind_PROTOCOL_LIST,
    Kind_CATEGORY,
    Kind_PROTOCOL,
    Kind_REQUIRED_DEFAULT,
    Kind_REQUIRED,
    Kind_OPTIONAL,
    Kind_ATTRIBUTE_LIST,
    Kind_SYNTHESIZE,
    Kind_DYNAMIC,
    Kind_ENCODE,
    Kind_AUTORELEASEPOOL,
    Kind_COMPATIBILITY_ALIAS,
    Kind_NIL,
    Kind_CLASS_INTERFACE,
    Kind_CLASS_IMPLEMENTATION,
    Kind_PROTOCOL_DECLARATION,
    Kind_CAST,
    Kind_CONST_CAST,
    Kind_DYNAMIC_CAST,
    Kind_REINTERPRET_CAST,
    Kind_STATIC_CAST,
    Kind_POSITION,
    Kind_CUDA_ARGUMENT_LIST,
    Kind_OMP_DIRECTIVE,
    Kind_OMP_NAME,
    Kind_OMP_CLAUSE,
    Kind_OMP_ARGUMENT_LIST,
    Kind_OMP_ARGUMENT,
    Kind_OMP_EXPRESSION,
    Kind_END_ELEMENT_TOKEN,
    Kind_MAIN,
    Kind_BREAK,
    Kind_CONTINUE,
    Kind_WHILE,
    Kind_DO,
    Kind_FOR,
    Kind_IF,
    Kind_GOTO,
    Kind_VISUAL_CXX_ASM,
    Kind_SIZEOF,
    Kind_AUTO,
    Kind_REGISTER,
    Kind_RESTRICT,
    Kind_IMAGINARY,
    Kind_NORETURN,
    Kind_STATIC_ASSERT,
    Kind_CRESTRICT,
    Kind_CXX_TRY,
    Kind_CXX_CATCH,
    Kind_CXX_CLASS,
    Kind_CONSTEXPR,
    Kind_THREAD_LOCAL,
    Kind_NULLPTR,
    Kind_VOID,
    Kind_RETURN,
    Kind_INCLUDE,
    Kind_DEFINE,
    Kind_ELIF,
    Kind_ENDIF,
    Kind_ERRORPREC,
    Kind_WARNING,
    Kind_IFDEF,
    Kind_IFNDEF,
    Kind_LINE,
    Kind_PRAGMA,
    Kind_UNDEF,
    Kind_INLINE,
    Kind_MACRO_TYPE_NAME,
    Kind_MACRO_CASE,
    Kind_MACRO_LABEL,
    Kind_SPECIFIER,
    Kind_TRY,
    Kind_CATCH,
    Kind_THROW,
    Kind_THROWS,
    Kind_PUBLIC,
    Kind_PRIVATE,
    Kind_PROTECTED,
    Kind_VIRTUAL,
    Kind_EXPLICIT,
    Kind_FOREVER,
    Kind_SIGNAL,
    Kind_EMIT,
    Kind_NEW,
    Kind_DELETE,
    Kind_STATIC,
    Kind_CONST,
    Kind_MUTABLE,
    Kind_VOLATILE,
    Kind_TRANSIENT,
    Kind_FINALLY,
    Kind_FINAL,
    Kind_ABSTRACT,
    Kind_SUPER,
    Kind_SYNCHRONIZED,
    Kind_NATIVE,
    Kind_STRICTFP,
    Kind_NULLLITERAL,
    Kind_ASSERT,
    Kind_FOREACH,
    Kind_REF,
    Kind_OUT,
    Kind_LOCK,
    Kind_IS,
    Kind_INTERNAL,
    Kind_SEALED,
    Kind_OVERRIDE,
    Kind_IMPLICIT,
    Kind_STACKALLOC,
    Kind_AS,
    Kind_DELEGATE,
    Kind_FIXED,
    Kind_CHECKED,
    Kind_UNCHECKED,
    Kind_REGION,
    Kind_ENDREGION,
    Kind_UNSAFE,
    Kind_READONLY,
    Kind_GET,
    Kind_SET,
    Kind_ADD,
    Kind_REMOVE,
    Kind_YIELD,
    Kind_PARTIAL,
    Kind_AWAIT,
    Kind_ASYNC,
    Kind_THIS,
    Kind_PARAMS,
    Kind_ALIAS,
    Kind_ASCENDING,
    Kind_DESCENDING,
    Kind_ATINTERFACE,
    Kind_ATIMPLEMENTATION,
    Kind_ATEND,
    Kind_ATPROTOCOL,
    Kind_ATREQUIRED,
    Kind_ATOPTIONAL,
    Kind_ATCLASS,
    Kind_WEAK,
    Kind_STRONG,
    Kind_OMP_OMP,
    Kind_SPECIAL_CHARS
  };
  return values;
}

inline const char **EnumNamesKind() {
  static const char *names[] = {
    "UNIT_KIND",
    "DECL",
    "DECL_STMT",
    "INIT",
    "EXPR",
    "EXPR_STMT",
    "COMMENT",
    "CALL",
    "CONTROL",
    "INCR",
    "NONE",
    "VARIABLE",
    "FUNCTION",
    "FUNCTION_DECL",
    "CONSTRUCTOR",
    "CONSTRUCTOR_DECL",
    "DESTRUCTOR",
    "DESTRUCTOR_DECL",
    "MACRO",
    "SINGLE_MACRO",
    "NULLOPERATOR",
    "ENUM_DEFN",
    "ENUM_DECL",
    "GLOBAL_ATTRIBUTE",
    "PROPERTY_ACCESSOR",
    "PROPERTY_ACCESSOR_DECL",
    "EXPRESSION",
    "CLASS_DEFN",
    "CLASS_DECL",
    "UNION_DEFN",
    "UNION_DECL",
    "STRUCT_DEFN",
    "STRUCT_DECL",
    "INTERFACE_DEFN",
    "INTERFACE_DECL",
    "ACCESS_REGION",
    "USING",
    "OPERATOR_FUNCTION",
    "OPERATOR_FUNCTION_DECL",
    "EVENT",
    "PROPERTY",
    "ANNOTATION_DEFN",
    "GLOBAL_TEMPLATE",
    "UNIT",
    "TART_ELEMENT_TOKEN",
    "NOP",
    "STRING",
    "CHAR",
    "LITERAL",
    "BOOLEAN",
    "NULL",
    "COMPLEX",
    "OPERATOR",
    "MODIFIER",
    "NAME",
    "ONAME",
    "CNAME",
    "TYPE",
    "TYPEPREV",
    "CONDITION",
    "BLOCK",
    "PSEUDO_BLOCK",
    "INDEX",
    "ENUM",
    "ENUM_DECLARATION",
    "IF_STATEMENT",
    "TERNARY",
    "THEN",
    "ELSE",
    "ELSEIF",
    "WHILE_STATEMENT",
    "DO_STATEMENT",
    "FOR_STATEMENT",
    "FOREACH_STATEMENT",
    "FOR_CONTROL",
    "FOR_INITIALIZATION",
    "FOR_CONDITION",
    "FOR_INCREMENT",
    "FOR_LIKE_CONTROL",
    "EXPRESSION_STATEMENT",
    "",
    "FUNCTION_CALL",
    "DECLARATION_STATEMENT",
    "DECLARATION",
    "DECLARATION_INITIALIZATION",
    "DECLARATION_RANGE",
    "RANGE",
    "GOTO_STATEMENT",
    "CONTINUE_STATEMENT",
    "BREAK_STATEMENT",
    "LABEL_STATEMENT",
    "LABEL",
    "SWITCH",
    "CASE",
    "DEFAULT",
    "FUNCTION_DEFINITION",
    "FUNCTION_DECLARATION",
    "LAMBDA",
    "FUNCTION_LAMBDA",
    "FUNCTION_SPECIFIER",
    "RETURN_STATEMENT",
    "PARAMETER_LIST",
    "PARAMETER",
    "KRPARAMETER_LIST",
    "KRPARAMETER",
    "ARGUMENT_LIST",
    "ARGUMENT",
    "PSEUDO_PARAMETER_LIST",
    "INDEXER_PARAMETER_LIST",
    "CLASS",
    "CLASS_DECLARATION",
    "STRUCT",
    "STRUCT_DECLARATION",
    "UNION",
    "UNION_DECLARATION",
    "DERIVATION_LIST",
    "PUBLIC_ACCESS",
    "PUBLIC_ACCESS_DEFAULT",
    "PRIVATE_ACCESS",
    "PRIVATE_ACCESS_DEFAULT",
    "PROTECTED_ACCESS",
    "PROTECTED_ACCESS_DEFAULT",
    "MEMBER_INIT_LIST",
    "MEMBER_INITIALIZATION_LIST",
    "MEMBER_INITIALIZATION",
    "CONSTRUCTOR_DEFINITION",
    "CONSTRUCTOR_DECLARATION",
    "DESTRUCTOR_DEFINITION",
    "DESTRUCTOR_DECLARATION",
    "FRIEND",
    "CLASS_SPECIFIER",
    "TRY_BLOCK",
    "CATCH_BLOCK",
    "FINALLY_BLOCK",
    "THROW_STATEMENT",
    "THROW_SPECIFIER",
    "THROW_SPECIFIER_JAVA",
    "TEMPLATE",
    "GENERIC_ARGUMENT",
    "GENERIC_ARGUMENT_LIST",
    "TEMPLATE_PARAMETER",
    "TEMPLATE_PARAMETER_LIST",
    "GENERIC_PARAMETER",
    "GENERIC_PARAMETER_LIST",
    "TYPEDEF",
    "ASM",
    "MACRO_CALL",
    "SIZEOF_CALL",
    "EXTERN",
    "NAMESPACE",
    "USING_DIRECTIVE",
    "DIRECTIVE",
    "ATOMIC",
    "STATIC_ASSERT_STATEMENT",
    "GENERIC_SELECTION",
    "GENERIC_SELECTOR",
    "GENERIC_ASSOCIATION_LIST",
    "GENERIC_ASSOCIATION",
    "ALIGNAS",
    "DECLTYPE",
    "CAPTURE",
    "LAMBDA_CAPTURE",
    "NOEXCEPT",
    "TYPENAME",
    "ALIGNOF",
    "TYPEID",
    "SIZEOF_PACK",
    "ENUM_CLASS",
    "ENUM_CLASS_DECLARATION",
    "",
    "",
    "REF_QUALIFIER",
    "SIGNAL_ACCESS",
    "FOREVER_STATEMENT",
    "EMIT_STATEMENT",
    "CPP_DIRECTIVE",
    "CPP_FILENAME",
    "FILE",
    "NUMBER",
    "CPP_NUMBER",
    "CPP_LITERAL",
    "CPP_MACRO_DEFN",
    "CPP_MACRO_VALUE",
    "ERROR",
    "CPP_ERROR",
    "CPP_WARNING",
    "CPP_PRAGMA",
    "CPP_INCLUDE",
    "CPP_DEFINE",
    "CPP_UNDEF",
    "CPP_LINE",
    "CPP_IF",
    "CPP_IFDEF",
    "CPP_IFNDEF",
    "CPP_THEN",
    "CPP_ELSE",
    "CPP_ELIF",
    "CPP_EMPTY",
    "CPP_REGION",
    "CPP_ENDREGION",
    "USING_STMT",
    "ESCAPE",
    "VALUE",
    "CPP_IMPORT",
    "CPP_ENDIF",
    "MARKER",
    "ERROR_PARSE",
    "ERROR_MODE",
    "IMPLEMENTS",
    "EXTENDS",
    "IMPORT",
    "PACKAGE",
    "ASSERT_STATEMENT",
    "INTERFACE",
    "INTERFACE_DECLARATION",
    "SYNCHRONIZED_STATEMENT",
    "ANNOTATION",
    "",
    "STATIC_BLOCK",
    "CHECKED_STATEMENT",
    "UNCHECKED_STATEMENT",
    "ATTRIBUTE",
    "TARGET",
    "UNSAFE_STATEMENT",
    "LOCK_STATEMENT",
    "FIXED_STATEMENT",
    "TYPEOF",
    "USING_STATEMENT",
    "FUNCTION_DELEGATE",
    "",
    "CONSTRAINT",
    "LINQ",
    "FROM",
    "WHERE",
    "SELECT",
    "LET",
    "ORDERBY",
    "JOIN",
    "GROUP",
    "IN",
    "ON",
    "EQUALS",
    "BY",
    "INTO",
    "EMPTY",
    "EMPTY_STMT",
    "RECEIVER",
    "MESSAGE",
    "SELECTOR",
    "PROTOCOL_LIST",
    "CATEGORY",
    "PROTOCOL",
    "REQUIRED_DEFAULT",
    "REQUIRED",
    "OPTIONAL",
    "",
    "ATTRIBUTE_LIST",
    "SYNTHESIZE",
    "DYNAMIC",
    "ENCODE",
    "AUTORELEASEPOOL",
    "COMPATIBILITY_ALIAS",
    "NIL",
    "CLASS_INTERFACE",
    "CLASS_IMPLEMENTATION",
    "PROTOCOL_DECLARATION",
    "CAST",
    "CONST_CAST",
    "DYNAMIC_CAST",
    "REINTERPRET_CAST",
    "STATIC_CAST",
    "POSITION",
    "CUDA_ARGUMENT_LIST",
    "OMP_DIRECTIVE",
    "OMP_NAME",
    "OMP_CLAUSE",
    "OMP_ARGUMENT_LIST",
    "OMP_ARGUMENT",
    "OMP_EXPRESSION",
    "END_ELEMENT_TOKEN",
    "MAIN",
    "BREAK",
    "CONTINUE",
    "WHILE",
    "DO",
    "FOR",
    "IF",
    "",
    "",
    "",
    "",
    "",
    "",
    "GOTO",
    "",
    "VISUAL_CXX_ASM",
    "SIZEOF",
    "",
    "AUTO",
    "REGISTER",
    "RESTRICT",
    "",
    "",
    "",
    "IMAGINARY",
    "NORETURN",
    "STATIC_ASSERT",
    "CRESTRICT",
    "CXX_TRY",
    "CXX_CATCH",
    "CXX_CLASS",
    "CONSTEXPR",
    "",
    "THREAD_LOCAL",
    "NULLPTR",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "VOID",
    "RETURN",
    "INCLUDE",
    "DEFINE",
    "ELIF",
    "ENDIF",
    "ERRORPREC",
    "WARNING",
    "IFDEF",
    "IFNDEF",
    "LINE",
    "PRAGMA",
    "UNDEF",
    "INLINE",
    "MACRO_TYPE_NAME",
    "MACRO_CASE",
    "MACRO_LABEL",
    "",
    "SPECIFIER",
    "TRY",
    "CATCH",
    "THROW",
    "THROWS",
    "",
    "PUBLIC",
    "PRIVATE",
    "PROTECTED",
    "VIRTUAL",
    "",
    "",
    "EXPLICIT",
    "FOREVER",
    "SIGNAL",
    "EMIT",
    "",
    "",
    "",
    "NEW",
    "DELETE",
    "STATIC",
    "CONST",
    "MUTABLE",
    "VOLATILE",
    "TRANSIENT",
    "",
    "",
    "FINALLY",
    "",
    "",
    "",
    "FINAL",
    "ABSTRACT",
    "SUPER",
    "SYNCHRONIZED",
    "NATIVE",
    "STRICTFP",
    "NULLLITERAL",
    "ASSERT",
    "FOREACH",
    "REF",
    "OUT",
    "",
    "LOCK",
    "IS",
    "INTERNAL",
    "SEALED",
    "OVERRIDE",
    "IMPLICIT",
    "STACKALLOC",
    "AS",
    "DELEGATE",
    "FIXED",
    "CHECKED",
    "UNCHECKED",
    "REGION",
    "ENDREGION",
    "UNSAFE",
    "READONLY",
    "GET",
    "SET",
    "ADD",
    "REMOVE",
    "YIELD",
    "PARTIAL",
    "AWAIT",
    "",
    "ASYNC",
    "THIS",
    "PARAMS",
    "",
    "ALIAS",
    "",
    "",
    "",
    "",
    "",
    "ASCENDING",
    "DESCENDING",
    "",
    "",
    "",
    "",
    "",
    "",
    "ATINTERFACE",
    "ATIMPLEMENTATION",
    "ATEND",
    "ATPROTOCOL",
    "ATREQUIRED",
    "ATOPTIONAL",
    "",
    "",
    "",
    "",
    "",
    "ATCLASS",
    "",
    "WEAK",
    "STRONG",
    "",
    "",
    "",
    "OMP_OMP",
    "SPECIAL_CHARS",
    nullptr
  };
  return names;
}

inline const char *EnumNameKind(Kind e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesKind()[index];
}

namespace _Unit {

enum LanguageType {
  LanguageType_DUMMY = 0,
  LanguageType_ALL = 1,
  LanguageType_OO = 2,
  LanguageType_CXX = 3,
  LanguageType_C = 4,
  LanguageType_C_FAMILY = 5,
  LanguageType_JAVA = 6,
  LanguageType_CSHARP = 7,
  LanguageType_OBJECTIVE_C = 8,
  LanguageType_MIN = LanguageType_DUMMY,
  LanguageType_MAX = LanguageType_OBJECTIVE_C
};

inline LanguageType (&EnumValuesLanguageType())[9] {
  static LanguageType values[] = {
    LanguageType_DUMMY,
    LanguageType_ALL,
    LanguageType_OO,
    LanguageType_CXX,
    LanguageType_C,
    LanguageType_C_FAMILY,
    LanguageType_JAVA,
    LanguageType_CSHARP,
    LanguageType_OBJECTIVE_C
  };
  return values;
}

inline const char **EnumNamesLanguageType() {
  static const char *names[] = {
    "DUMMY",
    "ALL",
    "OO",
    "CXX",
    "C",
    "C_FAMILY",
    "JAVA",
    "CSHARP",
    "OBJECTIVE_C",
    nullptr
  };
  return names;
}

inline const char *EnumNameLanguageType(LanguageType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLanguageType()[index];
}

}  // namespace _Unit

namespace _Literal {

enum LiteralType {
  LiteralType_dummy_type = 0,
  LiteralType_number_type = 1,
  LiteralType_char_type = 2,
  LiteralType_string_type = 3,
  LiteralType_boolean_type = 4,
  LiteralType_null_type = 5,
  LiteralType_MIN = LiteralType_dummy_type,
  LiteralType_MAX = LiteralType_null_type
};

inline LiteralType (&EnumValuesLiteralType())[6] {
  static LiteralType values[] = {
    LiteralType_dummy_type,
    LiteralType_number_type,
    LiteralType_char_type,
    LiteralType_string_type,
    LiteralType_boolean_type,
    LiteralType_null_type
  };
  return values;
}

inline const char **EnumNamesLiteralType() {
  static const char *names[] = {
    "dummy_type",
    "number_type",
    "char_type",
    "string_type",
    "boolean_type",
    "null_type",
    nullptr
  };
  return names;
}

inline const char *EnumNameLiteralType(LiteralType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLiteralType()[index];
}

}  // namespace _Literal
}  // namespace _Element

namespace _Delta {
namespace _Diff {

enum DeltaType {
  DeltaType_MATCH = 0,
  DeltaType_ADD = 1,
  DeltaType_DEL = 2,
  DeltaType_MOVE = 3,
  DeltaType_UPDATE = 4,
  DeltaType_MIN = DeltaType_MATCH,
  DeltaType_MAX = DeltaType_UPDATE
};

inline DeltaType (&EnumValuesDeltaType())[5] {
  static DeltaType values[] = {
    DeltaType_MATCH,
    DeltaType_ADD,
    DeltaType_DEL,
    DeltaType_MOVE,
    DeltaType_UPDATE
  };
  return values;
}

inline const char **EnumNamesDeltaType() {
  static const char *names[] = {
    "MATCH",
    "ADD",
    "DEL",
    "MOVE",
    "UPDATE",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeltaType(DeltaType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDeltaType()[index];
}

}  // namespace _Diff
}  // namespace _Delta

namespace _Pairs {
namespace _Pair {

enum CloneType {
  CloneType_MAYBE = 0,
  CloneType_YES = 1,
  CloneType_NO = 2,
  CloneType_MIN = CloneType_MAYBE,
  CloneType_MAX = CloneType_NO
};

inline CloneType (&EnumValuesCloneType())[3] {
  static CloneType values[] = {
    CloneType_MAYBE,
    CloneType_YES,
    CloneType_NO
  };
  return values;
}

inline const char **EnumNamesCloneType() {
  static const char *names[] = {
    "MAYBE",
    "YES",
    "NO",
    nullptr
  };
  return names;
}

inline const char *EnumNameCloneType(CloneType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCloneType()[index];
}

}  // namespace _Pair
}  // namespace _Pairs

namespace _Slices {
namespace _Slice {

enum ChangeType {
  ChangeType_UNCHANGED = 0,
  ChangeType_ADD = 1,
  ChangeType_DEL = 2,
  ChangeType_MIN = ChangeType_UNCHANGED,
  ChangeType_MAX = ChangeType_DEL
};

inline ChangeType (&EnumValuesChangeType())[3] {
  static ChangeType values[] = {
    ChangeType_UNCHANGED,
    ChangeType_ADD,
    ChangeType_DEL
  };
  return values;
}

inline const char **EnumNamesChangeType() {
  static const char *names[] = {
    "UNCHANGED",
    "ADD",
    "DEL",
    nullptr
  };
  return names;
}

inline const char *EnumNameChangeType(ChangeType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesChangeType()[index];
}

}  // namespace _Slice
}  // namespace _Slices

struct Element FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_TEXT = 6,
    VT_POS = 8,
    VT_LENGTH = 10,
    VT_CHILD = 12,
    VT_TAIL = 14,
    VT_EXTRA = 16,
    VT_LINE = 18,
    VT_COLUMN = 20
  };
  const _fast::_Element::Anonymous0 *type() const {
    return GetPointer<const _fast::_Element::Anonymous0 *>(VT_TYPE);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  int32_t pos() const {
    return GetField<int32_t>(VT_POS, 0);
  }
  int32_t length() const {
    return GetField<int32_t>(VT_LENGTH, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Element>> *child() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Element>> *>(VT_CHILD);
  }
  const flatbuffers::String *tail() const {
    return GetPointer<const flatbuffers::String *>(VT_TAIL);
  }
  const _fast::_Element::Anonymous1 *extra() const {
    return GetPointer<const _fast::_Element::Anonymous1 *>(VT_EXTRA);
  }
  int32_t line() const {
    return GetField<int32_t>(VT_LINE, 0);
  }
  int32_t column() const {
    return GetField<int32_t>(VT_COLUMN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           VerifyField<int32_t>(verifier, VT_POS) &&
           VerifyField<int32_t>(verifier, VT_LENGTH) &&
           VerifyOffset(verifier, VT_CHILD) &&
           verifier.Verify(child()) &&
           verifier.VerifyVectorOfTables(child()) &&
           VerifyOffset(verifier, VT_TAIL) &&
           verifier.Verify(tail()) &&
           VerifyOffset(verifier, VT_EXTRA) &&
           verifier.VerifyTable(extra()) &&
           VerifyField<int32_t>(verifier, VT_LINE) &&
           VerifyField<int32_t>(verifier, VT_COLUMN) &&
           verifier.EndTable();
  }
};

struct ElementBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<_fast::_Element::Anonymous0> type) {
    fbb_.AddOffset(Element::VT_TYPE, type);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(Element::VT_TEXT, text);
  }
  void add_pos(int32_t pos) {
    fbb_.AddElement<int32_t>(Element::VT_POS, pos, 0);
  }
  void add_length(int32_t length) {
    fbb_.AddElement<int32_t>(Element::VT_LENGTH, length, 0);
  }
  void add_child(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Element>>> child) {
    fbb_.AddOffset(Element::VT_CHILD, child);
  }
  void add_tail(flatbuffers::Offset<flatbuffers::String> tail) {
    fbb_.AddOffset(Element::VT_TAIL, tail);
  }
  void add_extra(flatbuffers::Offset<_fast::_Element::Anonymous1> extra) {
    fbb_.AddOffset(Element::VT_EXTRA, extra);
  }
  void add_line(int32_t line) {
    fbb_.AddElement<int32_t>(Element::VT_LINE, line, 0);
  }
  void add_column(int32_t column) {
    fbb_.AddElement<int32_t>(Element::VT_COLUMN, column, 0);
  }
  ElementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ElementBuilder &operator=(const ElementBuilder &);
  flatbuffers::Offset<Element> Finish() {
    const auto end = fbb_.EndTable(start_, 9);
    auto o = flatbuffers::Offset<Element>(end);
    return o;
  }
};

inline flatbuffers::Offset<Element> CreateElement(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<_fast::_Element::Anonymous0> type = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    int32_t pos = 0,
    int32_t length = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Element>>> child = 0,
    flatbuffers::Offset<flatbuffers::String> tail = 0,
    flatbuffers::Offset<_fast::_Element::Anonymous1> extra = 0,
    int32_t line = 0,
    int32_t column = 0) {
  ElementBuilder builder_(_fbb);
  builder_.add_column(column);
  builder_.add_line(line);
  builder_.add_extra(extra);
  builder_.add_tail(tail);
  builder_.add_child(child);
  builder_.add_length(length);
  builder_.add_pos(pos);
  builder_.add_text(text);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Element> CreateElementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<_fast::_Element::Anonymous0> type = 0,
    const char *text = nullptr,
    int32_t pos = 0,
    int32_t length = 0,
    const std::vector<flatbuffers::Offset<Element>> *child = nullptr,
    const char *tail = nullptr,
    flatbuffers::Offset<_fast::_Element::Anonymous1> extra = 0,
    int32_t line = 0,
    int32_t column = 0) {
  return _fast::CreateElement(
      _fbb,
      type,
      text ? _fbb.CreateString(text) : 0,
      pos,
      length,
      child ? _fbb.CreateVector<flatbuffers::Offset<Element>>(*child) : 0,
      tail ? _fbb.CreateString(tail) : 0,
      extra,
      line,
      column);
}

namespace _Element {

struct Anonymous0 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KIND = 4,
    VT_SMALI_KIND = 6
  };
  int32_t kind() const {
    return GetField<int32_t>(VT_KIND, 0);
  }
  int32_t smali_kind() const {
    return GetField<int32_t>(VT_SMALI_KIND, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KIND) &&
           VerifyField<int32_t>(verifier, VT_SMALI_KIND) &&
           verifier.EndTable();
  }
};

struct Anonymous0Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kind(int32_t kind) {
    fbb_.AddElement<int32_t>(Anonymous0::VT_KIND, kind, 0);
  }
  void add_smali_kind(int32_t smali_kind) {
    fbb_.AddElement<int32_t>(Anonymous0::VT_SMALI_KIND, smali_kind, 0);
  }
  Anonymous0Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Anonymous0Builder &operator=(const Anonymous0Builder &);
  flatbuffers::Offset<Anonymous0> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Anonymous0>(end);
    return o;
  }
};

inline flatbuffers::Offset<Anonymous0> CreateAnonymous0(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kind = 0,
    int32_t smali_kind = 0) {
  Anonymous0Builder builder_(_fbb);
  builder_.add_smali_kind(smali_kind);
  builder_.add_kind(kind);
  return builder_.Finish();
}

struct Anonymous1 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UNIT = 4,
    VT_LITERAL = 6
  };
  const Unit *unit() const {
    return GetPointer<const Unit *>(VT_UNIT);
  }
  const Literal *literal() const {
    return GetPointer<const Literal *>(VT_LITERAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UNIT) &&
           verifier.VerifyTable(unit()) &&
           VerifyOffset(verifier, VT_LITERAL) &&
           verifier.VerifyTable(literal()) &&
           verifier.EndTable();
  }
};

struct Anonymous1Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_unit(flatbuffers::Offset<Unit> unit) {
    fbb_.AddOffset(Anonymous1::VT_UNIT, unit);
  }
  void add_literal(flatbuffers::Offset<Literal> literal) {
    fbb_.AddOffset(Anonymous1::VT_LITERAL, literal);
  }
  Anonymous1Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Anonymous1Builder &operator=(const Anonymous1Builder &);
  flatbuffers::Offset<Anonymous1> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Anonymous1>(end);
    return o;
  }
};

inline flatbuffers::Offset<Anonymous1> CreateAnonymous1(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Unit> unit = 0,
    flatbuffers::Offset<Literal> literal = 0) {
  Anonymous1Builder builder_(_fbb);
  builder_.add_literal(literal);
  builder_.add_unit(unit);
  return builder_.Finish();
}

struct Unit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FILENAME = 4,
    VT_REVISION = 6,
    VT_LANGUAGE = 8,
    VT_ITEM = 10
  };
  const flatbuffers::String *filename() const {
    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
  }
  const flatbuffers::String *revision() const {
    return GetPointer<const flatbuffers::String *>(VT_REVISION);
  }
  int32_t language() const {
    return GetField<int32_t>(VT_LANGUAGE, 0);
  }
  int32_t item() const {
    return GetField<int32_t>(VT_ITEM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.Verify(filename()) &&
           VerifyOffset(verifier, VT_REVISION) &&
           verifier.Verify(revision()) &&
           VerifyField<int32_t>(verifier, VT_LANGUAGE) &&
           VerifyField<int32_t>(verifier, VT_ITEM) &&
           verifier.EndTable();
  }
};

struct UnitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) {
    fbb_.AddOffset(Unit::VT_FILENAME, filename);
  }
  void add_revision(flatbuffers::Offset<flatbuffers::String> revision) {
    fbb_.AddOffset(Unit::VT_REVISION, revision);
  }
  void add_language(int32_t language) {
    fbb_.AddElement<int32_t>(Unit::VT_LANGUAGE, language, 0);
  }
  void add_item(int32_t item) {
    fbb_.AddElement<int32_t>(Unit::VT_ITEM, item, 0);
  }
  UnitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnitBuilder &operator=(const UnitBuilder &);
  flatbuffers::Offset<Unit> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Unit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unit> CreateUnit(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> filename = 0,
    flatbuffers::Offset<flatbuffers::String> revision = 0,
    int32_t language = 0,
    int32_t item = 0) {
  UnitBuilder builder_(_fbb);
  builder_.add_item(item);
  builder_.add_language(language);
  builder_.add_revision(revision);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline flatbuffers::Offset<Unit> CreateUnitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr,
    const char *revision = nullptr,
    int32_t language = 0,
    int32_t item = 0) {
  return _fast::_Element::CreateUnit(
      _fbb,
      filename ? _fbb.CreateString(filename) : 0,
      revision ? _fbb.CreateString(revision) : 0,
      language,
      item);
}

struct Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct LiteralBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Literal::VT_TYPE, type, 0);
  }
  LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiteralBuilder &operator=(const LiteralBuilder &);
  flatbuffers::Offset<Literal> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Literal> CreateLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0) {
  LiteralBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

}  // namespace _Element

struct Delta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_DST = 6,
    VT_DIFF = 8
  };
  const flatbuffers::String *src() const {
    return GetPointer<const flatbuffers::String *>(VT_SRC);
  }
  const flatbuffers::String *dst() const {
    return GetPointer<const flatbuffers::String *>(VT_DST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Delta::Diff>> *diff() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Delta::Diff>> *>(VT_DIFF);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SRC) &&
           verifier.Verify(src()) &&
           VerifyOffset(verifier, VT_DST) &&
           verifier.Verify(dst()) &&
           VerifyOffset(verifier, VT_DIFF) &&
           verifier.Verify(diff()) &&
           verifier.VerifyVectorOfTables(diff()) &&
           verifier.EndTable();
  }
};

struct DeltaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(flatbuffers::Offset<flatbuffers::String> src) {
    fbb_.AddOffset(Delta::VT_SRC, src);
  }
  void add_dst(flatbuffers::Offset<flatbuffers::String> dst) {
    fbb_.AddOffset(Delta::VT_DST, dst);
  }
  void add_diff(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Delta::Diff>>> diff) {
    fbb_.AddOffset(Delta::VT_DIFF, diff);
  }
  DeltaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeltaBuilder &operator=(const DeltaBuilder &);
  flatbuffers::Offset<Delta> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Delta>(end);
    return o;
  }
};

inline flatbuffers::Offset<Delta> CreateDelta(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> src = 0,
    flatbuffers::Offset<flatbuffers::String> dst = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Delta::Diff>>> diff = 0) {
  DeltaBuilder builder_(_fbb);
  builder_.add_diff(diff);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

inline flatbuffers::Offset<Delta> CreateDeltaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *src = nullptr,
    const char *dst = nullptr,
    const std::vector<flatbuffers::Offset<_fast::_Delta::Diff>> *diff = nullptr) {
  return _fast::CreateDelta(
      _fbb,
      src ? _fbb.CreateString(src) : 0,
      dst ? _fbb.CreateString(dst) : 0,
      diff ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Delta::Diff>>(*diff) : 0);
}

namespace _Delta {

struct Diff FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_DELTA = 6
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const _fast::_Delta::_Diff::Anonymous2 *delta() const {
    return GetPointer<const _fast::_Delta::_Diff::Anonymous2 *>(VT_DELTA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_DELTA) &&
           verifier.VerifyTable(delta()) &&
           verifier.EndTable();
  }
};

struct DiffBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Diff::VT_TYPE, type, 0);
  }
  void add_delta(flatbuffers::Offset<_fast::_Delta::_Diff::Anonymous2> delta) {
    fbb_.AddOffset(Diff::VT_DELTA, delta);
  }
  DiffBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiffBuilder &operator=(const DiffBuilder &);
  flatbuffers::Offset<Diff> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Diff>(end);
    return o;
  }
};

inline flatbuffers::Offset<Diff> CreateDiff(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    flatbuffers::Offset<_fast::_Delta::_Diff::Anonymous2> delta = 0) {
  DiffBuilder builder_(_fbb);
  builder_.add_delta(delta);
  builder_.add_type(type);
  return builder_.Finish();
}

namespace _Diff {

struct Anonymous2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MATCH = 4,
    VT_ADD = 6,
    VT_DEL = 8,
    VT_MOVE = 10,
    VT_UPDATE = 12
  };
  const Match *match() const {
    return GetPointer<const Match *>(VT_MATCH);
  }
  const Add *add() const {
    return GetPointer<const Add *>(VT_ADD);
  }
  const Del *del() const {
    return GetPointer<const Del *>(VT_DEL);
  }
  const Move *move() const {
    return GetPointer<const Move *>(VT_MOVE);
  }
  const Update *update() const {
    return GetPointer<const Update *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MATCH) &&
           verifier.VerifyTable(match()) &&
           VerifyOffset(verifier, VT_ADD) &&
           verifier.VerifyTable(add()) &&
           VerifyOffset(verifier, VT_DEL) &&
           verifier.VerifyTable(del()) &&
           VerifyOffset(verifier, VT_MOVE) &&
           verifier.VerifyTable(move()) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
};

struct Anonymous2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_match(flatbuffers::Offset<Match> match) {
    fbb_.AddOffset(Anonymous2::VT_MATCH, match);
  }
  void add_add(flatbuffers::Offset<Add> add) {
    fbb_.AddOffset(Anonymous2::VT_ADD, add);
  }
  void add_del(flatbuffers::Offset<Del> del) {
    fbb_.AddOffset(Anonymous2::VT_DEL, del);
  }
  void add_move(flatbuffers::Offset<Move> move) {
    fbb_.AddOffset(Anonymous2::VT_MOVE, move);
  }
  void add_update(flatbuffers::Offset<Update> update) {
    fbb_.AddOffset(Anonymous2::VT_UPDATE, update);
  }
  Anonymous2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Anonymous2Builder &operator=(const Anonymous2Builder &);
  flatbuffers::Offset<Anonymous2> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<Anonymous2>(end);
    return o;
  }
};

inline flatbuffers::Offset<Anonymous2> CreateAnonymous2(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Match> match = 0,
    flatbuffers::Offset<Add> add = 0,
    flatbuffers::Offset<Del> del = 0,
    flatbuffers::Offset<Move> move = 0,
    flatbuffers::Offset<Update> update = 0) {
  Anonymous2Builder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_move(move);
  builder_.add_del(del);
  builder_.add_add(add);
  builder_.add_match(match);
  return builder_.Finish();
}

struct Match FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_DST = 6
  };
  int32_t src() const {
    return GetField<int32_t>(VT_SRC, 0);
  }
  int32_t dst() const {
    return GetField<int32_t>(VT_DST, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRC) &&
           VerifyField<int32_t>(verifier, VT_DST) &&
           verifier.EndTable();
  }
};

struct MatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(int32_t src) {
    fbb_.AddElement<int32_t>(Match::VT_SRC, src, 0);
  }
  void add_dst(int32_t dst) {
    fbb_.AddElement<int32_t>(Match::VT_DST, dst, 0);
  }
  MatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatchBuilder &operator=(const MatchBuilder &);
  flatbuffers::Offset<Match> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Match>(end);
    return o;
  }
};

inline flatbuffers::Offset<Match> CreateMatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0,
    int32_t dst = 0) {
  MatchBuilder builder_(_fbb);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

struct Add FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_DST = 6,
    VT_POSITION = 8
  };
  int32_t src() const {
    return GetField<int32_t>(VT_SRC, 0);
  }
  int32_t dst() const {
    return GetField<int32_t>(VT_DST, 0);
  }
  int32_t position() const {
    return GetField<int32_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRC) &&
           VerifyField<int32_t>(verifier, VT_DST) &&
           VerifyField<int32_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct AddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(int32_t src) {
    fbb_.AddElement<int32_t>(Add::VT_SRC, src, 0);
  }
  void add_dst(int32_t dst) {
    fbb_.AddElement<int32_t>(Add::VT_DST, dst, 0);
  }
  void add_position(int32_t position) {
    fbb_.AddElement<int32_t>(Add::VT_POSITION, position, 0);
  }
  AddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddBuilder &operator=(const AddBuilder &);
  flatbuffers::Offset<Add> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Add>(end);
    return o;
  }
};

inline flatbuffers::Offset<Add> CreateAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0,
    int32_t dst = 0,
    int32_t position = 0) {
  AddBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

struct Del FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4
  };
  int32_t src() const {
    return GetField<int32_t>(VT_SRC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRC) &&
           verifier.EndTable();
  }
};

struct DelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(int32_t src) {
    fbb_.AddElement<int32_t>(Del::VT_SRC, src, 0);
  }
  DelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DelBuilder &operator=(const DelBuilder &);
  flatbuffers::Offset<Del> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Del>(end);
    return o;
  }
};

inline flatbuffers::Offset<Del> CreateDel(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0) {
  DelBuilder builder_(_fbb);
  builder_.add_src(src);
  return builder_.Finish();
}

struct Move FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_DST = 6,
    VT_POSITION = 8
  };
  int32_t src() const {
    return GetField<int32_t>(VT_SRC, 0);
  }
  int32_t dst() const {
    return GetField<int32_t>(VT_DST, 0);
  }
  int32_t position() const {
    return GetField<int32_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRC) &&
           VerifyField<int32_t>(verifier, VT_DST) &&
           VerifyField<int32_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct MoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(int32_t src) {
    fbb_.AddElement<int32_t>(Move::VT_SRC, src, 0);
  }
  void add_dst(int32_t dst) {
    fbb_.AddElement<int32_t>(Move::VT_DST, dst, 0);
  }
  void add_position(int32_t position) {
    fbb_.AddElement<int32_t>(Move::VT_POSITION, position, 0);
  }
  MoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveBuilder &operator=(const MoveBuilder &);
  flatbuffers::Offset<Move> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Move>(end);
    return o;
  }
};

inline flatbuffers::Offset<Move> CreateMove(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0,
    int32_t dst = 0,
    int32_t position = 0) {
  MoveBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

struct Update FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_LABEL = 6
  };
  int32_t src() const {
    return GetField<int32_t>(VT_SRC, 0);
  }
  const flatbuffers::String *label() const {
    return GetPointer<const flatbuffers::String *>(VT_LABEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRC) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.Verify(label()) &&
           verifier.EndTable();
  }
};

struct UpdateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(int32_t src) {
    fbb_.AddElement<int32_t>(Update::VT_SRC, src, 0);
  }
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(Update::VT_LABEL, label);
  }
  UpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdateBuilder &operator=(const UpdateBuilder &);
  flatbuffers::Offset<Update> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Update>(end);
    return o;
  }
};

inline flatbuffers::Offset<Update> CreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0,
    flatbuffers::Offset<flatbuffers::String> label = 0) {
  UpdateBuilder builder_(_fbb);
  builder_.add_label(label);
  builder_.add_src(src);
  return builder_.Finish();
}

inline flatbuffers::Offset<Update> CreateUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0,
    const char *label = nullptr) {
  return _fast::_Delta::_Diff::CreateUpdate(
      _fbb,
      src,
      label ? _fbb.CreateString(label) : 0);
}

}  // namespace _Diff
}  // namespace _Delta

struct Pairs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PAIR = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Pairs::Pair>> *pair() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Pairs::Pair>> *>(VT_PAIR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAIR) &&
           verifier.Verify(pair()) &&
           verifier.VerifyVectorOfTables(pair()) &&
           verifier.EndTable();
  }
};

struct PairsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pair(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Pairs::Pair>>> pair) {
    fbb_.AddOffset(Pairs::VT_PAIR, pair);
  }
  PairsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PairsBuilder &operator=(const PairsBuilder &);
  flatbuffers::Offset<Pairs> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Pairs>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pairs> CreatePairs(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Pairs::Pair>>> pair = 0) {
  PairsBuilder builder_(_fbb);
  builder_.add_pair(pair);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pairs> CreatePairsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<_fast::_Pairs::Pair>> *pair = nullptr) {
  return _fast::CreatePairs(
      _fbb,
      pair ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Pairs::Pair>>(*pair) : 0);
}

namespace _Pairs {

struct Pair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PROJECT = 4,
    VT_LEFT = 6,
    VT_RIGHT = 8,
    VT_TYPE = 10
  };
  const flatbuffers::String *project() const {
    return GetPointer<const flatbuffers::String *>(VT_PROJECT);
  }
  const _fast::_Pairs::_Pair::Diff *left() const {
    return GetPointer<const _fast::_Pairs::_Pair::Diff *>(VT_LEFT);
  }
  const _fast::_Pairs::_Pair::Diff *right() const {
    return GetPointer<const _fast::_Pairs::_Pair::Diff *>(VT_RIGHT);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROJECT) &&
           verifier.Verify(project()) &&
           VerifyOffset(verifier, VT_LEFT) &&
           verifier.VerifyTable(left()) &&
           VerifyOffset(verifier, VT_RIGHT) &&
           verifier.VerifyTable(right()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct PairBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_project(flatbuffers::Offset<flatbuffers::String> project) {
    fbb_.AddOffset(Pair::VT_PROJECT, project);
  }
  void add_left(flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> left) {
    fbb_.AddOffset(Pair::VT_LEFT, left);
  }
  void add_right(flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> right) {
    fbb_.AddOffset(Pair::VT_RIGHT, right);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Pair::VT_TYPE, type, 0);
  }
  PairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PairBuilder &operator=(const PairBuilder &);
  flatbuffers::Offset<Pair> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Pair>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pair> CreatePair(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> project = 0,
    flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> left = 0,
    flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> right = 0,
    int32_t type = 0) {
  PairBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_right(right);
  builder_.add_left(left);
  builder_.add_project(project);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pair> CreatePairDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *project = nullptr,
    flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> left = 0,
    flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> right = 0,
    int32_t type = 0) {
  return _fast::_Pairs::CreatePair(
      _fbb,
      project ? _fbb.CreateString(project) : 0,
      left,
      right,
      type);
}

namespace _Pair {

struct Diff FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LEFT_LINE = 4,
    VT_LEFT_COLUMN = 6,
    VT_RIGHT_LINE = 8,
    VT_RIGHT_COLUMN = 10,
    VT_OLD_CODE = 12,
    VT_NEW_CODE = 14,
    VT_HASH = 16,
    VT_SLICES = 18
  };
  int32_t left_line() const {
    return GetField<int32_t>(VT_LEFT_LINE, 0);
  }
  int32_t left_column() const {
    return GetField<int32_t>(VT_LEFT_COLUMN, 0);
  }
  int32_t right_line() const {
    return GetField<int32_t>(VT_RIGHT_LINE, 0);
  }
  int32_t right_column() const {
    return GetField<int32_t>(VT_RIGHT_COLUMN, 0);
  }
  const _fast::Element *old_code() const {
    return GetPointer<const _fast::Element *>(VT_OLD_CODE);
  }
  const _fast::Element *new_code() const {
    return GetPointer<const _fast::Element *>(VT_NEW_CODE);
  }
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  const _fast::Slices *slices() const {
    return GetPointer<const _fast::Slices *>(VT_SLICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LEFT_LINE) &&
           VerifyField<int32_t>(verifier, VT_LEFT_COLUMN) &&
           VerifyField<int32_t>(verifier, VT_RIGHT_LINE) &&
           VerifyField<int32_t>(verifier, VT_RIGHT_COLUMN) &&
           VerifyOffset(verifier, VT_OLD_CODE) &&
           verifier.VerifyTable(old_code()) &&
           VerifyOffset(verifier, VT_NEW_CODE) &&
           verifier.VerifyTable(new_code()) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.Verify(hash()) &&
           VerifyOffset(verifier, VT_SLICES) &&
           verifier.VerifyTable(slices()) &&
           verifier.EndTable();
  }
};

struct DiffBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_left_line(int32_t left_line) {
    fbb_.AddElement<int32_t>(Diff::VT_LEFT_LINE, left_line, 0);
  }
  void add_left_column(int32_t left_column) {
    fbb_.AddElement<int32_t>(Diff::VT_LEFT_COLUMN, left_column, 0);
  }
  void add_right_line(int32_t right_line) {
    fbb_.AddElement<int32_t>(Diff::VT_RIGHT_LINE, right_line, 0);
  }
  void add_right_column(int32_t right_column) {
    fbb_.AddElement<int32_t>(Diff::VT_RIGHT_COLUMN, right_column, 0);
  }
  void add_old_code(flatbuffers::Offset<_fast::Element> old_code) {
    fbb_.AddOffset(Diff::VT_OLD_CODE, old_code);
  }
  void add_new_code(flatbuffers::Offset<_fast::Element> new_code) {
    fbb_.AddOffset(Diff::VT_NEW_CODE, new_code);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(Diff::VT_HASH, hash);
  }
  void add_slices(flatbuffers::Offset<_fast::Slices> slices) {
    fbb_.AddOffset(Diff::VT_SLICES, slices);
  }
  DiffBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiffBuilder &operator=(const DiffBuilder &);
  flatbuffers::Offset<Diff> Finish() {
    const auto end = fbb_.EndTable(start_, 8);
    auto o = flatbuffers::Offset<Diff>(end);
    return o;
  }
};

inline flatbuffers::Offset<Diff> CreateDiff(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t left_line = 0,
    int32_t left_column = 0,
    int32_t right_line = 0,
    int32_t right_column = 0,
    flatbuffers::Offset<_fast::Element> old_code = 0,
    flatbuffers::Offset<_fast::Element> new_code = 0,
    flatbuffers::Offset<flatbuffers::String> hash = 0,
    flatbuffers::Offset<_fast::Slices> slices = 0) {
  DiffBuilder builder_(_fbb);
  builder_.add_slices(slices);
  builder_.add_hash(hash);
  builder_.add_new_code(new_code);
  builder_.add_old_code(old_code);
  builder_.add_right_column(right_column);
  builder_.add_right_line(right_line);
  builder_.add_left_column(left_column);
  builder_.add_left_line(left_line);
  return builder_.Finish();
}

inline flatbuffers::Offset<Diff> CreateDiffDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t left_line = 0,
    int32_t left_column = 0,
    int32_t right_line = 0,
    int32_t right_column = 0,
    flatbuffers::Offset<_fast::Element> old_code = 0,
    flatbuffers::Offset<_fast::Element> new_code = 0,
    const char *hash = nullptr,
    flatbuffers::Offset<_fast::Slices> slices = 0) {
  return _fast::_Pairs::_Pair::CreateDiff(
      _fbb,
      left_line,
      left_column,
      right_line,
      right_column,
      old_code,
      new_code,
      hash ? _fbb.CreateString(hash) : 0,
      slices);
}

}  // namespace _Pair
}  // namespace _Pairs

struct Log FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COMMIT = 4,
    VT_AUTHOR = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::Commit>> *commit() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::Commit>> *>(VT_COMMIT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::Author>> *author() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::Author>> *>(VT_AUTHOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMIT) &&
           verifier.Verify(commit()) &&
           verifier.VerifyVectorOfTables(commit()) &&
           VerifyOffset(verifier, VT_AUTHOR) &&
           verifier.Verify(author()) &&
           verifier.VerifyVectorOfTables(author()) &&
           verifier.EndTable();
  }
};

struct LogBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_commit(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::Commit>>> commit) {
    fbb_.AddOffset(Log::VT_COMMIT, commit);
  }
  void add_author(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::Author>>> author) {
    fbb_.AddOffset(Log::VT_AUTHOR, author);
  }
  LogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogBuilder &operator=(const LogBuilder &);
  flatbuffers::Offset<Log> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Log>(end);
    return o;
  }
};

inline flatbuffers::Offset<Log> CreateLog(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::Commit>>> commit = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::Author>>> author = 0) {
  LogBuilder builder_(_fbb);
  builder_.add_author(author);
  builder_.add_commit(commit);
  return builder_.Finish();
}

inline flatbuffers::Offset<Log> CreateLogDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<_fast::_Log::Commit>> *commit = nullptr,
    const std::vector<flatbuffers::Offset<_fast::_Log::Author>> *author = nullptr) {
  return _fast::CreateLog(
      _fbb,
      commit ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Log::Commit>>(*commit) : 0,
      author ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Log::Author>>(*author) : 0);
}

namespace _Log {

struct Commit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_TEXT = 6,
    VT_AUTHOR_ID = 8,
    VT_AUTHOR_DATE = 10,
    VT_EXTRA = 12,
    VT_DIFF = 14,
    VT_SLICE = 16
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  int32_t author_id() const {
    return GetField<int32_t>(VT_AUTHOR_ID, 0);
  }
  const flatbuffers::String *author_date() const {
    return GetPointer<const flatbuffers::String *>(VT_AUTHOR_DATE);
  }
  const _fast::_Log::_Commit::Anonymous3 *extra() const {
    return GetPointer<const _fast::_Log::_Commit::Anonymous3 *>(VT_EXTRA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::Diff>> *diff() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::Diff>> *>(VT_DIFF);
  }
  const _fast::Slices *slice() const {
    return GetPointer<const _fast::Slices *>(VT_SLICE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.Verify(id()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           VerifyField<int32_t>(verifier, VT_AUTHOR_ID) &&
           VerifyOffset(verifier, VT_AUTHOR_DATE) &&
           verifier.Verify(author_date()) &&
           VerifyOffset(verifier, VT_EXTRA) &&
           verifier.VerifyTable(extra()) &&
           VerifyOffset(verifier, VT_DIFF) &&
           verifier.Verify(diff()) &&
           verifier.VerifyVectorOfTables(diff()) &&
           VerifyOffset(verifier, VT_SLICE) &&
           verifier.VerifyTable(slice()) &&
           verifier.EndTable();
  }
};

struct CommitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Commit::VT_ID, id);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(Commit::VT_TEXT, text);
  }
  void add_author_id(int32_t author_id) {
    fbb_.AddElement<int32_t>(Commit::VT_AUTHOR_ID, author_id, 0);
  }
  void add_author_date(flatbuffers::Offset<flatbuffers::String> author_date) {
    fbb_.AddOffset(Commit::VT_AUTHOR_DATE, author_date);
  }
  void add_extra(flatbuffers::Offset<_fast::_Log::_Commit::Anonymous3> extra) {
    fbb_.AddOffset(Commit::VT_EXTRA, extra);
  }
  void add_diff(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::Diff>>> diff) {
    fbb_.AddOffset(Commit::VT_DIFF, diff);
  }
  void add_slice(flatbuffers::Offset<_fast::Slices> slice) {
    fbb_.AddOffset(Commit::VT_SLICE, slice);
  }
  CommitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommitBuilder &operator=(const CommitBuilder &);
  flatbuffers::Offset<Commit> Finish() {
    const auto end = fbb_.EndTable(start_, 7);
    auto o = flatbuffers::Offset<Commit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Commit> CreateCommit(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    int32_t author_id = 0,
    flatbuffers::Offset<flatbuffers::String> author_date = 0,
    flatbuffers::Offset<_fast::_Log::_Commit::Anonymous3> extra = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::Diff>>> diff = 0,
    flatbuffers::Offset<_fast::Slices> slice = 0) {
  CommitBuilder builder_(_fbb);
  builder_.add_slice(slice);
  builder_.add_diff(diff);
  builder_.add_extra(extra);
  builder_.add_author_date(author_date);
  builder_.add_author_id(author_id);
  builder_.add_text(text);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Commit> CreateCommitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *text = nullptr,
    int32_t author_id = 0,
    const char *author_date = nullptr,
    flatbuffers::Offset<_fast::_Log::_Commit::Anonymous3> extra = 0,
    const std::vector<flatbuffers::Offset<_fast::_Log::_Commit::Diff>> *diff = nullptr,
    flatbuffers::Offset<_fast::Slices> slice = 0) {
  return _fast::_Log::CreateCommit(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      text ? _fbb.CreateString(text) : 0,
      author_id,
      author_date ? _fbb.CreateString(author_date) : 0,
      extra,
      diff ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Log::_Commit::Diff>>(*diff) : 0,
      slice);
}

namespace _Commit {

struct Anonymous3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COMMITTER = 4
  };
  const Committer *committer() const {
    return GetPointer<const Committer *>(VT_COMMITTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMITTER) &&
           verifier.VerifyTable(committer()) &&
           verifier.EndTable();
  }
};

struct Anonymous3Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_committer(flatbuffers::Offset<Committer> committer) {
    fbb_.AddOffset(Anonymous3::VT_COMMITTER, committer);
  }
  Anonymous3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Anonymous3Builder &operator=(const Anonymous3Builder &);
  flatbuffers::Offset<Anonymous3> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Anonymous3>(end);
    return o;
  }
};

inline flatbuffers::Offset<Anonymous3> CreateAnonymous3(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Committer> committer = 0) {
  Anonymous3Builder builder_(_fbb);
  builder_.add_committer(committer);
  return builder_.Finish();
}

struct Committer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COMMITTER_ID = 4,
    VT_COMMIT_DATE = 6
  };
  int32_t committer_id() const {
    return GetField<int32_t>(VT_COMMITTER_ID, 0);
  }
  const flatbuffers::String *commit_date() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMIT_DATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COMMITTER_ID) &&
           VerifyOffset(verifier, VT_COMMIT_DATE) &&
           verifier.Verify(commit_date()) &&
           verifier.EndTable();
  }
};

struct CommitterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_committer_id(int32_t committer_id) {
    fbb_.AddElement<int32_t>(Committer::VT_COMMITTER_ID, committer_id, 0);
  }
  void add_commit_date(flatbuffers::Offset<flatbuffers::String> commit_date) {
    fbb_.AddOffset(Committer::VT_COMMIT_DATE, commit_date);
  }
  CommitterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommitterBuilder &operator=(const CommitterBuilder &);
  flatbuffers::Offset<Committer> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Committer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Committer> CreateCommitter(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t committer_id = 0,
    flatbuffers::Offset<flatbuffers::String> commit_date = 0) {
  CommitterBuilder builder_(_fbb);
  builder_.add_commit_date(commit_date);
  builder_.add_committer_id(committer_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Committer> CreateCommitterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t committer_id = 0,
    const char *commit_date = nullptr) {
  return _fast::_Log::_Commit::CreateCommitter(
      _fbb,
      committer_id,
      commit_date ? _fbb.CreateString(commit_date) : 0);
}

struct Diff FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_A = 4,
    VT_B = 6,
    VT_IS_NEW = 8,
    VT_IS_CODE = 10,
    VT_INDEX_FROM = 12,
    VT_INDEX_TO = 14,
    VT_MODE = 16,
    VT_HUNK = 18
  };
  const flatbuffers::String *a() const {
    return GetPointer<const flatbuffers::String *>(VT_A);
  }
  const flatbuffers::String *b() const {
    return GetPointer<const flatbuffers::String *>(VT_B);
  }
  bool is_new() const {
    return GetField<uint8_t>(VT_IS_NEW, 0) != 0;
  }
  const flatbuffers::String *is_code() const {
    return GetPointer<const flatbuffers::String *>(VT_IS_CODE);
  }
  const flatbuffers::String *index_from() const {
    return GetPointer<const flatbuffers::String *>(VT_INDEX_FROM);
  }
  const flatbuffers::String *index_to() const {
    return GetPointer<const flatbuffers::String *>(VT_INDEX_TO);
  }
  const flatbuffers::String *mode() const {
    return GetPointer<const flatbuffers::String *>(VT_MODE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::Hunk>> *hunk() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::Hunk>> *>(VT_HUNK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_A) &&
           verifier.Verify(a()) &&
           VerifyOffset(verifier, VT_B) &&
           verifier.Verify(b()) &&
           VerifyField<uint8_t>(verifier, VT_IS_NEW) &&
           VerifyOffset(verifier, VT_IS_CODE) &&
           verifier.Verify(is_code()) &&
           VerifyOffset(verifier, VT_INDEX_FROM) &&
           verifier.Verify(index_from()) &&
           VerifyOffset(verifier, VT_INDEX_TO) &&
           verifier.Verify(index_to()) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.Verify(mode()) &&
           VerifyOffset(verifier, VT_HUNK) &&
           verifier.Verify(hunk()) &&
           verifier.VerifyVectorOfTables(hunk()) &&
           verifier.EndTable();
  }
};

struct DiffBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_a(flatbuffers::Offset<flatbuffers::String> a) {
    fbb_.AddOffset(Diff::VT_A, a);
  }
  void add_b(flatbuffers::Offset<flatbuffers::String> b) {
    fbb_.AddOffset(Diff::VT_B, b);
  }
  void add_is_new(bool is_new) {
    fbb_.AddElement<uint8_t>(Diff::VT_IS_NEW, static_cast<uint8_t>(is_new), 0);
  }
  void add_is_code(flatbuffers::Offset<flatbuffers::String> is_code) {
    fbb_.AddOffset(Diff::VT_IS_CODE, is_code);
  }
  void add_index_from(flatbuffers::Offset<flatbuffers::String> index_from) {
    fbb_.AddOffset(Diff::VT_INDEX_FROM, index_from);
  }
  void add_index_to(flatbuffers::Offset<flatbuffers::String> index_to) {
    fbb_.AddOffset(Diff::VT_INDEX_TO, index_to);
  }
  void add_mode(flatbuffers::Offset<flatbuffers::String> mode) {
    fbb_.AddOffset(Diff::VT_MODE, mode);
  }
  void add_hunk(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::Hunk>>> hunk) {
    fbb_.AddOffset(Diff::VT_HUNK, hunk);
  }
  DiffBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiffBuilder &operator=(const DiffBuilder &);
  flatbuffers::Offset<Diff> Finish() {
    const auto end = fbb_.EndTable(start_, 8);
    auto o = flatbuffers::Offset<Diff>(end);
    return o;
  }
};

inline flatbuffers::Offset<Diff> CreateDiff(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> a = 0,
    flatbuffers::Offset<flatbuffers::String> b = 0,
    bool is_new = false,
    flatbuffers::Offset<flatbuffers::String> is_code = 0,
    flatbuffers::Offset<flatbuffers::String> index_from = 0,
    flatbuffers::Offset<flatbuffers::String> index_to = 0,
    flatbuffers::Offset<flatbuffers::String> mode = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::Hunk>>> hunk = 0) {
  DiffBuilder builder_(_fbb);
  builder_.add_hunk(hunk);
  builder_.add_mode(mode);
  builder_.add_index_to(index_to);
  builder_.add_index_from(index_from);
  builder_.add_is_code(is_code);
  builder_.add_b(b);
  builder_.add_a(a);
  builder_.add_is_new(is_new);
  return builder_.Finish();
}

inline flatbuffers::Offset<Diff> CreateDiffDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *a = nullptr,
    const char *b = nullptr,
    bool is_new = false,
    const char *is_code = nullptr,
    const char *index_from = nullptr,
    const char *index_to = nullptr,
    const char *mode = nullptr,
    const std::vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::Hunk>> *hunk = nullptr) {
  return _fast::_Log::_Commit::CreateDiff(
      _fbb,
      a ? _fbb.CreateString(a) : 0,
      b ? _fbb.CreateString(b) : 0,
      is_new,
      is_code ? _fbb.CreateString(is_code) : 0,
      index_from ? _fbb.CreateString(index_from) : 0,
      index_to ? _fbb.CreateString(index_to) : 0,
      mode ? _fbb.CreateString(mode) : 0,
      hunk ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::Hunk>>(*hunk) : 0);
}

namespace _Diff {

struct Hunk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FROM_LINENO = 4,
    VT_FROM_COLUMN = 6,
    VT_TO_LINENO = 8,
    VT_TO_COLUMN = 10,
    VT_CONTEXT = 12,
    VT_ELEMENT = 14,
    VT_MOD = 16,
    VT_SLICE = 18
  };
  int32_t from_lineno() const {
    return GetField<int32_t>(VT_FROM_LINENO, 0);
  }
  int32_t from_column() const {
    return GetField<int32_t>(VT_FROM_COLUMN, 0);
  }
  int32_t to_lineno() const {
    return GetField<int32_t>(VT_TO_LINENO, 0);
  }
  int32_t to_column() const {
    return GetField<int32_t>(VT_TO_COLUMN, 0);
  }
  const flatbuffers::String *context() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTEXT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::Element>> *element() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::Element>> *>(VT_ELEMENT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::_Hunk::ModLine>> *mod() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::_Hunk::ModLine>> *>(VT_MOD);
  }
  const _fast::Slices *slice() const {
    return GetPointer<const _fast::Slices *>(VT_SLICE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FROM_LINENO) &&
           VerifyField<int32_t>(verifier, VT_FROM_COLUMN) &&
           VerifyField<int32_t>(verifier, VT_TO_LINENO) &&
           VerifyField<int32_t>(verifier, VT_TO_COLUMN) &&
           VerifyOffset(verifier, VT_CONTEXT) &&
           verifier.Verify(context()) &&
           VerifyOffset(verifier, VT_ELEMENT) &&
           verifier.Verify(element()) &&
           verifier.VerifyVectorOfTables(element()) &&
           VerifyOffset(verifier, VT_MOD) &&
           verifier.Verify(mod()) &&
           verifier.VerifyVectorOfTables(mod()) &&
           VerifyOffset(verifier, VT_SLICE) &&
           verifier.VerifyTable(slice()) &&
           verifier.EndTable();
  }
};

struct HunkBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_from_lineno(int32_t from_lineno) {
    fbb_.AddElement<int32_t>(Hunk::VT_FROM_LINENO, from_lineno, 0);
  }
  void add_from_column(int32_t from_column) {
    fbb_.AddElement<int32_t>(Hunk::VT_FROM_COLUMN, from_column, 0);
  }
  void add_to_lineno(int32_t to_lineno) {
    fbb_.AddElement<int32_t>(Hunk::VT_TO_LINENO, to_lineno, 0);
  }
  void add_to_column(int32_t to_column) {
    fbb_.AddElement<int32_t>(Hunk::VT_TO_COLUMN, to_column, 0);
  }
  void add_context(flatbuffers::Offset<flatbuffers::String> context) {
    fbb_.AddOffset(Hunk::VT_CONTEXT, context);
  }
  void add_element(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::Element>>> element) {
    fbb_.AddOffset(Hunk::VT_ELEMENT, element);
  }
  void add_mod(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::_Hunk::ModLine>>> mod) {
    fbb_.AddOffset(Hunk::VT_MOD, mod);
  }
  void add_slice(flatbuffers::Offset<_fast::Slices> slice) {
    fbb_.AddOffset(Hunk::VT_SLICE, slice);
  }
  HunkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HunkBuilder &operator=(const HunkBuilder &);
  flatbuffers::Offset<Hunk> Finish() {
    const auto end = fbb_.EndTable(start_, 8);
    auto o = flatbuffers::Offset<Hunk>(end);
    return o;
  }
};

inline flatbuffers::Offset<Hunk> CreateHunk(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t from_lineno = 0,
    int32_t from_column = 0,
    int32_t to_lineno = 0,
    int32_t to_column = 0,
    flatbuffers::Offset<flatbuffers::String> context = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::Element>>> element = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::_Hunk::ModLine>>> mod = 0,
    flatbuffers::Offset<_fast::Slices> slice = 0) {
  HunkBuilder builder_(_fbb);
  builder_.add_slice(slice);
  builder_.add_mod(mod);
  builder_.add_element(element);
  builder_.add_context(context);
  builder_.add_to_column(to_column);
  builder_.add_to_lineno(to_lineno);
  builder_.add_from_column(from_column);
  builder_.add_from_lineno(from_lineno);
  return builder_.Finish();
}

inline flatbuffers::Offset<Hunk> CreateHunkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t from_lineno = 0,
    int32_t from_column = 0,
    int32_t to_lineno = 0,
    int32_t to_column = 0,
    const char *context = nullptr,
    const std::vector<flatbuffers::Offset<_fast::Element>> *element = nullptr,
    const std::vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::_Hunk::ModLine>> *mod = nullptr,
    flatbuffers::Offset<_fast::Slices> slice = 0) {
  return _fast::_Log::_Commit::_Diff::CreateHunk(
      _fbb,
      from_lineno,
      from_column,
      to_lineno,
      to_column,
      context ? _fbb.CreateString(context) : 0,
      element ? _fbb.CreateVector<flatbuffers::Offset<_fast::Element>>(*element) : 0,
      mod ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::_Hunk::ModLine>>(*mod) : 0,
      slice);
}

namespace _Hunk {

struct ModLine FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LINE = 4,
    VT_IS_ADD = 6,
    VT_IS_DEL = 8
  };
  const flatbuffers::String *line() const {
    return GetPointer<const flatbuffers::String *>(VT_LINE);
  }
  bool is_add() const {
    return GetField<uint8_t>(VT_IS_ADD, 0) != 0;
  }
  bool is_del() const {
    return GetField<uint8_t>(VT_IS_DEL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LINE) &&
           verifier.Verify(line()) &&
           VerifyField<uint8_t>(verifier, VT_IS_ADD) &&
           VerifyField<uint8_t>(verifier, VT_IS_DEL) &&
           verifier.EndTable();
  }
};

struct ModLineBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_line(flatbuffers::Offset<flatbuffers::String> line) {
    fbb_.AddOffset(ModLine::VT_LINE, line);
  }
  void add_is_add(bool is_add) {
    fbb_.AddElement<uint8_t>(ModLine::VT_IS_ADD, static_cast<uint8_t>(is_add), 0);
  }
  void add_is_del(bool is_del) {
    fbb_.AddElement<uint8_t>(ModLine::VT_IS_DEL, static_cast<uint8_t>(is_del), 0);
  }
  ModLineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModLineBuilder &operator=(const ModLineBuilder &);
  flatbuffers::Offset<ModLine> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<ModLine>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModLine> CreateModLine(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> line = 0,
    bool is_add = false,
    bool is_del = false) {
  ModLineBuilder builder_(_fbb);
  builder_.add_line(line);
  builder_.add_is_del(is_del);
  builder_.add_is_add(is_add);
  return builder_.Finish();
}

inline flatbuffers::Offset<ModLine> CreateModLineDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *line = nullptr,
    bool is_add = false,
    bool is_del = false) {
  return _fast::_Log::_Commit::_Diff::_Hunk::CreateModLine(
      _fbb,
      line ? _fbb.CreateString(line) : 0,
      is_add,
      is_del);
}

}  // namespace _Hunk
}  // namespace _Diff
}  // namespace _Commit

struct Author FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_NAME = 6,
    VT_EMAIL = 8
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *email() const {
    return GetPointer<const flatbuffers::String *>(VT_EMAIL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_EMAIL) &&
           verifier.Verify(email()) &&
           verifier.EndTable();
  }
};

struct AuthorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Author::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Author::VT_NAME, name);
  }
  void add_email(flatbuffers::Offset<flatbuffers::String> email) {
    fbb_.AddOffset(Author::VT_EMAIL, email);
  }
  AuthorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthorBuilder &operator=(const AuthorBuilder &);
  flatbuffers::Offset<Author> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Author>(end);
    return o;
  }
};

inline flatbuffers::Offset<Author> CreateAuthor(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> email = 0) {
  AuthorBuilder builder_(_fbb);
  builder_.add_email(email);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Author> CreateAuthorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *name = nullptr,
    const char *email = nullptr) {
  return _fast::_Log::CreateAuthor(
      _fbb,
      id,
      name ? _fbb.CreateString(name) : 0,
      email ? _fbb.CreateString(email) : 0);
}

}  // namespace _Log

struct Slices FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SLICE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::Slice>> *slice() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::Slice>> *>(VT_SLICE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SLICE) &&
           verifier.Verify(slice()) &&
           verifier.VerifyVectorOfTables(slice()) &&
           verifier.EndTable();
  }
};

struct SlicesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slice(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::Slice>>> slice) {
    fbb_.AddOffset(Slices::VT_SLICE, slice);
  }
  SlicesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SlicesBuilder &operator=(const SlicesBuilder &);
  flatbuffers::Offset<Slices> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Slices>(end);
    return o;
  }
};

inline flatbuffers::Offset<Slices> CreateSlices(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::Slice>>> slice = 0) {
  SlicesBuilder builder_(_fbb);
  builder_.add_slice(slice);
  return builder_.Finish();
}

inline flatbuffers::Offset<Slices> CreateSlicesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<_fast::_Slices::Slice>> *slice = nullptr) {
  return _fast::CreateSlices(
      _fbb,
      slice ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Slices::Slice>>(*slice) : 0);
}

namespace _Slices {

struct Slice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FILE = 4,
    VT_HASH = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::SourceFile>> *file() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::SourceFile>> *>(VT_FILE);
  }
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.Verify(file()) &&
           verifier.VerifyVectorOfTables(file()) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.Verify(hash()) &&
           verifier.EndTable();
  }
};

struct SliceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::SourceFile>>> file) {
    fbb_.AddOffset(Slice::VT_FILE, file);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(Slice::VT_HASH, hash);
  }
  SliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SliceBuilder &operator=(const SliceBuilder &);
  flatbuffers::Offset<Slice> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Slice>(end);
    return o;
  }
};

inline flatbuffers::Offset<Slice> CreateSlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::SourceFile>>> file = 0,
    flatbuffers::Offset<flatbuffers::String> hash = 0) {
  SliceBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_file(file);
  return builder_.Finish();
}

inline flatbuffers::Offset<Slice> CreateSliceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<_fast::_Slices::_Slice::SourceFile>> *file = nullptr,
    const char *hash = nullptr) {
  return _fast::_Slices::CreateSlice(
      _fbb,
      file ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Slices::_Slice::SourceFile>>(*file) : 0,
      hash ? _fbb.CreateString(hash) : 0);
}

namespace _Slice {

struct SourceFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FUNCTION = 4,
    VT_NAME = 6,
    VT_TYPE = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::Function>> *function() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::Function>> *>(VT_FUNCTION);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FUNCTION) &&
           verifier.Verify(function()) &&
           verifier.VerifyVectorOfTables(function()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct SourceFileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_function(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::Function>>> function) {
    fbb_.AddOffset(SourceFile::VT_FUNCTION, function);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SourceFile::VT_NAME, name);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SourceFile::VT_TYPE, type, 0);
  }
  SourceFileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SourceFileBuilder &operator=(const SourceFileBuilder &);
  flatbuffers::Offset<SourceFile> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<SourceFile>(end);
    return o;
  }
};

inline flatbuffers::Offset<SourceFile> CreateSourceFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::Function>>> function = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t type = 0) {
  SourceFileBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_function(function);
  return builder_.Finish();
}

inline flatbuffers::Offset<SourceFile> CreateSourceFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::Function>> *function = nullptr,
    const char *name = nullptr,
    int32_t type = 0) {
  return _fast::_Slices::_Slice::CreateSourceFile(
      _fbb,
      function ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::Function>>(*function) : 0,
      name ? _fbb.CreateString(name) : 0,
      type);
}

namespace _SourceFile {

struct Function FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VARIABLE = 4,
    VT_NAME = 6,
    VT_TYPE = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::Variable>> *variable() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::Variable>> *>(VT_VARIABLE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VARIABLE) &&
           verifier.Verify(variable()) &&
           verifier.VerifyVectorOfTables(variable()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct FunctionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_variable(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::Variable>>> variable) {
    fbb_.AddOffset(Function::VT_VARIABLE, variable);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Function::VT_NAME, name);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Function::VT_TYPE, type, 0);
  }
  FunctionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FunctionBuilder &operator=(const FunctionBuilder &);
  flatbuffers::Offset<Function> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Function>(end);
    return o;
  }
};

inline flatbuffers::Offset<Function> CreateFunction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::Variable>>> variable = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t type = 0) {
  FunctionBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_variable(variable);
  return builder_.Finish();
}

inline flatbuffers::Offset<Function> CreateFunctionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::Variable>> *variable = nullptr,
    const char *name = nullptr,
    int32_t type = 0) {
  return _fast::_Slices::_Slice::_SourceFile::CreateFunction(
      _fbb,
      variable ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::Variable>>(*variable) : 0,
      name ? _fbb.CreateString(name) : 0,
      type);
}

namespace _Function {

struct Variable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_POS = 6,
    VT_TYPE = 8,
    VT_DEFN = 10,
    VT_USE = 12,
    VT_DVAR = 14,
    VT_ALIAS = 16,
    VT_CFUNC = 18
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const _fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position *pos() const {
    return GetPointer<const _fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position *>(VT_POS);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>> *defn() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>> *>(VT_DEFN);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>> *use() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>> *>(VT_USE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *dvar() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DVAR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *alias() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ALIAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::FunctionDecl>> *cfunc() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::FunctionDecl>> *>(VT_CFUNC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_DEFN) &&
           verifier.Verify(defn()) &&
           verifier.VerifyVectorOfTables(defn()) &&
           VerifyOffset(verifier, VT_USE) &&
           verifier.Verify(use()) &&
           verifier.VerifyVectorOfTables(use()) &&
           VerifyOffset(verifier, VT_DVAR) &&
           verifier.Verify(dvar()) &&
           verifier.VerifyVectorOfStrings(dvar()) &&
           VerifyOffset(verifier, VT_ALIAS) &&
           verifier.Verify(alias()) &&
           verifier.VerifyVectorOfStrings(alias()) &&
           VerifyOffset(verifier, VT_CFUNC) &&
           verifier.Verify(cfunc()) &&
           verifier.VerifyVectorOfTables(cfunc()) &&
           verifier.EndTable();
  }
};

struct VariableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Variable::VT_NAME, name);
  }
  void add_pos(flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position> pos) {
    fbb_.AddOffset(Variable::VT_POS, pos);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Variable::VT_TYPE, type, 0);
  }
  void add_defn(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>>> defn) {
    fbb_.AddOffset(Variable::VT_DEFN, defn);
  }
  void add_use(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>>> use) {
    fbb_.AddOffset(Variable::VT_USE, use);
  }
  void add_dvar(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> dvar) {
    fbb_.AddOffset(Variable::VT_DVAR, dvar);
  }
  void add_alias(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> alias) {
    fbb_.AddOffset(Variable::VT_ALIAS, alias);
  }
  void add_cfunc(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::FunctionDecl>>> cfunc) {
    fbb_.AddOffset(Variable::VT_CFUNC, cfunc);
  }
  VariableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VariableBuilder &operator=(const VariableBuilder &);
  flatbuffers::Offset<Variable> Finish() {
    const auto end = fbb_.EndTable(start_, 8);
    auto o = flatbuffers::Offset<Variable>(end);
    return o;
  }
};

inline flatbuffers::Offset<Variable> CreateVariable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position> pos = 0,
    int32_t type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>>> defn = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>>> use = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> dvar = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> alias = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::FunctionDecl>>> cfunc = 0) {
  VariableBuilder builder_(_fbb);
  builder_.add_cfunc(cfunc);
  builder_.add_alias(alias);
  builder_.add_dvar(dvar);
  builder_.add_use(use);
  builder_.add_defn(defn);
  builder_.add_type(type);
  builder_.add_pos(pos);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Variable> CreateVariableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position> pos = 0,
    int32_t type = 0,
    const std::vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>> *defn = nullptr,
    const std::vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>> *use = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *dvar = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *alias = nullptr,
    const std::vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::FunctionDecl>> *cfunc = nullptr) {
  return _fast::_Slices::_Slice::_SourceFile::_Function::CreateVariable(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      pos,
      type,
      defn ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>>(*defn) : 0,
      use ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>>(*use) : 0,
      dvar ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*dvar) : 0,
      alias ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*alias) : 0,
      cfunc ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::FunctionDecl>>(*cfunc) : 0);
}

namespace _Variable {

struct Position FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LINENO = 4,
    VT_TYPE = 6,
    VT_DELTA_LINENO = 8
  };
  int32_t lineno() const {
    return GetField<int32_t>(VT_LINENO, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t delta_lineno() const {
    return GetField<int32_t>(VT_DELTA_LINENO, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LINENO) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_DELTA_LINENO) &&
           verifier.EndTable();
  }
};

struct PositionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lineno(int32_t lineno) {
    fbb_.AddElement<int32_t>(Position::VT_LINENO, lineno, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Position::VT_TYPE, type, 0);
  }
  void add_delta_lineno(int32_t delta_lineno) {
    fbb_.AddElement<int32_t>(Position::VT_DELTA_LINENO, delta_lineno, 0);
  }
  PositionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PositionBuilder &operator=(const PositionBuilder &);
  flatbuffers::Offset<Position> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Position>(end);
    return o;
  }
};

inline flatbuffers::Offset<Position> CreatePosition(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t lineno = 0,
    int32_t type = 0,
    int32_t delta_lineno = 0) {
  PositionBuilder builder_(_fbb);
  builder_.add_delta_lineno(delta_lineno);
  builder_.add_type(type);
  builder_.add_lineno(lineno);
  return builder_.Finish();
}

struct FunctionDecl FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_LINENO = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t lineno() const {
    return GetField<int32_t>(VT_LINENO, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_LINENO) &&
           verifier.EndTable();
  }
};

struct FunctionDeclBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FunctionDecl::VT_NAME, name);
  }
  void add_lineno(int32_t lineno) {
    fbb_.AddElement<int32_t>(FunctionDecl::VT_LINENO, lineno, 0);
  }
  FunctionDeclBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FunctionDeclBuilder &operator=(const FunctionDeclBuilder &);
  flatbuffers::Offset<FunctionDecl> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<FunctionDecl>(end);
    return o;
  }
};

inline flatbuffers::Offset<FunctionDecl> CreateFunctionDecl(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t lineno = 0) {
  FunctionDeclBuilder builder_(_fbb);
  builder_.add_lineno(lineno);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<FunctionDecl> CreateFunctionDeclDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t lineno = 0) {
  return _fast::_Slices::_Slice::_SourceFile::_Function::_Variable::CreateFunctionDecl(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      lineno);
}

}  // namespace _Variable
}  // namespace _Function
}  // namespace _SourceFile
}  // namespace _Slice
}  // namespace _Slices

struct Data FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECORDTYPE = 4
  };
  const _fast::_Data::Anonymous4 *RecordType() const {
    return GetPointer<const _fast::_Data::Anonymous4 *>(VT_RECORDTYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDTYPE) &&
           verifier.VerifyTable(RecordType()) &&
           verifier.EndTable();
  }
};

struct DataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_RecordType(flatbuffers::Offset<_fast::_Data::Anonymous4> RecordType) {
    fbb_.AddOffset(Data::VT_RECORDTYPE, RecordType);
  }
  DataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataBuilder &operator=(const DataBuilder &);
  flatbuffers::Offset<Data> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Data>(end);
    return o;
  }
};

inline flatbuffers::Offset<Data> CreateData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<_fast::_Data::Anonymous4> RecordType = 0) {
  DataBuilder builder_(_fbb);
  builder_.add_RecordType(RecordType);
  return builder_.Finish();
}

namespace _Data {

struct Anonymous4 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ELEMENT = 4,
    VT_LOG = 6,
    VT_DELTA = 8,
    VT_PAIRS = 10,
    VT_SLICES = 12
  };
  const _fast::Element *element() const {
    return GetPointer<const _fast::Element *>(VT_ELEMENT);
  }
  const _fast::Log *log() const {
    return GetPointer<const _fast::Log *>(VT_LOG);
  }
  const _fast::Delta *delta() const {
    return GetPointer<const _fast::Delta *>(VT_DELTA);
  }
  const _fast::Pairs *pairs() const {
    return GetPointer<const _fast::Pairs *>(VT_PAIRS);
  }
  const _fast::Slices *slices() const {
    return GetPointer<const _fast::Slices *>(VT_SLICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ELEMENT) &&
           verifier.VerifyTable(element()) &&
           VerifyOffset(verifier, VT_LOG) &&
           verifier.VerifyTable(log()) &&
           VerifyOffset(verifier, VT_DELTA) &&
           verifier.VerifyTable(delta()) &&
           VerifyOffset(verifier, VT_PAIRS) &&
           verifier.VerifyTable(pairs()) &&
           VerifyOffset(verifier, VT_SLICES) &&
           verifier.VerifyTable(slices()) &&
           verifier.EndTable();
  }
};

struct Anonymous4Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_element(flatbuffers::Offset<_fast::Element> element) {
    fbb_.AddOffset(Anonymous4::VT_ELEMENT, element);
  }
  void add_log(flatbuffers::Offset<_fast::Log> log) {
    fbb_.AddOffset(Anonymous4::VT_LOG, log);
  }
  void add_delta(flatbuffers::Offset<_fast::Delta> delta) {
    fbb_.AddOffset(Anonymous4::VT_DELTA, delta);
  }
  void add_pairs(flatbuffers::Offset<_fast::Pairs> pairs) {
    fbb_.AddOffset(Anonymous4::VT_PAIRS, pairs);
  }
  void add_slices(flatbuffers::Offset<_fast::Slices> slices) {
    fbb_.AddOffset(Anonymous4::VT_SLICES, slices);
  }
  Anonymous4Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Anonymous4Builder &operator=(const Anonymous4Builder &);
  flatbuffers::Offset<Anonymous4> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<Anonymous4>(end);
    return o;
  }
};

inline flatbuffers::Offset<Anonymous4> CreateAnonymous4(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<_fast::Element> element = 0,
    flatbuffers::Offset<_fast::Log> log = 0,
    flatbuffers::Offset<_fast::Delta> delta = 0,
    flatbuffers::Offset<_fast::Pairs> pairs = 0,
    flatbuffers::Offset<_fast::Slices> slices = 0) {
  Anonymous4Builder builder_(_fbb);
  builder_.add_slices(slices);
  builder_.add_pairs(pairs);
  builder_.add_delta(delta);
  builder_.add_log(log);
  builder_.add_element(element);
  return builder_.Finish();
}

}  // namespace _Data

namespace _Element {

}  // namespace _Element

namespace _Delta {

namespace _Diff {

}  // namespace _Diff
}  // namespace _Delta

namespace _Pairs {

namespace _Pair {

}  // namespace _Pair
}  // namespace _Pairs

namespace _Log {

namespace _Commit {

namespace _Diff {

namespace _Hunk {

}  // namespace _Hunk
}  // namespace _Diff
}  // namespace _Commit

}  // namespace _Log

namespace _Slices {

namespace _Slice {

namespace _SourceFile {

namespace _Function {

namespace _Variable {

}  // namespace _Variable
}  // namespace _Function
}  // namespace _SourceFile
}  // namespace _Slice
}  // namespace _Slices

namespace _Data {

}  // namespace _Data
}  // namespace _fast

#endif  // FLATBUFFERS_GENERATED_FAST__FAST__DATA_H_
