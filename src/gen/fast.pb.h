// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fast.proto

#ifndef PROTOBUF_fast_2eproto__INCLUDED
#define PROTOBUF_fast_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace fast {
class Data;
class DataDefaultTypeInternal;
extern DataDefaultTypeInternal _Data_default_instance_;
class Delta;
class DeltaDefaultTypeInternal;
extern DeltaDefaultTypeInternal _Delta_default_instance_;
class Delta_Diff;
class Delta_DiffDefaultTypeInternal;
extern Delta_DiffDefaultTypeInternal _Delta_Diff_default_instance_;
class Delta_Diff_Add;
class Delta_Diff_AddDefaultTypeInternal;
extern Delta_Diff_AddDefaultTypeInternal _Delta_Diff_Add_default_instance_;
class Delta_Diff_Del;
class Delta_Diff_DelDefaultTypeInternal;
extern Delta_Diff_DelDefaultTypeInternal _Delta_Diff_Del_default_instance_;
class Delta_Diff_Match;
class Delta_Diff_MatchDefaultTypeInternal;
extern Delta_Diff_MatchDefaultTypeInternal _Delta_Diff_Match_default_instance_;
class Delta_Diff_Move;
class Delta_Diff_MoveDefaultTypeInternal;
extern Delta_Diff_MoveDefaultTypeInternal _Delta_Diff_Move_default_instance_;
class Delta_Diff_Update;
class Delta_Diff_UpdateDefaultTypeInternal;
extern Delta_Diff_UpdateDefaultTypeInternal _Delta_Diff_Update_default_instance_;
class Element;
class ElementDefaultTypeInternal;
extern ElementDefaultTypeInternal _Element_default_instance_;
class Element_Literal;
class Element_LiteralDefaultTypeInternal;
extern Element_LiteralDefaultTypeInternal _Element_Literal_default_instance_;
class Element_Unit;
class Element_UnitDefaultTypeInternal;
extern Element_UnitDefaultTypeInternal _Element_Unit_default_instance_;
class Log;
class LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class Log_Author;
class Log_AuthorDefaultTypeInternal;
extern Log_AuthorDefaultTypeInternal _Log_Author_default_instance_;
class Log_Commit;
class Log_CommitDefaultTypeInternal;
extern Log_CommitDefaultTypeInternal _Log_Commit_default_instance_;
class Log_Commit_Committer;
class Log_Commit_CommitterDefaultTypeInternal;
extern Log_Commit_CommitterDefaultTypeInternal _Log_Commit_Committer_default_instance_;
class Log_Commit_Diff;
class Log_Commit_DiffDefaultTypeInternal;
extern Log_Commit_DiffDefaultTypeInternal _Log_Commit_Diff_default_instance_;
class Log_Commit_Diff_Hunk;
class Log_Commit_Diff_HunkDefaultTypeInternal;
extern Log_Commit_Diff_HunkDefaultTypeInternal _Log_Commit_Diff_Hunk_default_instance_;
class Log_Commit_Diff_Hunk_ModLine;
class Log_Commit_Diff_Hunk_ModLineDefaultTypeInternal;
extern Log_Commit_Diff_Hunk_ModLineDefaultTypeInternal _Log_Commit_Diff_Hunk_ModLine_default_instance_;
class Pairs;
class PairsDefaultTypeInternal;
extern PairsDefaultTypeInternal _Pairs_default_instance_;
class Pairs_Pair;
class Pairs_PairDefaultTypeInternal;
extern Pairs_PairDefaultTypeInternal _Pairs_Pair_default_instance_;
class Pairs_Pair_Diff;
class Pairs_Pair_DiffDefaultTypeInternal;
extern Pairs_Pair_DiffDefaultTypeInternal _Pairs_Pair_Diff_default_instance_;
class Slices;
class SlicesDefaultTypeInternal;
extern SlicesDefaultTypeInternal _Slices_default_instance_;
class Slices_Slice;
class Slices_SliceDefaultTypeInternal;
extern Slices_SliceDefaultTypeInternal _Slices_Slice_default_instance_;
class Slices_Slice_SourceFile;
class Slices_Slice_SourceFileDefaultTypeInternal;
extern Slices_Slice_SourceFileDefaultTypeInternal _Slices_Slice_SourceFile_default_instance_;
class Slices_Slice_SourceFile_Function;
class Slices_Slice_SourceFile_FunctionDefaultTypeInternal;
extern Slices_Slice_SourceFile_FunctionDefaultTypeInternal _Slices_Slice_SourceFile_Function_default_instance_;
class Slices_Slice_SourceFile_Function_Variable;
class Slices_Slice_SourceFile_Function_VariableDefaultTypeInternal;
extern Slices_Slice_SourceFile_Function_VariableDefaultTypeInternal _Slices_Slice_SourceFile_Function_Variable_default_instance_;
class Slices_Slice_SourceFile_Function_Variable_FunctionDecl;
class Slices_Slice_SourceFile_Function_Variable_FunctionDeclDefaultTypeInternal;
extern Slices_Slice_SourceFile_Function_Variable_FunctionDeclDefaultTypeInternal _Slices_Slice_SourceFile_Function_Variable_FunctionDecl_default_instance_;
class Slices_Slice_SourceFile_Function_Variable_Position;
class Slices_Slice_SourceFile_Function_Variable_PositionDefaultTypeInternal;
extern Slices_Slice_SourceFile_Function_Variable_PositionDefaultTypeInternal _Slices_Slice_SourceFile_Function_Variable_Position_default_instance_;
}  // namespace fast

namespace fast {

namespace protobuf_fast_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_fast_2eproto

enum Element_Unit_LanguageType {
  Element_Unit_LanguageType_ALL = 0,
  Element_Unit_LanguageType_OO = 1,
  Element_Unit_LanguageType_CXX = 2,
  Element_Unit_LanguageType_C = 3,
  Element_Unit_LanguageType_C_FAMILY = 4,
  Element_Unit_LanguageType_JAVA = 5,
  Element_Unit_LanguageType_CSHARP = 6,
  Element_Unit_LanguageType_OBJECTIVE_C = 7,
  Element_Unit_LanguageType_Element_Unit_LanguageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Element_Unit_LanguageType_Element_Unit_LanguageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Element_Unit_LanguageType_IsValid(int value);
const Element_Unit_LanguageType Element_Unit_LanguageType_LanguageType_MIN = Element_Unit_LanguageType_ALL;
const Element_Unit_LanguageType Element_Unit_LanguageType_LanguageType_MAX = Element_Unit_LanguageType_OBJECTIVE_C;
const int Element_Unit_LanguageType_LanguageType_ARRAYSIZE = Element_Unit_LanguageType_LanguageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Element_Unit_LanguageType_descriptor();
inline const ::std::string& Element_Unit_LanguageType_Name(Element_Unit_LanguageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Element_Unit_LanguageType_descriptor(), value);
}
inline bool Element_Unit_LanguageType_Parse(
    const ::std::string& name, Element_Unit_LanguageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Element_Unit_LanguageType>(
    Element_Unit_LanguageType_descriptor(), name, value);
}
enum Element_Literal_LiteralType {
  Element_Literal_LiteralType_number_type = 0,
  Element_Literal_LiteralType_char_type = 1,
  Element_Literal_LiteralType_string_type = 2,
  Element_Literal_LiteralType_boolean_type = 3,
  Element_Literal_LiteralType_null_type = 4,
  Element_Literal_LiteralType_Element_Literal_LiteralType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Element_Literal_LiteralType_Element_Literal_LiteralType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Element_Literal_LiteralType_IsValid(int value);
const Element_Literal_LiteralType Element_Literal_LiteralType_LiteralType_MIN = Element_Literal_LiteralType_number_type;
const Element_Literal_LiteralType Element_Literal_LiteralType_LiteralType_MAX = Element_Literal_LiteralType_null_type;
const int Element_Literal_LiteralType_LiteralType_ARRAYSIZE = Element_Literal_LiteralType_LiteralType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Element_Literal_LiteralType_descriptor();
inline const ::std::string& Element_Literal_LiteralType_Name(Element_Literal_LiteralType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Element_Literal_LiteralType_descriptor(), value);
}
inline bool Element_Literal_LiteralType_Parse(
    const ::std::string& name, Element_Literal_LiteralType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Element_Literal_LiteralType>(
    Element_Literal_LiteralType_descriptor(), name, value);
}
enum Element_Kind {
  Element_Kind_UNIT_KIND = 0,
  Element_Kind_DECL = 1,
  Element_Kind_DECL_STMT = 2,
  Element_Kind_INIT = 3,
  Element_Kind_EXPR = 4,
  Element_Kind_EXPR_STMT = 5,
  Element_Kind_COMMENT = 6,
  Element_Kind_CALL = 7,
  Element_Kind_CONTROL = 8,
  Element_Kind_INCR = 9,
  Element_Kind_NONE = 10,
  Element_Kind_VARIABLE = 11,
  Element_Kind_FUNCTION = 12,
  Element_Kind_FUNCTION_DECL = 13,
  Element_Kind_CONSTRUCTOR = 14,
  Element_Kind_CONSTRUCTOR_DECL = 15,
  Element_Kind_DESTRUCTOR = 16,
  Element_Kind_DESTRUCTOR_DECL = 17,
  Element_Kind_MACRO = 18,
  Element_Kind_SINGLE_MACRO = 19,
  Element_Kind_NULLOPERATOR = 20,
  Element_Kind_ENUM_DEFN = 21,
  Element_Kind_ENUM_DECL = 22,
  Element_Kind_GLOBAL_ATTRIBUTE = 23,
  Element_Kind_PROPERTY_ACCESSOR = 24,
  Element_Kind_PROPERTY_ACCESSOR_DECL = 25,
  Element_Kind_EXPRESSION = 26,
  Element_Kind_CLASS_DEFN = 27,
  Element_Kind_CLASS_DECL = 28,
  Element_Kind_UNION_DEFN = 29,
  Element_Kind_UNION_DECL = 30,
  Element_Kind_STRUCT_DEFN = 31,
  Element_Kind_STRUCT_DECL = 32,
  Element_Kind_INTERFACE_DEFN = 33,
  Element_Kind_INTERFACE_DECL = 34,
  Element_Kind_ACCESS_REGION = 35,
  Element_Kind_USING = 36,
  Element_Kind_OPERATOR_FUNCTION = 37,
  Element_Kind_OPERATOR_FUNCTION_DECL = 38,
  Element_Kind_EVENT = 39,
  Element_Kind_PROPERTY = 40,
  Element_Kind_ANNOTATION_DEFN = 41,
  Element_Kind_GLOBAL_TEMPLATE = 42,
  Element_Kind_UNIT = 43,
  Element_Kind_TART_ELEMENT_TOKEN = 44,
  Element_Kind_NOP = 45,
  Element_Kind_STRING = 46,
  Element_Kind_CHAR = 47,
  Element_Kind_LITERAL = 48,
  Element_Kind_BOOLEAN = 49,
  Element_Kind_NULL_ = 50,
  Element_Kind_COMPLEX = 51,
  Element_Kind_OPERATOR = 52,
  Element_Kind_MODIFIER = 53,
  Element_Kind_NAME = 54,
  Element_Kind_ONAME = 55,
  Element_Kind_CNAME = 56,
  Element_Kind_TYPE = 57,
  Element_Kind_TYPEPREV = 58,
  Element_Kind_CONDITION = 59,
  Element_Kind_BLOCK = 60,
  Element_Kind_PSEUDO_BLOCK = 61,
  Element_Kind_INDEX = 62,
  Element_Kind_ENUM = 63,
  Element_Kind_ENUM_DECLARATION = 64,
  Element_Kind_IF_STATEMENT = 65,
  Element_Kind_TERNARY = 66,
  Element_Kind_THEN = 67,
  Element_Kind_ELSE = 68,
  Element_Kind_ELSEIF = 69,
  Element_Kind_WHILE_STATEMENT = 70,
  Element_Kind_DO_STATEMENT = 71,
  Element_Kind_FOR_STATEMENT = 72,
  Element_Kind_FOREACH_STATEMENT = 73,
  Element_Kind_FOR_CONTROL = 74,
  Element_Kind_FOR_INITIALIZATION = 75,
  Element_Kind_FOR_CONDITION = 76,
  Element_Kind_FOR_INCREMENT = 77,
  Element_Kind_FOR_LIKE_CONTROL = 78,
  Element_Kind_EXPRESSION_STATEMENT = 79,
  Element_Kind_FUNCTION_CALL = 81,
  Element_Kind_DECLARATION_STATEMENT = 82,
  Element_Kind_DECLARATION = 83,
  Element_Kind_DECLARATION_INITIALIZATION = 84,
  Element_Kind_DECLARATION_RANGE = 85,
  Element_Kind_RANGE = 86,
  Element_Kind_GOTO_STATEMENT = 87,
  Element_Kind_CONTINUE_STATEMENT = 88,
  Element_Kind_BREAK_STATEMENT = 89,
  Element_Kind_LABEL_STATEMENT = 90,
  Element_Kind_LABEL = 91,
  Element_Kind_SWITCH = 92,
  Element_Kind_CASE = 93,
  Element_Kind_DEFAULT = 94,
  Element_Kind_FUNCTION_DEFINITION = 95,
  Element_Kind_FUNCTION_DECLARATION = 96,
  Element_Kind_LAMBDA = 97,
  Element_Kind_FUNCTION_LAMBDA = 98,
  Element_Kind_FUNCTION_SPECIFIER = 99,
  Element_Kind_RETURN_STATEMENT = 100,
  Element_Kind_PARAMETER_LIST = 101,
  Element_Kind_PARAMETER = 102,
  Element_Kind_KRPARAMETER_LIST = 103,
  Element_Kind_KRPARAMETER = 104,
  Element_Kind_ARGUMENT_LIST = 105,
  Element_Kind_ARGUMENT = 106,
  Element_Kind_PSEUDO_PARAMETER_LIST = 107,
  Element_Kind_INDEXER_PARAMETER_LIST = 108,
  Element_Kind_CLASS = 109,
  Element_Kind_CLASS_DECLARATION = 110,
  Element_Kind_STRUCT = 111,
  Element_Kind_STRUCT_DECLARATION = 112,
  Element_Kind_UNION = 113,
  Element_Kind_UNION_DECLARATION = 114,
  Element_Kind_DERIVATION_LIST = 115,
  Element_Kind_PUBLIC_ACCESS = 116,
  Element_Kind_PUBLIC_ACCESS_DEFAULT = 117,
  Element_Kind_PRIVATE_ACCESS = 118,
  Element_Kind_PRIVATE_ACCESS_DEFAULT = 119,
  Element_Kind_PROTECTED_ACCESS = 120,
  Element_Kind_PROTECTED_ACCESS_DEFAULT = 121,
  Element_Kind_MEMBER_INIT_LIST = 122,
  Element_Kind_MEMBER_INITIALIZATION_LIST = 123,
  Element_Kind_MEMBER_INITIALIZATION = 124,
  Element_Kind_CONSTRUCTOR_DEFINITION = 125,
  Element_Kind_CONSTRUCTOR_DECLARATION = 126,
  Element_Kind_DESTRUCTOR_DEFINITION = 127,
  Element_Kind_DESTRUCTOR_DECLARATION = 128,
  Element_Kind_FRIEND = 129,
  Element_Kind_CLASS_SPECIFIER = 130,
  Element_Kind_TRY_BLOCK = 131,
  Element_Kind_CATCH_BLOCK = 132,
  Element_Kind_FINALLY_BLOCK = 133,
  Element_Kind_THROW_STATEMENT = 134,
  Element_Kind_THROW_SPECIFIER = 135,
  Element_Kind_THROW_SPECIFIER_JAVA = 136,
  Element_Kind_TEMPLATE = 137,
  Element_Kind_GENERIC_ARGUMENT = 138,
  Element_Kind_GENERIC_ARGUMENT_LIST = 139,
  Element_Kind_TEMPLATE_PARAMETER = 140,
  Element_Kind_TEMPLATE_PARAMETER_LIST = 141,
  Element_Kind_GENERIC_PARAMETER = 142,
  Element_Kind_GENERIC_PARAMETER_LIST = 143,
  Element_Kind_TYPEDEF = 144,
  Element_Kind_ASM = 145,
  Element_Kind_MACRO_CALL = 146,
  Element_Kind_SIZEOF_CALL = 147,
  Element_Kind_EXTERN = 148,
  Element_Kind_NAMESPACE = 149,
  Element_Kind_USING_DIRECTIVE = 150,
  Element_Kind_DIRECTIVE = 151,
  Element_Kind_ATOMIC = 152,
  Element_Kind_STATIC_ASSERT_STATEMENT = 153,
  Element_Kind_GENERIC_SELECTION = 154,
  Element_Kind_GENERIC_SELECTOR = 155,
  Element_Kind_GENERIC_ASSOCIATION_LIST = 156,
  Element_Kind_GENERIC_ASSOCIATION = 157,
  Element_Kind_ALIGNAS = 158,
  Element_Kind_DECLTYPE = 159,
  Element_Kind_CAPTURE = 160,
  Element_Kind_LAMBDA_CAPTURE = 161,
  Element_Kind_NOEXCEPT = 162,
  Element_Kind_TYPENAME = 163,
  Element_Kind_ALIGNOF = 164,
  Element_Kind_TYPEID = 165,
  Element_Kind_SIZEOF_PACK = 166,
  Element_Kind_ENUM_CLASS = 167,
  Element_Kind_ENUM_CLASS_DECLARATION = 168,
  Element_Kind_REF_QUALIFIER = 171,
  Element_Kind_SIGNAL_ACCESS = 172,
  Element_Kind_FOREVER_STATEMENT = 173,
  Element_Kind_EMIT_STATEMENT = 174,
  Element_Kind_CPP_DIRECTIVE = 175,
  Element_Kind_CPP_FILENAME = 176,
  Element_Kind_FILE = 177,
  Element_Kind_NUMBER = 178,
  Element_Kind_CPP_NUMBER = 179,
  Element_Kind_CPP_LITERAL = 180,
  Element_Kind_CPP_MACRO_DEFN = 181,
  Element_Kind_CPP_MACRO_VALUE = 182,
  Element_Kind_ERROR = 183,
  Element_Kind_CPP_ERROR = 184,
  Element_Kind_CPP_WARNING = 185,
  Element_Kind_CPP_PRAGMA = 186,
  Element_Kind_CPP_INCLUDE = 187,
  Element_Kind_CPP_DEFINE = 188,
  Element_Kind_CPP_UNDEF = 189,
  Element_Kind_CPP_LINE = 190,
  Element_Kind_CPP_IF = 191,
  Element_Kind_CPP_IFDEF = 192,
  Element_Kind_CPP_IFNDEF = 193,
  Element_Kind_CPP_THEN = 194,
  Element_Kind_CPP_ELSE = 195,
  Element_Kind_CPP_ELIF = 196,
  Element_Kind_CPP_EMPTY = 197,
  Element_Kind_CPP_REGION = 198,
  Element_Kind_CPP_ENDREGION = 199,
  Element_Kind_USING_STMT = 200,
  Element_Kind_ESCAPE = 201,
  Element_Kind_VALUE = 202,
  Element_Kind_CPP_IMPORT = 203,
  Element_Kind_CPP_ENDIF = 204,
  Element_Kind_MARKER = 205,
  Element_Kind_ERROR_PARSE = 206,
  Element_Kind_ERROR_MODE = 207,
  Element_Kind_IMPLEMENTS = 208,
  Element_Kind_EXTENDS = 209,
  Element_Kind_IMPORT = 210,
  Element_Kind_PACKAGE = 211,
  Element_Kind_ASSERT_STATEMENT = 212,
  Element_Kind_INTERFACE = 213,
  Element_Kind_INTERFACE_DECLARATION = 214,
  Element_Kind_SYNCHRONIZED_STATEMENT = 215,
  Element_Kind_ANNOTATION = 216,
  Element_Kind_STATIC_BLOCK = 218,
  Element_Kind_CHECKED_STATEMENT = 219,
  Element_Kind_UNCHECKED_STATEMENT = 220,
  Element_Kind_ATTRIBUTE = 221,
  Element_Kind_TARGET = 222,
  Element_Kind_UNSAFE_STATEMENT = 223,
  Element_Kind_LOCK_STATEMENT = 224,
  Element_Kind_FIXED_STATEMENT = 225,
  Element_Kind_TYPEOF = 226,
  Element_Kind_USING_STATEMENT = 227,
  Element_Kind_FUNCTION_DELEGATE = 228,
  Element_Kind_CONSTRAINT = 230,
  Element_Kind_LINQ = 231,
  Element_Kind_FROM = 232,
  Element_Kind_WHERE = 233,
  Element_Kind_SELECT = 234,
  Element_Kind_LET = 235,
  Element_Kind_ORDERBY = 236,
  Element_Kind_JOIN = 237,
  Element_Kind_GROUP = 238,
  Element_Kind_IN = 239,
  Element_Kind_ON = 240,
  Element_Kind_EQUALS = 241,
  Element_Kind_BY = 242,
  Element_Kind_INTO = 243,
  Element_Kind_EMPTY = 244,
  Element_Kind_EMPTY_STMT = 245,
  Element_Kind_RECEIVER = 246,
  Element_Kind_MESSAGE = 247,
  Element_Kind_SELECTOR = 248,
  Element_Kind_PROTOCOL_LIST = 249,
  Element_Kind_CATEGORY = 250,
  Element_Kind_PROTOCOL = 251,
  Element_Kind_REQUIRED_DEFAULT = 252,
  Element_Kind_REQUIRED = 253,
  Element_Kind_OPTIONAL = 254,
  Element_Kind_ATTRIBUTE_LIST = 256,
  Element_Kind_SYNTHESIZE = 257,
  Element_Kind_DYNAMIC = 258,
  Element_Kind_ENCODE = 259,
  Element_Kind_AUTORELEASEPOOL = 260,
  Element_Kind_COMPATIBILITY_ALIAS = 261,
  Element_Kind_NIL = 262,
  Element_Kind_CLASS_INTERFACE = 263,
  Element_Kind_CLASS_IMPLEMENTATION = 264,
  Element_Kind_PROTOCOL_DECLARATION = 265,
  Element_Kind_CAST = 266,
  Element_Kind_CONST_CAST = 267,
  Element_Kind_DYNAMIC_CAST = 268,
  Element_Kind_REINTERPRET_CAST = 269,
  Element_Kind_STATIC_CAST = 270,
  Element_Kind_POSITION = 271,
  Element_Kind_CUDA_ARGUMENT_LIST = 272,
  Element_Kind_OMP_DIRECTIVE = 273,
  Element_Kind_OMP_NAME = 274,
  Element_Kind_OMP_CLAUSE = 275,
  Element_Kind_OMP_ARGUMENT_LIST = 276,
  Element_Kind_OMP_ARGUMENT = 277,
  Element_Kind_OMP_EXPRESSION = 278,
  Element_Kind_END_ELEMENT_TOKEN = 279,
  Element_Kind_MAIN = 280,
  Element_Kind_BREAK = 281,
  Element_Kind_CONTINUE = 282,
  Element_Kind_WHILE = 283,
  Element_Kind_DO = 284,
  Element_Kind_FOR = 285,
  Element_Kind_IF = 286,
  Element_Kind_GOTO = 293,
  Element_Kind_VISUAL_CXX_ASM = 295,
  Element_Kind_SIZEOF = 296,
  Element_Kind_AUTO = 298,
  Element_Kind_REGISTER = 299,
  Element_Kind_RESTRICT = 300,
  Element_Kind_IMAGINARY = 304,
  Element_Kind_NORETURN = 305,
  Element_Kind_STATIC_ASSERT = 306,
  Element_Kind_CRESTRICT = 307,
  Element_Kind_CXX_TRY = 308,
  Element_Kind_CXX_CATCH = 309,
  Element_Kind_CXX_CLASS = 310,
  Element_Kind_CONSTEXPR = 311,
  Element_Kind_THREAD_LOCAL = 313,
  Element_Kind_NULLPTR = 314,
  Element_Kind_VOID = 326,
  Element_Kind_RETURN = 327,
  Element_Kind_INCLUDE = 328,
  Element_Kind_DEFINE = 329,
  Element_Kind_ELIF = 330,
  Element_Kind_ENDIF = 331,
  Element_Kind_ERRORPREC = 332,
  Element_Kind_WARNING = 333,
  Element_Kind_IFDEF = 334,
  Element_Kind_IFNDEF = 335,
  Element_Kind_LINE = 336,
  Element_Kind_PRAGMA = 337,
  Element_Kind_UNDEF = 338,
  Element_Kind_INLINE = 339,
  Element_Kind_MACRO_TYPE_NAME = 340,
  Element_Kind_MACRO_CASE = 341,
  Element_Kind_MACRO_LABEL = 342,
  Element_Kind_SPECIFIER = 344,
  Element_Kind_TRY = 345,
  Element_Kind_CATCH = 346,
  Element_Kind_THROW = 347,
  Element_Kind_THROWS = 348,
  Element_Kind_PUBLIC = 350,
  Element_Kind_PRIVATE = 351,
  Element_Kind_PROTECTED = 352,
  Element_Kind_VIRTUAL = 353,
  Element_Kind_EXPLICIT = 356,
  Element_Kind_FOREVER = 357,
  Element_Kind_SIGNAL = 358,
  Element_Kind_EMIT = 359,
  Element_Kind_NEW = 363,
  Element_Kind_DELETE = 364,
  Element_Kind_STATIC = 365,
  Element_Kind_CONST = 366,
  Element_Kind_MUTABLE = 367,
  Element_Kind_VOLATILE = 368,
  Element_Kind_TRANSIENT = 369,
  Element_Kind_FINALLY = 372,
  Element_Kind_FINAL = 376,
  Element_Kind_ABSTRACT = 377,
  Element_Kind_SUPER = 378,
  Element_Kind_SYNCHRONIZED = 379,
  Element_Kind_NATIVE = 380,
  Element_Kind_STRICTFP = 381,
  Element_Kind_NULLLITERAL = 382,
  Element_Kind_ASSERT = 383,
  Element_Kind_FOREACH = 384,
  Element_Kind_REF = 385,
  Element_Kind_OUT = 386,
  Element_Kind_LOCK = 388,
  Element_Kind_IS = 389,
  Element_Kind_INTERNAL = 390,
  Element_Kind_SEALED = 391,
  Element_Kind_OVERRIDE = 392,
  Element_Kind_IMPLICIT = 393,
  Element_Kind_STACKALLOC = 394,
  Element_Kind_AS = 395,
  Element_Kind_DELEGATE = 396,
  Element_Kind_FIXED = 397,
  Element_Kind_CHECKED = 398,
  Element_Kind_UNCHECKED = 399,
  Element_Kind_REGION = 400,
  Element_Kind_ENDREGION = 401,
  Element_Kind_UNSAFE = 402,
  Element_Kind_READONLY = 403,
  Element_Kind_GET = 404,
  Element_Kind_SET = 405,
  Element_Kind_ADD = 406,
  Element_Kind_REMOVE = 407,
  Element_Kind_YIELD = 408,
  Element_Kind_PARTIAL = 409,
  Element_Kind_AWAIT = 410,
  Element_Kind_ASYNC = 412,
  Element_Kind_THIS = 413,
  Element_Kind_PARAMS = 414,
  Element_Kind_ALIAS = 416,
  Element_Kind_ASCENDING = 422,
  Element_Kind_DESCENDING = 423,
  Element_Kind_ATINTERFACE = 430,
  Element_Kind_ATIMPLEMENTATION = 431,
  Element_Kind_ATEND = 432,
  Element_Kind_ATPROTOCOL = 433,
  Element_Kind_ATREQUIRED = 434,
  Element_Kind_ATOPTIONAL = 435,
  Element_Kind_ATCLASS = 441,
  Element_Kind_WEAK = 443,
  Element_Kind_STRONG = 444,
  Element_Kind_OMP_OMP = 448,
  Element_Kind_SPECIAL_CHARS = 449,
  Element_Kind_Element_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Element_Kind_Element_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Element_Kind_IsValid(int value);
const Element_Kind Element_Kind_Kind_MIN = Element_Kind_UNIT_KIND;
const Element_Kind Element_Kind_Kind_MAX = Element_Kind_SPECIAL_CHARS;
const int Element_Kind_Kind_ARRAYSIZE = Element_Kind_Kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Element_Kind_descriptor();
inline const ::std::string& Element_Kind_Name(Element_Kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Element_Kind_descriptor(), value);
}
inline bool Element_Kind_Parse(
    const ::std::string& name, Element_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Element_Kind>(
    Element_Kind_descriptor(), name, value);
}
enum Delta_Diff_DeltaType {
  Delta_Diff_DeltaType_MATCH = 0,
  Delta_Diff_DeltaType_ADD = 1,
  Delta_Diff_DeltaType_DEL = 2,
  Delta_Diff_DeltaType_MOVE = 3,
  Delta_Diff_DeltaType_UPDATE = 4,
  Delta_Diff_DeltaType_Delta_Diff_DeltaType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Delta_Diff_DeltaType_Delta_Diff_DeltaType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Delta_Diff_DeltaType_IsValid(int value);
const Delta_Diff_DeltaType Delta_Diff_DeltaType_DeltaType_MIN = Delta_Diff_DeltaType_MATCH;
const Delta_Diff_DeltaType Delta_Diff_DeltaType_DeltaType_MAX = Delta_Diff_DeltaType_UPDATE;
const int Delta_Diff_DeltaType_DeltaType_ARRAYSIZE = Delta_Diff_DeltaType_DeltaType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Delta_Diff_DeltaType_descriptor();
inline const ::std::string& Delta_Diff_DeltaType_Name(Delta_Diff_DeltaType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Delta_Diff_DeltaType_descriptor(), value);
}
inline bool Delta_Diff_DeltaType_Parse(
    const ::std::string& name, Delta_Diff_DeltaType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Delta_Diff_DeltaType>(
    Delta_Diff_DeltaType_descriptor(), name, value);
}
enum Pairs_Pair_CloneType {
  Pairs_Pair_CloneType_MAYBE = 0,
  Pairs_Pair_CloneType_YES = 1,
  Pairs_Pair_CloneType_NO = 2,
  Pairs_Pair_CloneType_Pairs_Pair_CloneType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Pairs_Pair_CloneType_Pairs_Pair_CloneType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Pairs_Pair_CloneType_IsValid(int value);
const Pairs_Pair_CloneType Pairs_Pair_CloneType_CloneType_MIN = Pairs_Pair_CloneType_MAYBE;
const Pairs_Pair_CloneType Pairs_Pair_CloneType_CloneType_MAX = Pairs_Pair_CloneType_NO;
const int Pairs_Pair_CloneType_CloneType_ARRAYSIZE = Pairs_Pair_CloneType_CloneType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Pairs_Pair_CloneType_descriptor();
inline const ::std::string& Pairs_Pair_CloneType_Name(Pairs_Pair_CloneType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Pairs_Pair_CloneType_descriptor(), value);
}
inline bool Pairs_Pair_CloneType_Parse(
    const ::std::string& name, Pairs_Pair_CloneType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Pairs_Pair_CloneType>(
    Pairs_Pair_CloneType_descriptor(), name, value);
}
enum Slices_Slice_ChangeType {
  Slices_Slice_ChangeType_UNCHANGED = 0,
  Slices_Slice_ChangeType_ADD = 1,
  Slices_Slice_ChangeType_DEL = 2,
  Slices_Slice_ChangeType_Slices_Slice_ChangeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Slices_Slice_ChangeType_Slices_Slice_ChangeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Slices_Slice_ChangeType_IsValid(int value);
const Slices_Slice_ChangeType Slices_Slice_ChangeType_ChangeType_MIN = Slices_Slice_ChangeType_UNCHANGED;
const Slices_Slice_ChangeType Slices_Slice_ChangeType_ChangeType_MAX = Slices_Slice_ChangeType_DEL;
const int Slices_Slice_ChangeType_ChangeType_ARRAYSIZE = Slices_Slice_ChangeType_ChangeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Slices_Slice_ChangeType_descriptor();
inline const ::std::string& Slices_Slice_ChangeType_Name(Slices_Slice_ChangeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Slices_Slice_ChangeType_descriptor(), value);
}
inline bool Slices_Slice_ChangeType_Parse(
    const ::std::string& name, Slices_Slice_ChangeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Slices_Slice_ChangeType>(
    Slices_Slice_ChangeType_descriptor(), name, value);
}
enum SmaliKind {
  smali_file = 0,
  class_spec = 1,
  super_spec = 2,
  implements_spec = 3,
  source_spec = 4,
  access_list = 5,
  field = 6,
  method = 7,
  statements_and_directives = 8,
  ordered_method_item = 9,
  registers_directive = 10,
  param_list_or_id = 11,
  simple_name = 12,
  member_name = 13,
  method_prototype = 14,
  param_list_or_id_primitive_type = 15,
  param_list = 16,
  array_descriptor = 17,
  type_descriptor = 18,
  nonvoid_type_descriptor = 19,
  reference_type_descriptor = 20,
  integer_literal = 21,
  float_literal = 22,
  double_literal = 23,
  literal = 24,
  parsed_integer_literal = 25,
  integral_literal = 26,
  fixed_32bit_literal = 27,
  fixed_literal = 28,
  array_literal = 29,
  annotation_element = 30,
  annotation = 31,
  subannotation = 32,
  enum_literal = 33,
  type_field_method_literal = 34,
  method_reference = 35,
  field_reference = 36,
  label = 37,
  label_ref = 38,
  register_list = 39,
  register_range = 40,
  verification_error_reference = 41,
  catch_directive = 42,
  catchall_directive = 43,
  parameter_directive = 44,
  debug_directive = 45,
  line_directive = 46,
  local_directive = 47,
  end_local_directive = 48,
  restart_local_directive = 49,
  prologue_directive = 50,
  epilogue_directive = 51,
  source_directive = 52,
  instruction_format12x = 53,
  instruction_format22s = 54,
  instruction_format31i = 55,
  instruction = 56,
  insn_format10t = 57,
  insn_format10x = 58,
  insn_format10x_odex = 59,
  insn_format11n = 60,
  insn_format11x = 61,
  insn_format12x = 62,
  insn_format20bc = 63,
  insn_format20t = 64,
  insn_format21c_field = 65,
  insn_format21c_field_odex = 66,
  insn_format21c_string = 67,
  insn_format21c_type = 68,
  insn_format21ih = 69,
  insn_format21lh = 70,
  insn_format21s = 71,
  insn_format21t = 72,
  insn_format22b = 73,
  insn_format22c_field = 74,
  insn_format22c_field_odex = 75,
  insn_format22c_type = 76,
  insn_format22cs_field = 77,
  insn_format22s = 78,
  insn_format22t = 79,
  insn_format22x = 80,
  insn_format23x = 81,
  insn_format30t = 82,
  insn_format31c = 83,
  insn_format31i = 84,
  insn_format31t = 85,
  insn_format32x = 86,
  insn_format35c_method = 87,
  insn_format35c_type = 88,
  insn_format35c_method_odex = 89,
  insn_format35mi_method = 90,
  insn_format35ms_method = 91,
  insn_format3rc_method = 92,
  insn_format3rc_method_odex = 93,
  insn_format3rc_type = 94,
  insn_format3rmi_method = 95,
  insn_format3rms_method = 96,
  insn_format45cc_method = 97,
  insn_format4rcc_method = 98,
  insn_format51l = 99,
  insn_array_data_directive = 100,
  insn_packed_switch_directive = 101,
  insn_sparse_switch_directive = 102,
  SmaliKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SmaliKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SmaliKind_IsValid(int value);
const SmaliKind SmaliKind_MIN = smali_file;
const SmaliKind SmaliKind_MAX = insn_sparse_switch_directive;
const int SmaliKind_ARRAYSIZE = SmaliKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* SmaliKind_descriptor();
inline const ::std::string& SmaliKind_Name(SmaliKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    SmaliKind_descriptor(), value);
}
inline bool SmaliKind_Parse(
    const ::std::string& name, SmaliKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SmaliKind>(
    SmaliKind_descriptor(), name, value);
}
// ===================================================================

class Element_Unit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Element.Unit) */ {
 public:
  Element_Unit();
  virtual ~Element_Unit();

  Element_Unit(const Element_Unit& from);

  inline Element_Unit& operator=(const Element_Unit& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Element_Unit& default_instance();

  static inline const Element_Unit* internal_default_instance() {
    return reinterpret_cast<const Element_Unit*>(
               &_Element_Unit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Element_Unit* other);

  // implements Message ----------------------------------------------

  inline Element_Unit* New() const PROTOBUF_FINAL { return New(NULL); }

  Element_Unit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Element_Unit& from);
  void MergeFrom(const Element_Unit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Element_Unit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Element_Unit_LanguageType LanguageType;
  static const LanguageType ALL =
    Element_Unit_LanguageType_ALL;
  static const LanguageType OO =
    Element_Unit_LanguageType_OO;
  static const LanguageType CXX =
    Element_Unit_LanguageType_CXX;
  static const LanguageType C =
    Element_Unit_LanguageType_C;
  static const LanguageType C_FAMILY =
    Element_Unit_LanguageType_C_FAMILY;
  static const LanguageType JAVA =
    Element_Unit_LanguageType_JAVA;
  static const LanguageType CSHARP =
    Element_Unit_LanguageType_CSHARP;
  static const LanguageType OBJECTIVE_C =
    Element_Unit_LanguageType_OBJECTIVE_C;
  static inline bool LanguageType_IsValid(int value) {
    return Element_Unit_LanguageType_IsValid(value);
  }
  static const LanguageType LanguageType_MIN =
    Element_Unit_LanguageType_LanguageType_MIN;
  static const LanguageType LanguageType_MAX =
    Element_Unit_LanguageType_LanguageType_MAX;
  static const int LanguageType_ARRAYSIZE =
    Element_Unit_LanguageType_LanguageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LanguageType_descriptor() {
    return Element_Unit_LanguageType_descriptor();
  }
  static inline const ::std::string& LanguageType_Name(LanguageType value) {
    return Element_Unit_LanguageType_Name(value);
  }
  static inline bool LanguageType_Parse(const ::std::string& name,
      LanguageType* value) {
    return Element_Unit_LanguageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string filename = 1;
  void clear_filename();
  static const int kFilenameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // string revision = 2;
  void clear_revision();
  static const int kRevisionFieldNumber = 2;
  const ::std::string& revision() const;
  void set_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_revision(::std::string&& value);
  #endif
  void set_revision(const char* value);
  void set_revision(const char* value, size_t size);
  ::std::string* mutable_revision();
  ::std::string* release_revision();
  void set_allocated_revision(::std::string* revision);

  // .fast.Element.Unit.LanguageType language = 3;
  void clear_language();
  static const int kLanguageFieldNumber = 3;
  ::fast::Element_Unit_LanguageType language() const;
  void set_language(::fast::Element_Unit_LanguageType value);

  // int32 item = 4;
  void clear_item();
  static const int kItemFieldNumber = 4;
  ::google::protobuf::int32 item() const;
  void set_item(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fast.Element.Unit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::google::protobuf::internal::ArenaStringPtr revision_;
  int language_;
  ::google::protobuf::int32 item_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Element_Literal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Element.Literal) */ {
 public:
  Element_Literal();
  virtual ~Element_Literal();

  Element_Literal(const Element_Literal& from);

  inline Element_Literal& operator=(const Element_Literal& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Element_Literal& default_instance();

  static inline const Element_Literal* internal_default_instance() {
    return reinterpret_cast<const Element_Literal*>(
               &_Element_Literal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Element_Literal* other);

  // implements Message ----------------------------------------------

  inline Element_Literal* New() const PROTOBUF_FINAL { return New(NULL); }

  Element_Literal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Element_Literal& from);
  void MergeFrom(const Element_Literal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Element_Literal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Element_Literal_LiteralType LiteralType;
  static const LiteralType number_type =
    Element_Literal_LiteralType_number_type;
  static const LiteralType char_type =
    Element_Literal_LiteralType_char_type;
  static const LiteralType string_type =
    Element_Literal_LiteralType_string_type;
  static const LiteralType boolean_type =
    Element_Literal_LiteralType_boolean_type;
  static const LiteralType null_type =
    Element_Literal_LiteralType_null_type;
  static inline bool LiteralType_IsValid(int value) {
    return Element_Literal_LiteralType_IsValid(value);
  }
  static const LiteralType LiteralType_MIN =
    Element_Literal_LiteralType_LiteralType_MIN;
  static const LiteralType LiteralType_MAX =
    Element_Literal_LiteralType_LiteralType_MAX;
  static const int LiteralType_ARRAYSIZE =
    Element_Literal_LiteralType_LiteralType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LiteralType_descriptor() {
    return Element_Literal_LiteralType_descriptor();
  }
  static inline const ::std::string& LiteralType_Name(LiteralType value) {
    return Element_Literal_LiteralType_Name(value);
  }
  static inline bool LiteralType_Parse(const ::std::string& name,
      LiteralType* value) {
    return Element_Literal_LiteralType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .fast.Element.Literal.LiteralType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::fast::Element_Literal_LiteralType type() const;
  void set_type(::fast::Element_Literal_LiteralType value);

  // @@protoc_insertion_point(class_scope:fast.Element.Literal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Element : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Element) */ {
 public:
  Element();
  virtual ~Element();

  Element(const Element& from);

  inline Element& operator=(const Element& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Element& default_instance();

  enum TypeCase {
    kKind = 1,
    kSmaliKind = 2,
    TYPE_NOT_SET = 0,
  };

  enum ExtraCase {
    kUnit = 8,
    kLiteral = 9,
    EXTRA_NOT_SET = 0,
  };

  static inline const Element* internal_default_instance() {
    return reinterpret_cast<const Element*>(
               &_Element_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Element* other);

  // implements Message ----------------------------------------------

  inline Element* New() const PROTOBUF_FINAL { return New(NULL); }

  Element* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Element& from);
  void MergeFrom(const Element& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Element* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Element_Unit Unit;
  typedef Element_Literal Literal;

  typedef Element_Kind Kind;
  static const Kind UNIT_KIND =
    Element_Kind_UNIT_KIND;
  static const Kind DECL =
    Element_Kind_DECL;
  static const Kind DECL_STMT =
    Element_Kind_DECL_STMT;
  static const Kind INIT =
    Element_Kind_INIT;
  static const Kind EXPR =
    Element_Kind_EXPR;
  static const Kind EXPR_STMT =
    Element_Kind_EXPR_STMT;
  static const Kind COMMENT =
    Element_Kind_COMMENT;
  static const Kind CALL =
    Element_Kind_CALL;
  static const Kind CONTROL =
    Element_Kind_CONTROL;
  static const Kind INCR =
    Element_Kind_INCR;
  static const Kind NONE =
    Element_Kind_NONE;
  static const Kind VARIABLE =
    Element_Kind_VARIABLE;
  static const Kind FUNCTION =
    Element_Kind_FUNCTION;
  static const Kind FUNCTION_DECL =
    Element_Kind_FUNCTION_DECL;
  static const Kind CONSTRUCTOR =
    Element_Kind_CONSTRUCTOR;
  static const Kind CONSTRUCTOR_DECL =
    Element_Kind_CONSTRUCTOR_DECL;
  static const Kind DESTRUCTOR =
    Element_Kind_DESTRUCTOR;
  static const Kind DESTRUCTOR_DECL =
    Element_Kind_DESTRUCTOR_DECL;
  static const Kind MACRO =
    Element_Kind_MACRO;
  static const Kind SINGLE_MACRO =
    Element_Kind_SINGLE_MACRO;
  static const Kind NULLOPERATOR =
    Element_Kind_NULLOPERATOR;
  static const Kind ENUM_DEFN =
    Element_Kind_ENUM_DEFN;
  static const Kind ENUM_DECL =
    Element_Kind_ENUM_DECL;
  static const Kind GLOBAL_ATTRIBUTE =
    Element_Kind_GLOBAL_ATTRIBUTE;
  static const Kind PROPERTY_ACCESSOR =
    Element_Kind_PROPERTY_ACCESSOR;
  static const Kind PROPERTY_ACCESSOR_DECL =
    Element_Kind_PROPERTY_ACCESSOR_DECL;
  static const Kind EXPRESSION =
    Element_Kind_EXPRESSION;
  static const Kind CLASS_DEFN =
    Element_Kind_CLASS_DEFN;
  static const Kind CLASS_DECL =
    Element_Kind_CLASS_DECL;
  static const Kind UNION_DEFN =
    Element_Kind_UNION_DEFN;
  static const Kind UNION_DECL =
    Element_Kind_UNION_DECL;
  static const Kind STRUCT_DEFN =
    Element_Kind_STRUCT_DEFN;
  static const Kind STRUCT_DECL =
    Element_Kind_STRUCT_DECL;
  static const Kind INTERFACE_DEFN =
    Element_Kind_INTERFACE_DEFN;
  static const Kind INTERFACE_DECL =
    Element_Kind_INTERFACE_DECL;
  static const Kind ACCESS_REGION =
    Element_Kind_ACCESS_REGION;
  static const Kind USING =
    Element_Kind_USING;
  static const Kind OPERATOR_FUNCTION =
    Element_Kind_OPERATOR_FUNCTION;
  static const Kind OPERATOR_FUNCTION_DECL =
    Element_Kind_OPERATOR_FUNCTION_DECL;
  static const Kind EVENT =
    Element_Kind_EVENT;
  static const Kind PROPERTY =
    Element_Kind_PROPERTY;
  static const Kind ANNOTATION_DEFN =
    Element_Kind_ANNOTATION_DEFN;
  static const Kind GLOBAL_TEMPLATE =
    Element_Kind_GLOBAL_TEMPLATE;
  static const Kind UNIT =
    Element_Kind_UNIT;
  static const Kind TART_ELEMENT_TOKEN =
    Element_Kind_TART_ELEMENT_TOKEN;
  static const Kind NOP =
    Element_Kind_NOP;
  static const Kind STRING =
    Element_Kind_STRING;
  static const Kind CHAR =
    Element_Kind_CHAR;
  static const Kind LITERAL =
    Element_Kind_LITERAL;
  static const Kind BOOLEAN =
    Element_Kind_BOOLEAN;
  static const Kind NULL_ =
    Element_Kind_NULL_;
  static const Kind COMPLEX =
    Element_Kind_COMPLEX;
  static const Kind OPERATOR =
    Element_Kind_OPERATOR;
  static const Kind MODIFIER =
    Element_Kind_MODIFIER;
  static const Kind NAME =
    Element_Kind_NAME;
  static const Kind ONAME =
    Element_Kind_ONAME;
  static const Kind CNAME =
    Element_Kind_CNAME;
  static const Kind TYPE =
    Element_Kind_TYPE;
  static const Kind TYPEPREV =
    Element_Kind_TYPEPREV;
  static const Kind CONDITION =
    Element_Kind_CONDITION;
  static const Kind BLOCK =
    Element_Kind_BLOCK;
  static const Kind PSEUDO_BLOCK =
    Element_Kind_PSEUDO_BLOCK;
  static const Kind INDEX =
    Element_Kind_INDEX;
  static const Kind ENUM =
    Element_Kind_ENUM;
  static const Kind ENUM_DECLARATION =
    Element_Kind_ENUM_DECLARATION;
  static const Kind IF_STATEMENT =
    Element_Kind_IF_STATEMENT;
  static const Kind TERNARY =
    Element_Kind_TERNARY;
  static const Kind THEN =
    Element_Kind_THEN;
  static const Kind ELSE =
    Element_Kind_ELSE;
  static const Kind ELSEIF =
    Element_Kind_ELSEIF;
  static const Kind WHILE_STATEMENT =
    Element_Kind_WHILE_STATEMENT;
  static const Kind DO_STATEMENT =
    Element_Kind_DO_STATEMENT;
  static const Kind FOR_STATEMENT =
    Element_Kind_FOR_STATEMENT;
  static const Kind FOREACH_STATEMENT =
    Element_Kind_FOREACH_STATEMENT;
  static const Kind FOR_CONTROL =
    Element_Kind_FOR_CONTROL;
  static const Kind FOR_INITIALIZATION =
    Element_Kind_FOR_INITIALIZATION;
  static const Kind FOR_CONDITION =
    Element_Kind_FOR_CONDITION;
  static const Kind FOR_INCREMENT =
    Element_Kind_FOR_INCREMENT;
  static const Kind FOR_LIKE_CONTROL =
    Element_Kind_FOR_LIKE_CONTROL;
  static const Kind EXPRESSION_STATEMENT =
    Element_Kind_EXPRESSION_STATEMENT;
  static const Kind FUNCTION_CALL =
    Element_Kind_FUNCTION_CALL;
  static const Kind DECLARATION_STATEMENT =
    Element_Kind_DECLARATION_STATEMENT;
  static const Kind DECLARATION =
    Element_Kind_DECLARATION;
  static const Kind DECLARATION_INITIALIZATION =
    Element_Kind_DECLARATION_INITIALIZATION;
  static const Kind DECLARATION_RANGE =
    Element_Kind_DECLARATION_RANGE;
  static const Kind RANGE =
    Element_Kind_RANGE;
  static const Kind GOTO_STATEMENT =
    Element_Kind_GOTO_STATEMENT;
  static const Kind CONTINUE_STATEMENT =
    Element_Kind_CONTINUE_STATEMENT;
  static const Kind BREAK_STATEMENT =
    Element_Kind_BREAK_STATEMENT;
  static const Kind LABEL_STATEMENT =
    Element_Kind_LABEL_STATEMENT;
  static const Kind LABEL =
    Element_Kind_LABEL;
  static const Kind SWITCH =
    Element_Kind_SWITCH;
  static const Kind CASE =
    Element_Kind_CASE;
  static const Kind DEFAULT =
    Element_Kind_DEFAULT;
  static const Kind FUNCTION_DEFINITION =
    Element_Kind_FUNCTION_DEFINITION;
  static const Kind FUNCTION_DECLARATION =
    Element_Kind_FUNCTION_DECLARATION;
  static const Kind LAMBDA =
    Element_Kind_LAMBDA;
  static const Kind FUNCTION_LAMBDA =
    Element_Kind_FUNCTION_LAMBDA;
  static const Kind FUNCTION_SPECIFIER =
    Element_Kind_FUNCTION_SPECIFIER;
  static const Kind RETURN_STATEMENT =
    Element_Kind_RETURN_STATEMENT;
  static const Kind PARAMETER_LIST =
    Element_Kind_PARAMETER_LIST;
  static const Kind PARAMETER =
    Element_Kind_PARAMETER;
  static const Kind KRPARAMETER_LIST =
    Element_Kind_KRPARAMETER_LIST;
  static const Kind KRPARAMETER =
    Element_Kind_KRPARAMETER;
  static const Kind ARGUMENT_LIST =
    Element_Kind_ARGUMENT_LIST;
  static const Kind ARGUMENT =
    Element_Kind_ARGUMENT;
  static const Kind PSEUDO_PARAMETER_LIST =
    Element_Kind_PSEUDO_PARAMETER_LIST;
  static const Kind INDEXER_PARAMETER_LIST =
    Element_Kind_INDEXER_PARAMETER_LIST;
  static const Kind CLASS =
    Element_Kind_CLASS;
  static const Kind CLASS_DECLARATION =
    Element_Kind_CLASS_DECLARATION;
  static const Kind STRUCT =
    Element_Kind_STRUCT;
  static const Kind STRUCT_DECLARATION =
    Element_Kind_STRUCT_DECLARATION;
  static const Kind UNION =
    Element_Kind_UNION;
  static const Kind UNION_DECLARATION =
    Element_Kind_UNION_DECLARATION;
  static const Kind DERIVATION_LIST =
    Element_Kind_DERIVATION_LIST;
  static const Kind PUBLIC_ACCESS =
    Element_Kind_PUBLIC_ACCESS;
  static const Kind PUBLIC_ACCESS_DEFAULT =
    Element_Kind_PUBLIC_ACCESS_DEFAULT;
  static const Kind PRIVATE_ACCESS =
    Element_Kind_PRIVATE_ACCESS;
  static const Kind PRIVATE_ACCESS_DEFAULT =
    Element_Kind_PRIVATE_ACCESS_DEFAULT;
  static const Kind PROTECTED_ACCESS =
    Element_Kind_PROTECTED_ACCESS;
  static const Kind PROTECTED_ACCESS_DEFAULT =
    Element_Kind_PROTECTED_ACCESS_DEFAULT;
  static const Kind MEMBER_INIT_LIST =
    Element_Kind_MEMBER_INIT_LIST;
  static const Kind MEMBER_INITIALIZATION_LIST =
    Element_Kind_MEMBER_INITIALIZATION_LIST;
  static const Kind MEMBER_INITIALIZATION =
    Element_Kind_MEMBER_INITIALIZATION;
  static const Kind CONSTRUCTOR_DEFINITION =
    Element_Kind_CONSTRUCTOR_DEFINITION;
  static const Kind CONSTRUCTOR_DECLARATION =
    Element_Kind_CONSTRUCTOR_DECLARATION;
  static const Kind DESTRUCTOR_DEFINITION =
    Element_Kind_DESTRUCTOR_DEFINITION;
  static const Kind DESTRUCTOR_DECLARATION =
    Element_Kind_DESTRUCTOR_DECLARATION;
  static const Kind FRIEND =
    Element_Kind_FRIEND;
  static const Kind CLASS_SPECIFIER =
    Element_Kind_CLASS_SPECIFIER;
  static const Kind TRY_BLOCK =
    Element_Kind_TRY_BLOCK;
  static const Kind CATCH_BLOCK =
    Element_Kind_CATCH_BLOCK;
  static const Kind FINALLY_BLOCK =
    Element_Kind_FINALLY_BLOCK;
  static const Kind THROW_STATEMENT =
    Element_Kind_THROW_STATEMENT;
  static const Kind THROW_SPECIFIER =
    Element_Kind_THROW_SPECIFIER;
  static const Kind THROW_SPECIFIER_JAVA =
    Element_Kind_THROW_SPECIFIER_JAVA;
  static const Kind TEMPLATE =
    Element_Kind_TEMPLATE;
  static const Kind GENERIC_ARGUMENT =
    Element_Kind_GENERIC_ARGUMENT;
  static const Kind GENERIC_ARGUMENT_LIST =
    Element_Kind_GENERIC_ARGUMENT_LIST;
  static const Kind TEMPLATE_PARAMETER =
    Element_Kind_TEMPLATE_PARAMETER;
  static const Kind TEMPLATE_PARAMETER_LIST =
    Element_Kind_TEMPLATE_PARAMETER_LIST;
  static const Kind GENERIC_PARAMETER =
    Element_Kind_GENERIC_PARAMETER;
  static const Kind GENERIC_PARAMETER_LIST =
    Element_Kind_GENERIC_PARAMETER_LIST;
  static const Kind TYPEDEF =
    Element_Kind_TYPEDEF;
  static const Kind ASM =
    Element_Kind_ASM;
  static const Kind MACRO_CALL =
    Element_Kind_MACRO_CALL;
  static const Kind SIZEOF_CALL =
    Element_Kind_SIZEOF_CALL;
  static const Kind EXTERN =
    Element_Kind_EXTERN;
  static const Kind NAMESPACE =
    Element_Kind_NAMESPACE;
  static const Kind USING_DIRECTIVE =
    Element_Kind_USING_DIRECTIVE;
  static const Kind DIRECTIVE =
    Element_Kind_DIRECTIVE;
  static const Kind ATOMIC =
    Element_Kind_ATOMIC;
  static const Kind STATIC_ASSERT_STATEMENT =
    Element_Kind_STATIC_ASSERT_STATEMENT;
  static const Kind GENERIC_SELECTION =
    Element_Kind_GENERIC_SELECTION;
  static const Kind GENERIC_SELECTOR =
    Element_Kind_GENERIC_SELECTOR;
  static const Kind GENERIC_ASSOCIATION_LIST =
    Element_Kind_GENERIC_ASSOCIATION_LIST;
  static const Kind GENERIC_ASSOCIATION =
    Element_Kind_GENERIC_ASSOCIATION;
  static const Kind ALIGNAS =
    Element_Kind_ALIGNAS;
  static const Kind DECLTYPE =
    Element_Kind_DECLTYPE;
  static const Kind CAPTURE =
    Element_Kind_CAPTURE;
  static const Kind LAMBDA_CAPTURE =
    Element_Kind_LAMBDA_CAPTURE;
  static const Kind NOEXCEPT =
    Element_Kind_NOEXCEPT;
  static const Kind TYPENAME =
    Element_Kind_TYPENAME;
  static const Kind ALIGNOF =
    Element_Kind_ALIGNOF;
  static const Kind TYPEID =
    Element_Kind_TYPEID;
  static const Kind SIZEOF_PACK =
    Element_Kind_SIZEOF_PACK;
  static const Kind ENUM_CLASS =
    Element_Kind_ENUM_CLASS;
  static const Kind ENUM_CLASS_DECLARATION =
    Element_Kind_ENUM_CLASS_DECLARATION;
  static const Kind REF_QUALIFIER =
    Element_Kind_REF_QUALIFIER;
  static const Kind SIGNAL_ACCESS =
    Element_Kind_SIGNAL_ACCESS;
  static const Kind FOREVER_STATEMENT =
    Element_Kind_FOREVER_STATEMENT;
  static const Kind EMIT_STATEMENT =
    Element_Kind_EMIT_STATEMENT;
  static const Kind CPP_DIRECTIVE =
    Element_Kind_CPP_DIRECTIVE;
  static const Kind CPP_FILENAME =
    Element_Kind_CPP_FILENAME;
  static const Kind FILE =
    Element_Kind_FILE;
  static const Kind NUMBER =
    Element_Kind_NUMBER;
  static const Kind CPP_NUMBER =
    Element_Kind_CPP_NUMBER;
  static const Kind CPP_LITERAL =
    Element_Kind_CPP_LITERAL;
  static const Kind CPP_MACRO_DEFN =
    Element_Kind_CPP_MACRO_DEFN;
  static const Kind CPP_MACRO_VALUE =
    Element_Kind_CPP_MACRO_VALUE;
  static const Kind ERROR =
    Element_Kind_ERROR;
  static const Kind CPP_ERROR =
    Element_Kind_CPP_ERROR;
  static const Kind CPP_WARNING =
    Element_Kind_CPP_WARNING;
  static const Kind CPP_PRAGMA =
    Element_Kind_CPP_PRAGMA;
  static const Kind CPP_INCLUDE =
    Element_Kind_CPP_INCLUDE;
  static const Kind CPP_DEFINE =
    Element_Kind_CPP_DEFINE;
  static const Kind CPP_UNDEF =
    Element_Kind_CPP_UNDEF;
  static const Kind CPP_LINE =
    Element_Kind_CPP_LINE;
  static const Kind CPP_IF =
    Element_Kind_CPP_IF;
  static const Kind CPP_IFDEF =
    Element_Kind_CPP_IFDEF;
  static const Kind CPP_IFNDEF =
    Element_Kind_CPP_IFNDEF;
  static const Kind CPP_THEN =
    Element_Kind_CPP_THEN;
  static const Kind CPP_ELSE =
    Element_Kind_CPP_ELSE;
  static const Kind CPP_ELIF =
    Element_Kind_CPP_ELIF;
  static const Kind CPP_EMPTY =
    Element_Kind_CPP_EMPTY;
  static const Kind CPP_REGION =
    Element_Kind_CPP_REGION;
  static const Kind CPP_ENDREGION =
    Element_Kind_CPP_ENDREGION;
  static const Kind USING_STMT =
    Element_Kind_USING_STMT;
  static const Kind ESCAPE =
    Element_Kind_ESCAPE;
  static const Kind VALUE =
    Element_Kind_VALUE;
  static const Kind CPP_IMPORT =
    Element_Kind_CPP_IMPORT;
  static const Kind CPP_ENDIF =
    Element_Kind_CPP_ENDIF;
  static const Kind MARKER =
    Element_Kind_MARKER;
  static const Kind ERROR_PARSE =
    Element_Kind_ERROR_PARSE;
  static const Kind ERROR_MODE =
    Element_Kind_ERROR_MODE;
  static const Kind IMPLEMENTS =
    Element_Kind_IMPLEMENTS;
  static const Kind EXTENDS =
    Element_Kind_EXTENDS;
  static const Kind IMPORT =
    Element_Kind_IMPORT;
  static const Kind PACKAGE =
    Element_Kind_PACKAGE;
  static const Kind ASSERT_STATEMENT =
    Element_Kind_ASSERT_STATEMENT;
  static const Kind INTERFACE =
    Element_Kind_INTERFACE;
  static const Kind INTERFACE_DECLARATION =
    Element_Kind_INTERFACE_DECLARATION;
  static const Kind SYNCHRONIZED_STATEMENT =
    Element_Kind_SYNCHRONIZED_STATEMENT;
  static const Kind ANNOTATION =
    Element_Kind_ANNOTATION;
  static const Kind STATIC_BLOCK =
    Element_Kind_STATIC_BLOCK;
  static const Kind CHECKED_STATEMENT =
    Element_Kind_CHECKED_STATEMENT;
  static const Kind UNCHECKED_STATEMENT =
    Element_Kind_UNCHECKED_STATEMENT;
  static const Kind ATTRIBUTE =
    Element_Kind_ATTRIBUTE;
  static const Kind TARGET =
    Element_Kind_TARGET;
  static const Kind UNSAFE_STATEMENT =
    Element_Kind_UNSAFE_STATEMENT;
  static const Kind LOCK_STATEMENT =
    Element_Kind_LOCK_STATEMENT;
  static const Kind FIXED_STATEMENT =
    Element_Kind_FIXED_STATEMENT;
  static const Kind TYPEOF =
    Element_Kind_TYPEOF;
  static const Kind USING_STATEMENT =
    Element_Kind_USING_STATEMENT;
  static const Kind FUNCTION_DELEGATE =
    Element_Kind_FUNCTION_DELEGATE;
  static const Kind CONSTRAINT =
    Element_Kind_CONSTRAINT;
  static const Kind LINQ =
    Element_Kind_LINQ;
  static const Kind FROM =
    Element_Kind_FROM;
  static const Kind WHERE =
    Element_Kind_WHERE;
  static const Kind SELECT =
    Element_Kind_SELECT;
  static const Kind LET =
    Element_Kind_LET;
  static const Kind ORDERBY =
    Element_Kind_ORDERBY;
  static const Kind JOIN =
    Element_Kind_JOIN;
  static const Kind GROUP =
    Element_Kind_GROUP;
  static const Kind IN =
    Element_Kind_IN;
  static const Kind ON =
    Element_Kind_ON;
  static const Kind EQUALS =
    Element_Kind_EQUALS;
  static const Kind BY =
    Element_Kind_BY;
  static const Kind INTO =
    Element_Kind_INTO;
  static const Kind EMPTY =
    Element_Kind_EMPTY;
  static const Kind EMPTY_STMT =
    Element_Kind_EMPTY_STMT;
  static const Kind RECEIVER =
    Element_Kind_RECEIVER;
  static const Kind MESSAGE =
    Element_Kind_MESSAGE;
  static const Kind SELECTOR =
    Element_Kind_SELECTOR;
  static const Kind PROTOCOL_LIST =
    Element_Kind_PROTOCOL_LIST;
  static const Kind CATEGORY =
    Element_Kind_CATEGORY;
  static const Kind PROTOCOL =
    Element_Kind_PROTOCOL;
  static const Kind REQUIRED_DEFAULT =
    Element_Kind_REQUIRED_DEFAULT;
  static const Kind REQUIRED =
    Element_Kind_REQUIRED;
  static const Kind OPTIONAL =
    Element_Kind_OPTIONAL;
  static const Kind ATTRIBUTE_LIST =
    Element_Kind_ATTRIBUTE_LIST;
  static const Kind SYNTHESIZE =
    Element_Kind_SYNTHESIZE;
  static const Kind DYNAMIC =
    Element_Kind_DYNAMIC;
  static const Kind ENCODE =
    Element_Kind_ENCODE;
  static const Kind AUTORELEASEPOOL =
    Element_Kind_AUTORELEASEPOOL;
  static const Kind COMPATIBILITY_ALIAS =
    Element_Kind_COMPATIBILITY_ALIAS;
  static const Kind NIL =
    Element_Kind_NIL;
  static const Kind CLASS_INTERFACE =
    Element_Kind_CLASS_INTERFACE;
  static const Kind CLASS_IMPLEMENTATION =
    Element_Kind_CLASS_IMPLEMENTATION;
  static const Kind PROTOCOL_DECLARATION =
    Element_Kind_PROTOCOL_DECLARATION;
  static const Kind CAST =
    Element_Kind_CAST;
  static const Kind CONST_CAST =
    Element_Kind_CONST_CAST;
  static const Kind DYNAMIC_CAST =
    Element_Kind_DYNAMIC_CAST;
  static const Kind REINTERPRET_CAST =
    Element_Kind_REINTERPRET_CAST;
  static const Kind STATIC_CAST =
    Element_Kind_STATIC_CAST;
  static const Kind POSITION =
    Element_Kind_POSITION;
  static const Kind CUDA_ARGUMENT_LIST =
    Element_Kind_CUDA_ARGUMENT_LIST;
  static const Kind OMP_DIRECTIVE =
    Element_Kind_OMP_DIRECTIVE;
  static const Kind OMP_NAME =
    Element_Kind_OMP_NAME;
  static const Kind OMP_CLAUSE =
    Element_Kind_OMP_CLAUSE;
  static const Kind OMP_ARGUMENT_LIST =
    Element_Kind_OMP_ARGUMENT_LIST;
  static const Kind OMP_ARGUMENT =
    Element_Kind_OMP_ARGUMENT;
  static const Kind OMP_EXPRESSION =
    Element_Kind_OMP_EXPRESSION;
  static const Kind END_ELEMENT_TOKEN =
    Element_Kind_END_ELEMENT_TOKEN;
  static const Kind MAIN =
    Element_Kind_MAIN;
  static const Kind BREAK =
    Element_Kind_BREAK;
  static const Kind CONTINUE =
    Element_Kind_CONTINUE;
  static const Kind WHILE =
    Element_Kind_WHILE;
  static const Kind DO =
    Element_Kind_DO;
  static const Kind FOR =
    Element_Kind_FOR;
  static const Kind IF =
    Element_Kind_IF;
  static const Kind GOTO =
    Element_Kind_GOTO;
  static const Kind VISUAL_CXX_ASM =
    Element_Kind_VISUAL_CXX_ASM;
  static const Kind SIZEOF =
    Element_Kind_SIZEOF;
  static const Kind AUTO =
    Element_Kind_AUTO;
  static const Kind REGISTER =
    Element_Kind_REGISTER;
  static const Kind RESTRICT =
    Element_Kind_RESTRICT;
  static const Kind IMAGINARY =
    Element_Kind_IMAGINARY;
  static const Kind NORETURN =
    Element_Kind_NORETURN;
  static const Kind STATIC_ASSERT =
    Element_Kind_STATIC_ASSERT;
  static const Kind CRESTRICT =
    Element_Kind_CRESTRICT;
  static const Kind CXX_TRY =
    Element_Kind_CXX_TRY;
  static const Kind CXX_CATCH =
    Element_Kind_CXX_CATCH;
  static const Kind CXX_CLASS =
    Element_Kind_CXX_CLASS;
  static const Kind CONSTEXPR =
    Element_Kind_CONSTEXPR;
  static const Kind THREAD_LOCAL =
    Element_Kind_THREAD_LOCAL;
  static const Kind NULLPTR =
    Element_Kind_NULLPTR;
  static const Kind VOID =
    Element_Kind_VOID;
  static const Kind RETURN =
    Element_Kind_RETURN;
  static const Kind INCLUDE =
    Element_Kind_INCLUDE;
  static const Kind DEFINE =
    Element_Kind_DEFINE;
  static const Kind ELIF =
    Element_Kind_ELIF;
  static const Kind ENDIF =
    Element_Kind_ENDIF;
  static const Kind ERRORPREC =
    Element_Kind_ERRORPREC;
  static const Kind WARNING =
    Element_Kind_WARNING;
  static const Kind IFDEF =
    Element_Kind_IFDEF;
  static const Kind IFNDEF =
    Element_Kind_IFNDEF;
  static const Kind LINE =
    Element_Kind_LINE;
  static const Kind PRAGMA =
    Element_Kind_PRAGMA;
  static const Kind UNDEF =
    Element_Kind_UNDEF;
  static const Kind INLINE =
    Element_Kind_INLINE;
  static const Kind MACRO_TYPE_NAME =
    Element_Kind_MACRO_TYPE_NAME;
  static const Kind MACRO_CASE =
    Element_Kind_MACRO_CASE;
  static const Kind MACRO_LABEL =
    Element_Kind_MACRO_LABEL;
  static const Kind SPECIFIER =
    Element_Kind_SPECIFIER;
  static const Kind TRY =
    Element_Kind_TRY;
  static const Kind CATCH =
    Element_Kind_CATCH;
  static const Kind THROW =
    Element_Kind_THROW;
  static const Kind THROWS =
    Element_Kind_THROWS;
  static const Kind PUBLIC =
    Element_Kind_PUBLIC;
  static const Kind PRIVATE =
    Element_Kind_PRIVATE;
  static const Kind PROTECTED =
    Element_Kind_PROTECTED;
  static const Kind VIRTUAL =
    Element_Kind_VIRTUAL;
  static const Kind EXPLICIT =
    Element_Kind_EXPLICIT;
  static const Kind FOREVER =
    Element_Kind_FOREVER;
  static const Kind SIGNAL =
    Element_Kind_SIGNAL;
  static const Kind EMIT =
    Element_Kind_EMIT;
  static const Kind NEW =
    Element_Kind_NEW;
  static const Kind DELETE =
    Element_Kind_DELETE;
  static const Kind STATIC =
    Element_Kind_STATIC;
  static const Kind CONST =
    Element_Kind_CONST;
  static const Kind MUTABLE =
    Element_Kind_MUTABLE;
  static const Kind VOLATILE =
    Element_Kind_VOLATILE;
  static const Kind TRANSIENT =
    Element_Kind_TRANSIENT;
  static const Kind FINALLY =
    Element_Kind_FINALLY;
  static const Kind FINAL =
    Element_Kind_FINAL;
  static const Kind ABSTRACT =
    Element_Kind_ABSTRACT;
  static const Kind SUPER =
    Element_Kind_SUPER;
  static const Kind SYNCHRONIZED =
    Element_Kind_SYNCHRONIZED;
  static const Kind NATIVE =
    Element_Kind_NATIVE;
  static const Kind STRICTFP =
    Element_Kind_STRICTFP;
  static const Kind NULLLITERAL =
    Element_Kind_NULLLITERAL;
  static const Kind ASSERT =
    Element_Kind_ASSERT;
  static const Kind FOREACH =
    Element_Kind_FOREACH;
  static const Kind REF =
    Element_Kind_REF;
  static const Kind OUT =
    Element_Kind_OUT;
  static const Kind LOCK =
    Element_Kind_LOCK;
  static const Kind IS =
    Element_Kind_IS;
  static const Kind INTERNAL =
    Element_Kind_INTERNAL;
  static const Kind SEALED =
    Element_Kind_SEALED;
  static const Kind OVERRIDE =
    Element_Kind_OVERRIDE;
  static const Kind IMPLICIT =
    Element_Kind_IMPLICIT;
  static const Kind STACKALLOC =
    Element_Kind_STACKALLOC;
  static const Kind AS =
    Element_Kind_AS;
  static const Kind DELEGATE =
    Element_Kind_DELEGATE;
  static const Kind FIXED =
    Element_Kind_FIXED;
  static const Kind CHECKED =
    Element_Kind_CHECKED;
  static const Kind UNCHECKED =
    Element_Kind_UNCHECKED;
  static const Kind REGION =
    Element_Kind_REGION;
  static const Kind ENDREGION =
    Element_Kind_ENDREGION;
  static const Kind UNSAFE =
    Element_Kind_UNSAFE;
  static const Kind READONLY =
    Element_Kind_READONLY;
  static const Kind GET =
    Element_Kind_GET;
  static const Kind SET =
    Element_Kind_SET;
  static const Kind ADD =
    Element_Kind_ADD;
  static const Kind REMOVE =
    Element_Kind_REMOVE;
  static const Kind YIELD =
    Element_Kind_YIELD;
  static const Kind PARTIAL =
    Element_Kind_PARTIAL;
  static const Kind AWAIT =
    Element_Kind_AWAIT;
  static const Kind ASYNC =
    Element_Kind_ASYNC;
  static const Kind THIS =
    Element_Kind_THIS;
  static const Kind PARAMS =
    Element_Kind_PARAMS;
  static const Kind ALIAS =
    Element_Kind_ALIAS;
  static const Kind ASCENDING =
    Element_Kind_ASCENDING;
  static const Kind DESCENDING =
    Element_Kind_DESCENDING;
  static const Kind ATINTERFACE =
    Element_Kind_ATINTERFACE;
  static const Kind ATIMPLEMENTATION =
    Element_Kind_ATIMPLEMENTATION;
  static const Kind ATEND =
    Element_Kind_ATEND;
  static const Kind ATPROTOCOL =
    Element_Kind_ATPROTOCOL;
  static const Kind ATREQUIRED =
    Element_Kind_ATREQUIRED;
  static const Kind ATOPTIONAL =
    Element_Kind_ATOPTIONAL;
  static const Kind ATCLASS =
    Element_Kind_ATCLASS;
  static const Kind WEAK =
    Element_Kind_WEAK;
  static const Kind STRONG =
    Element_Kind_STRONG;
  static const Kind OMP_OMP =
    Element_Kind_OMP_OMP;
  static const Kind SPECIAL_CHARS =
    Element_Kind_SPECIAL_CHARS;
  static inline bool Kind_IsValid(int value) {
    return Element_Kind_IsValid(value);
  }
  static const Kind Kind_MIN =
    Element_Kind_Kind_MIN;
  static const Kind Kind_MAX =
    Element_Kind_Kind_MAX;
  static const int Kind_ARRAYSIZE =
    Element_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Kind_descriptor() {
    return Element_Kind_descriptor();
  }
  static inline const ::std::string& Kind_Name(Kind value) {
    return Element_Kind_Name(value);
  }
  static inline bool Kind_Parse(const ::std::string& name,
      Kind* value) {
    return Element_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .fast.Element child = 6;
  int child_size() const;
  void clear_child();
  static const int kChildFieldNumber = 6;
  const ::fast::Element& child(int index) const;
  ::fast::Element* mutable_child(int index);
  ::fast::Element* add_child();
  ::google::protobuf::RepeatedPtrField< ::fast::Element >*
      mutable_child();
  const ::google::protobuf::RepeatedPtrField< ::fast::Element >&
      child() const;

  // string text = 3;
  void clear_text();
  static const int kTextFieldNumber = 3;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // string tail = 7;
  void clear_tail();
  static const int kTailFieldNumber = 7;
  const ::std::string& tail() const;
  void set_tail(const ::std::string& value);
  #if LANG_CXX11
  void set_tail(::std::string&& value);
  #endif
  void set_tail(const char* value);
  void set_tail(const char* value, size_t size);
  ::std::string* mutable_tail();
  ::std::string* release_tail();
  void set_allocated_tail(::std::string* tail);

  // int32 pos = 4;
  void clear_pos();
  static const int kPosFieldNumber = 4;
  ::google::protobuf::int32 pos() const;
  void set_pos(::google::protobuf::int32 value);

  // int32 length = 5;
  void clear_length();
  static const int kLengthFieldNumber = 5;
  ::google::protobuf::int32 length() const;
  void set_length(::google::protobuf::int32 value);

  // int32 line = 10;
  void clear_line();
  static const int kLineFieldNumber = 10;
  ::google::protobuf::int32 line() const;
  void set_line(::google::protobuf::int32 value);

  // int32 column = 11;
  void clear_column();
  static const int kColumnFieldNumber = 11;
  ::google::protobuf::int32 column() const;
  void set_column(::google::protobuf::int32 value);

  // .fast.Element.Kind kind = 1;
  private:
  bool has_kind() const;
  public:
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::fast::Element_Kind kind() const;
  void set_kind(::fast::Element_Kind value);

  // .fast.SmaliKind smali_kind = 2;
  private:
  bool has_smali_kind() const;
  public:
  void clear_smali_kind();
  static const int kSmaliKindFieldNumber = 2;
  ::fast::SmaliKind smali_kind() const;
  void set_smali_kind(::fast::SmaliKind value);

  // .fast.Element.Unit unit = 8;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 8;
  const ::fast::Element_Unit& unit() const;
  ::fast::Element_Unit* mutable_unit();
  ::fast::Element_Unit* release_unit();
  void set_allocated_unit(::fast::Element_Unit* unit);

  // .fast.Element.Literal literal = 9;
  bool has_literal() const;
  void clear_literal();
  static const int kLiteralFieldNumber = 9;
  const ::fast::Element_Literal& literal() const;
  ::fast::Element_Literal* mutable_literal();
  ::fast::Element_Literal* release_literal();
  void set_allocated_literal(::fast::Element_Literal* literal);

  TypeCase type_case() const;
  ExtraCase extra_case() const;
  // @@protoc_insertion_point(class_scope:fast.Element)
 private:
  void set_has_kind();
  void set_has_smali_kind();
  void set_has_unit();
  void set_has_literal();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  inline bool has_extra() const;
  void clear_extra();
  inline void clear_has_extra();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fast::Element > child_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr tail_;
  ::google::protobuf::int32 pos_;
  ::google::protobuf::int32 length_;
  ::google::protobuf::int32 line_;
  ::google::protobuf::int32 column_;
  union TypeUnion {
    TypeUnion() {}
    int kind_;
    int smali_kind_;
  } type_;
  union ExtraUnion {
    ExtraUnion() {}
    ::fast::Element_Unit* unit_;
    ::fast::Element_Literal* literal_;
  } extra_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Delta_Diff_Match : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Delta.Diff.Match) */ {
 public:
  Delta_Diff_Match();
  virtual ~Delta_Diff_Match();

  Delta_Diff_Match(const Delta_Diff_Match& from);

  inline Delta_Diff_Match& operator=(const Delta_Diff_Match& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Delta_Diff_Match& default_instance();

  static inline const Delta_Diff_Match* internal_default_instance() {
    return reinterpret_cast<const Delta_Diff_Match*>(
               &_Delta_Diff_Match_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Delta_Diff_Match* other);

  // implements Message ----------------------------------------------

  inline Delta_Diff_Match* New() const PROTOBUF_FINAL { return New(NULL); }

  Delta_Diff_Match* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Delta_Diff_Match& from);
  void MergeFrom(const Delta_Diff_Match& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Delta_Diff_Match* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 src = 1;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  ::google::protobuf::int32 src() const;
  void set_src(::google::protobuf::int32 value);

  // int32 dst = 2;
  void clear_dst();
  static const int kDstFieldNumber = 2;
  ::google::protobuf::int32 dst() const;
  void set_dst(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fast.Delta.Diff.Match)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 src_;
  ::google::protobuf::int32 dst_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Delta_Diff_Add : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Delta.Diff.Add) */ {
 public:
  Delta_Diff_Add();
  virtual ~Delta_Diff_Add();

  Delta_Diff_Add(const Delta_Diff_Add& from);

  inline Delta_Diff_Add& operator=(const Delta_Diff_Add& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Delta_Diff_Add& default_instance();

  static inline const Delta_Diff_Add* internal_default_instance() {
    return reinterpret_cast<const Delta_Diff_Add*>(
               &_Delta_Diff_Add_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Delta_Diff_Add* other);

  // implements Message ----------------------------------------------

  inline Delta_Diff_Add* New() const PROTOBUF_FINAL { return New(NULL); }

  Delta_Diff_Add* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Delta_Diff_Add& from);
  void MergeFrom(const Delta_Diff_Add& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Delta_Diff_Add* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 src = 1;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  ::google::protobuf::int32 src() const;
  void set_src(::google::protobuf::int32 value);

  // int32 dst = 2;
  void clear_dst();
  static const int kDstFieldNumber = 2;
  ::google::protobuf::int32 dst() const;
  void set_dst(::google::protobuf::int32 value);

  // int32 position = 3;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  ::google::protobuf::int32 position() const;
  void set_position(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fast.Delta.Diff.Add)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 src_;
  ::google::protobuf::int32 dst_;
  ::google::protobuf::int32 position_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Delta_Diff_Del : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Delta.Diff.Del) */ {
 public:
  Delta_Diff_Del();
  virtual ~Delta_Diff_Del();

  Delta_Diff_Del(const Delta_Diff_Del& from);

  inline Delta_Diff_Del& operator=(const Delta_Diff_Del& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Delta_Diff_Del& default_instance();

  static inline const Delta_Diff_Del* internal_default_instance() {
    return reinterpret_cast<const Delta_Diff_Del*>(
               &_Delta_Diff_Del_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Delta_Diff_Del* other);

  // implements Message ----------------------------------------------

  inline Delta_Diff_Del* New() const PROTOBUF_FINAL { return New(NULL); }

  Delta_Diff_Del* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Delta_Diff_Del& from);
  void MergeFrom(const Delta_Diff_Del& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Delta_Diff_Del* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 src = 1;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  ::google::protobuf::int32 src() const;
  void set_src(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fast.Delta.Diff.Del)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 src_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Delta_Diff_Move : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Delta.Diff.Move) */ {
 public:
  Delta_Diff_Move();
  virtual ~Delta_Diff_Move();

  Delta_Diff_Move(const Delta_Diff_Move& from);

  inline Delta_Diff_Move& operator=(const Delta_Diff_Move& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Delta_Diff_Move& default_instance();

  static inline const Delta_Diff_Move* internal_default_instance() {
    return reinterpret_cast<const Delta_Diff_Move*>(
               &_Delta_Diff_Move_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Delta_Diff_Move* other);

  // implements Message ----------------------------------------------

  inline Delta_Diff_Move* New() const PROTOBUF_FINAL { return New(NULL); }

  Delta_Diff_Move* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Delta_Diff_Move& from);
  void MergeFrom(const Delta_Diff_Move& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Delta_Diff_Move* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 src = 1;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  ::google::protobuf::int32 src() const;
  void set_src(::google::protobuf::int32 value);

  // int32 dst = 2;
  void clear_dst();
  static const int kDstFieldNumber = 2;
  ::google::protobuf::int32 dst() const;
  void set_dst(::google::protobuf::int32 value);

  // int32 position = 3;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  ::google::protobuf::int32 position() const;
  void set_position(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fast.Delta.Diff.Move)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 src_;
  ::google::protobuf::int32 dst_;
  ::google::protobuf::int32 position_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Delta_Diff_Update : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Delta.Diff.Update) */ {
 public:
  Delta_Diff_Update();
  virtual ~Delta_Diff_Update();

  Delta_Diff_Update(const Delta_Diff_Update& from);

  inline Delta_Diff_Update& operator=(const Delta_Diff_Update& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Delta_Diff_Update& default_instance();

  static inline const Delta_Diff_Update* internal_default_instance() {
    return reinterpret_cast<const Delta_Diff_Update*>(
               &_Delta_Diff_Update_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Delta_Diff_Update* other);

  // implements Message ----------------------------------------------

  inline Delta_Diff_Update* New() const PROTOBUF_FINAL { return New(NULL); }

  Delta_Diff_Update* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Delta_Diff_Update& from);
  void MergeFrom(const Delta_Diff_Update& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Delta_Diff_Update* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string label = 2;
  void clear_label();
  static const int kLabelFieldNumber = 2;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // int32 src = 1;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  ::google::protobuf::int32 src() const;
  void set_src(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fast.Delta.Diff.Update)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::int32 src_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Delta_Diff : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Delta.Diff) */ {
 public:
  Delta_Diff();
  virtual ~Delta_Diff();

  Delta_Diff(const Delta_Diff& from);

  inline Delta_Diff& operator=(const Delta_Diff& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Delta_Diff& default_instance();

  enum DeltaCase {
    kMatch = 2,
    kAdd = 3,
    kDel = 4,
    kMove = 5,
    kUpdate = 6,
    DELTA_NOT_SET = 0,
  };

  static inline const Delta_Diff* internal_default_instance() {
    return reinterpret_cast<const Delta_Diff*>(
               &_Delta_Diff_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Delta_Diff* other);

  // implements Message ----------------------------------------------

  inline Delta_Diff* New() const PROTOBUF_FINAL { return New(NULL); }

  Delta_Diff* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Delta_Diff& from);
  void MergeFrom(const Delta_Diff& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Delta_Diff* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Delta_Diff_Match Match;
  typedef Delta_Diff_Add Add;
  typedef Delta_Diff_Del Del;
  typedef Delta_Diff_Move Move;
  typedef Delta_Diff_Update Update;

  typedef Delta_Diff_DeltaType DeltaType;
  static const DeltaType MATCH =
    Delta_Diff_DeltaType_MATCH;
  static const DeltaType ADD =
    Delta_Diff_DeltaType_ADD;
  static const DeltaType DEL =
    Delta_Diff_DeltaType_DEL;
  static const DeltaType MOVE =
    Delta_Diff_DeltaType_MOVE;
  static const DeltaType UPDATE =
    Delta_Diff_DeltaType_UPDATE;
  static inline bool DeltaType_IsValid(int value) {
    return Delta_Diff_DeltaType_IsValid(value);
  }
  static const DeltaType DeltaType_MIN =
    Delta_Diff_DeltaType_DeltaType_MIN;
  static const DeltaType DeltaType_MAX =
    Delta_Diff_DeltaType_DeltaType_MAX;
  static const int DeltaType_ARRAYSIZE =
    Delta_Diff_DeltaType_DeltaType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DeltaType_descriptor() {
    return Delta_Diff_DeltaType_descriptor();
  }
  static inline const ::std::string& DeltaType_Name(DeltaType value) {
    return Delta_Diff_DeltaType_Name(value);
  }
  static inline bool DeltaType_Parse(const ::std::string& name,
      DeltaType* value) {
    return Delta_Diff_DeltaType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .fast.Delta.Diff.DeltaType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::fast::Delta_Diff_DeltaType type() const;
  void set_type(::fast::Delta_Diff_DeltaType value);

  // .fast.Delta.Diff.Match match = 2;
  bool has_match() const;
  void clear_match();
  static const int kMatchFieldNumber = 2;
  const ::fast::Delta_Diff_Match& match() const;
  ::fast::Delta_Diff_Match* mutable_match();
  ::fast::Delta_Diff_Match* release_match();
  void set_allocated_match(::fast::Delta_Diff_Match* match);

  // .fast.Delta.Diff.Add add = 3;
  bool has_add() const;
  void clear_add();
  static const int kAddFieldNumber = 3;
  const ::fast::Delta_Diff_Add& add() const;
  ::fast::Delta_Diff_Add* mutable_add();
  ::fast::Delta_Diff_Add* release_add();
  void set_allocated_add(::fast::Delta_Diff_Add* add);

  // .fast.Delta.Diff.Del del = 4;
  bool has_del() const;
  void clear_del();
  static const int kDelFieldNumber = 4;
  const ::fast::Delta_Diff_Del& del() const;
  ::fast::Delta_Diff_Del* mutable_del();
  ::fast::Delta_Diff_Del* release_del();
  void set_allocated_del(::fast::Delta_Diff_Del* del);

  // .fast.Delta.Diff.Move move = 5;
  bool has_move() const;
  void clear_move();
  static const int kMoveFieldNumber = 5;
  const ::fast::Delta_Diff_Move& move() const;
  ::fast::Delta_Diff_Move* mutable_move();
  ::fast::Delta_Diff_Move* release_move();
  void set_allocated_move(::fast::Delta_Diff_Move* move);

  // .fast.Delta.Diff.Update update = 6;
  bool has_update() const;
  void clear_update();
  static const int kUpdateFieldNumber = 6;
  const ::fast::Delta_Diff_Update& update() const;
  ::fast::Delta_Diff_Update* mutable_update();
  ::fast::Delta_Diff_Update* release_update();
  void set_allocated_update(::fast::Delta_Diff_Update* update);

  DeltaCase delta_case() const;
  // @@protoc_insertion_point(class_scope:fast.Delta.Diff)
 private:
  void set_has_match();
  void set_has_add();
  void set_has_del();
  void set_has_move();
  void set_has_update();

  inline bool has_delta() const;
  void clear_delta();
  inline void clear_has_delta();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int type_;
  union DeltaUnion {
    DeltaUnion() {}
    ::fast::Delta_Diff_Match* match_;
    ::fast::Delta_Diff_Add* add_;
    ::fast::Delta_Diff_Del* del_;
    ::fast::Delta_Diff_Move* move_;
    ::fast::Delta_Diff_Update* update_;
  } delta_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Delta : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Delta) */ {
 public:
  Delta();
  virtual ~Delta();

  Delta(const Delta& from);

  inline Delta& operator=(const Delta& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Delta& default_instance();

  static inline const Delta* internal_default_instance() {
    return reinterpret_cast<const Delta*>(
               &_Delta_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Delta* other);

  // implements Message ----------------------------------------------

  inline Delta* New() const PROTOBUF_FINAL { return New(NULL); }

  Delta* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Delta& from);
  void MergeFrom(const Delta& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Delta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Delta_Diff Diff;

  // accessors -------------------------------------------------------

  // repeated .fast.Delta.Diff diff = 3;
  int diff_size() const;
  void clear_diff();
  static const int kDiffFieldNumber = 3;
  const ::fast::Delta_Diff& diff(int index) const;
  ::fast::Delta_Diff* mutable_diff(int index);
  ::fast::Delta_Diff* add_diff();
  ::google::protobuf::RepeatedPtrField< ::fast::Delta_Diff >*
      mutable_diff();
  const ::google::protobuf::RepeatedPtrField< ::fast::Delta_Diff >&
      diff() const;

  // string src = 1;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  const ::std::string& src() const;
  void set_src(const ::std::string& value);
  #if LANG_CXX11
  void set_src(::std::string&& value);
  #endif
  void set_src(const char* value);
  void set_src(const char* value, size_t size);
  ::std::string* mutable_src();
  ::std::string* release_src();
  void set_allocated_src(::std::string* src);

  // string dst = 2;
  void clear_dst();
  static const int kDstFieldNumber = 2;
  const ::std::string& dst() const;
  void set_dst(const ::std::string& value);
  #if LANG_CXX11
  void set_dst(::std::string&& value);
  #endif
  void set_dst(const char* value);
  void set_dst(const char* value, size_t size);
  ::std::string* mutable_dst();
  ::std::string* release_dst();
  void set_allocated_dst(::std::string* dst);

  // @@protoc_insertion_point(class_scope:fast.Delta)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fast::Delta_Diff > diff_;
  ::google::protobuf::internal::ArenaStringPtr src_;
  ::google::protobuf::internal::ArenaStringPtr dst_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pairs_Pair_Diff : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Pairs.Pair.Diff) */ {
 public:
  Pairs_Pair_Diff();
  virtual ~Pairs_Pair_Diff();

  Pairs_Pair_Diff(const Pairs_Pair_Diff& from);

  inline Pairs_Pair_Diff& operator=(const Pairs_Pair_Diff& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pairs_Pair_Diff& default_instance();

  static inline const Pairs_Pair_Diff* internal_default_instance() {
    return reinterpret_cast<const Pairs_Pair_Diff*>(
               &_Pairs_Pair_Diff_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Pairs_Pair_Diff* other);

  // implements Message ----------------------------------------------

  inline Pairs_Pair_Diff* New() const PROTOBUF_FINAL { return New(NULL); }

  Pairs_Pair_Diff* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Pairs_Pair_Diff& from);
  void MergeFrom(const Pairs_Pair_Diff& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pairs_Pair_Diff* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 7;
  void clear_hash();
  static const int kHashFieldNumber = 7;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // .fast.Element old_code = 5;
  bool has_old_code() const;
  void clear_old_code();
  static const int kOldCodeFieldNumber = 5;
  const ::fast::Element& old_code() const;
  ::fast::Element* mutable_old_code();
  ::fast::Element* release_old_code();
  void set_allocated_old_code(::fast::Element* old_code);

  // .fast.Element new_code = 6;
  bool has_new_code() const;
  void clear_new_code();
  static const int kNewCodeFieldNumber = 6;
  const ::fast::Element& new_code() const;
  ::fast::Element* mutable_new_code();
  ::fast::Element* release_new_code();
  void set_allocated_new_code(::fast::Element* new_code);

  // int32 left_line = 1;
  void clear_left_line();
  static const int kLeftLineFieldNumber = 1;
  ::google::protobuf::int32 left_line() const;
  void set_left_line(::google::protobuf::int32 value);

  // int32 left_column = 2;
  void clear_left_column();
  static const int kLeftColumnFieldNumber = 2;
  ::google::protobuf::int32 left_column() const;
  void set_left_column(::google::protobuf::int32 value);

  // int32 right_line = 3;
  void clear_right_line();
  static const int kRightLineFieldNumber = 3;
  ::google::protobuf::int32 right_line() const;
  void set_right_line(::google::protobuf::int32 value);

  // int32 right_column = 4;
  void clear_right_column();
  static const int kRightColumnFieldNumber = 4;
  ::google::protobuf::int32 right_column() const;
  void set_right_column(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fast.Pairs.Pair.Diff)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::fast::Element* old_code_;
  ::fast::Element* new_code_;
  ::google::protobuf::int32 left_line_;
  ::google::protobuf::int32 left_column_;
  ::google::protobuf::int32 right_line_;
  ::google::protobuf::int32 right_column_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pairs_Pair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Pairs.Pair) */ {
 public:
  Pairs_Pair();
  virtual ~Pairs_Pair();

  Pairs_Pair(const Pairs_Pair& from);

  inline Pairs_Pair& operator=(const Pairs_Pair& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pairs_Pair& default_instance();

  static inline const Pairs_Pair* internal_default_instance() {
    return reinterpret_cast<const Pairs_Pair*>(
               &_Pairs_Pair_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Pairs_Pair* other);

  // implements Message ----------------------------------------------

  inline Pairs_Pair* New() const PROTOBUF_FINAL { return New(NULL); }

  Pairs_Pair* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Pairs_Pair& from);
  void MergeFrom(const Pairs_Pair& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pairs_Pair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Pairs_Pair_Diff Diff;

  typedef Pairs_Pair_CloneType CloneType;
  static const CloneType MAYBE =
    Pairs_Pair_CloneType_MAYBE;
  static const CloneType YES =
    Pairs_Pair_CloneType_YES;
  static const CloneType NO =
    Pairs_Pair_CloneType_NO;
  static inline bool CloneType_IsValid(int value) {
    return Pairs_Pair_CloneType_IsValid(value);
  }
  static const CloneType CloneType_MIN =
    Pairs_Pair_CloneType_CloneType_MIN;
  static const CloneType CloneType_MAX =
    Pairs_Pair_CloneType_CloneType_MAX;
  static const int CloneType_ARRAYSIZE =
    Pairs_Pair_CloneType_CloneType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CloneType_descriptor() {
    return Pairs_Pair_CloneType_descriptor();
  }
  static inline const ::std::string& CloneType_Name(CloneType value) {
    return Pairs_Pair_CloneType_Name(value);
  }
  static inline bool CloneType_Parse(const ::std::string& name,
      CloneType* value) {
    return Pairs_Pair_CloneType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string project = 1;
  void clear_project();
  static const int kProjectFieldNumber = 1;
  const ::std::string& project() const;
  void set_project(const ::std::string& value);
  #if LANG_CXX11
  void set_project(::std::string&& value);
  #endif
  void set_project(const char* value);
  void set_project(const char* value, size_t size);
  ::std::string* mutable_project();
  ::std::string* release_project();
  void set_allocated_project(::std::string* project);

  // .fast.Pairs.Pair.Diff left = 2;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 2;
  const ::fast::Pairs_Pair_Diff& left() const;
  ::fast::Pairs_Pair_Diff* mutable_left();
  ::fast::Pairs_Pair_Diff* release_left();
  void set_allocated_left(::fast::Pairs_Pair_Diff* left);

  // .fast.Pairs.Pair.Diff right = 3;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 3;
  const ::fast::Pairs_Pair_Diff& right() const;
  ::fast::Pairs_Pair_Diff* mutable_right();
  ::fast::Pairs_Pair_Diff* release_right();
  void set_allocated_right(::fast::Pairs_Pair_Diff* right);

  // .fast.Pairs.Pair.CloneType type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::fast::Pairs_Pair_CloneType type() const;
  void set_type(::fast::Pairs_Pair_CloneType value);

  // @@protoc_insertion_point(class_scope:fast.Pairs.Pair)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr project_;
  ::fast::Pairs_Pair_Diff* left_;
  ::fast::Pairs_Pair_Diff* right_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pairs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Pairs) */ {
 public:
  Pairs();
  virtual ~Pairs();

  Pairs(const Pairs& from);

  inline Pairs& operator=(const Pairs& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pairs& default_instance();

  static inline const Pairs* internal_default_instance() {
    return reinterpret_cast<const Pairs*>(
               &_Pairs_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Pairs* other);

  // implements Message ----------------------------------------------

  inline Pairs* New() const PROTOBUF_FINAL { return New(NULL); }

  Pairs* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Pairs& from);
  void MergeFrom(const Pairs& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pairs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Pairs_Pair Pair;

  // accessors -------------------------------------------------------

  // repeated .fast.Pairs.Pair pair = 1;
  int pair_size() const;
  void clear_pair();
  static const int kPairFieldNumber = 1;
  const ::fast::Pairs_Pair& pair(int index) const;
  ::fast::Pairs_Pair* mutable_pair(int index);
  ::fast::Pairs_Pair* add_pair();
  ::google::protobuf::RepeatedPtrField< ::fast::Pairs_Pair >*
      mutable_pair();
  const ::google::protobuf::RepeatedPtrField< ::fast::Pairs_Pair >&
      pair() const;

  // @@protoc_insertion_point(class_scope:fast.Pairs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fast::Pairs_Pair > pair_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Log_Commit_Committer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Log.Commit.Committer) */ {
 public:
  Log_Commit_Committer();
  virtual ~Log_Commit_Committer();

  Log_Commit_Committer(const Log_Commit_Committer& from);

  inline Log_Commit_Committer& operator=(const Log_Commit_Committer& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log_Commit_Committer& default_instance();

  static inline const Log_Commit_Committer* internal_default_instance() {
    return reinterpret_cast<const Log_Commit_Committer*>(
               &_Log_Commit_Committer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Log_Commit_Committer* other);

  // implements Message ----------------------------------------------

  inline Log_Commit_Committer* New() const PROTOBUF_FINAL { return New(NULL); }

  Log_Commit_Committer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Log_Commit_Committer& from);
  void MergeFrom(const Log_Commit_Committer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Log_Commit_Committer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string commit_date = 2;
  void clear_commit_date();
  static const int kCommitDateFieldNumber = 2;
  const ::std::string& commit_date() const;
  void set_commit_date(const ::std::string& value);
  #if LANG_CXX11
  void set_commit_date(::std::string&& value);
  #endif
  void set_commit_date(const char* value);
  void set_commit_date(const char* value, size_t size);
  ::std::string* mutable_commit_date();
  ::std::string* release_commit_date();
  void set_allocated_commit_date(::std::string* commit_date);

  // int32 committer_id = 1;
  void clear_committer_id();
  static const int kCommitterIdFieldNumber = 1;
  ::google::protobuf::int32 committer_id() const;
  void set_committer_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fast.Log.Commit.Committer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr commit_date_;
  ::google::protobuf::int32 committer_id_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Log_Commit_Diff_Hunk_ModLine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Log.Commit.Diff.Hunk.ModLine) */ {
 public:
  Log_Commit_Diff_Hunk_ModLine();
  virtual ~Log_Commit_Diff_Hunk_ModLine();

  Log_Commit_Diff_Hunk_ModLine(const Log_Commit_Diff_Hunk_ModLine& from);

  inline Log_Commit_Diff_Hunk_ModLine& operator=(const Log_Commit_Diff_Hunk_ModLine& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log_Commit_Diff_Hunk_ModLine& default_instance();

  static inline const Log_Commit_Diff_Hunk_ModLine* internal_default_instance() {
    return reinterpret_cast<const Log_Commit_Diff_Hunk_ModLine*>(
               &_Log_Commit_Diff_Hunk_ModLine_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Log_Commit_Diff_Hunk_ModLine* other);

  // implements Message ----------------------------------------------

  inline Log_Commit_Diff_Hunk_ModLine* New() const PROTOBUF_FINAL { return New(NULL); }

  Log_Commit_Diff_Hunk_ModLine* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Log_Commit_Diff_Hunk_ModLine& from);
  void MergeFrom(const Log_Commit_Diff_Hunk_ModLine& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Log_Commit_Diff_Hunk_ModLine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes line = 1;
  void clear_line();
  static const int kLineFieldNumber = 1;
  const ::std::string& line() const;
  void set_line(const ::std::string& value);
  #if LANG_CXX11
  void set_line(::std::string&& value);
  #endif
  void set_line(const char* value);
  void set_line(const void* value, size_t size);
  ::std::string* mutable_line();
  ::std::string* release_line();
  void set_allocated_line(::std::string* line);

  // bool is_add = 2;
  void clear_is_add();
  static const int kIsAddFieldNumber = 2;
  bool is_add() const;
  void set_is_add(bool value);

  // bool is_del = 3;
  void clear_is_del();
  static const int kIsDelFieldNumber = 3;
  bool is_del() const;
  void set_is_del(bool value);

  // @@protoc_insertion_point(class_scope:fast.Log.Commit.Diff.Hunk.ModLine)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr line_;
  bool is_add_;
  bool is_del_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Log_Commit_Diff_Hunk : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Log.Commit.Diff.Hunk) */ {
 public:
  Log_Commit_Diff_Hunk();
  virtual ~Log_Commit_Diff_Hunk();

  Log_Commit_Diff_Hunk(const Log_Commit_Diff_Hunk& from);

  inline Log_Commit_Diff_Hunk& operator=(const Log_Commit_Diff_Hunk& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log_Commit_Diff_Hunk& default_instance();

  static inline const Log_Commit_Diff_Hunk* internal_default_instance() {
    return reinterpret_cast<const Log_Commit_Diff_Hunk*>(
               &_Log_Commit_Diff_Hunk_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(Log_Commit_Diff_Hunk* other);

  // implements Message ----------------------------------------------

  inline Log_Commit_Diff_Hunk* New() const PROTOBUF_FINAL { return New(NULL); }

  Log_Commit_Diff_Hunk* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Log_Commit_Diff_Hunk& from);
  void MergeFrom(const Log_Commit_Diff_Hunk& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Log_Commit_Diff_Hunk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Log_Commit_Diff_Hunk_ModLine ModLine;

  // accessors -------------------------------------------------------

  // repeated .fast.Element element = 6;
  int element_size() const;
  void clear_element();
  static const int kElementFieldNumber = 6;
  const ::fast::Element& element(int index) const;
  ::fast::Element* mutable_element(int index);
  ::fast::Element* add_element();
  ::google::protobuf::RepeatedPtrField< ::fast::Element >*
      mutable_element();
  const ::google::protobuf::RepeatedPtrField< ::fast::Element >&
      element() const;

  // repeated .fast.Log.Commit.Diff.Hunk.ModLine mod = 7;
  int mod_size() const;
  void clear_mod();
  static const int kModFieldNumber = 7;
  const ::fast::Log_Commit_Diff_Hunk_ModLine& mod(int index) const;
  ::fast::Log_Commit_Diff_Hunk_ModLine* mutable_mod(int index);
  ::fast::Log_Commit_Diff_Hunk_ModLine* add_mod();
  ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit_Diff_Hunk_ModLine >*
      mutable_mod();
  const ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit_Diff_Hunk_ModLine >&
      mod() const;

  // string context = 5;
  void clear_context();
  static const int kContextFieldNumber = 5;
  const ::std::string& context() const;
  void set_context(const ::std::string& value);
  #if LANG_CXX11
  void set_context(::std::string&& value);
  #endif
  void set_context(const char* value);
  void set_context(const char* value, size_t size);
  ::std::string* mutable_context();
  ::std::string* release_context();
  void set_allocated_context(::std::string* context);

  // .fast.Slices slice = 8;
  bool has_slice() const;
  void clear_slice();
  static const int kSliceFieldNumber = 8;
  const ::fast::Slices& slice() const;
  ::fast::Slices* mutable_slice();
  ::fast::Slices* release_slice();
  void set_allocated_slice(::fast::Slices* slice);

  // int32 from_lineno = 1;
  void clear_from_lineno();
  static const int kFromLinenoFieldNumber = 1;
  ::google::protobuf::int32 from_lineno() const;
  void set_from_lineno(::google::protobuf::int32 value);

  // int32 from_column = 2;
  void clear_from_column();
  static const int kFromColumnFieldNumber = 2;
  ::google::protobuf::int32 from_column() const;
  void set_from_column(::google::protobuf::int32 value);

  // int32 to_lineno = 3;
  void clear_to_lineno();
  static const int kToLinenoFieldNumber = 3;
  ::google::protobuf::int32 to_lineno() const;
  void set_to_lineno(::google::protobuf::int32 value);

  // int32 to_column = 4;
  void clear_to_column();
  static const int kToColumnFieldNumber = 4;
  ::google::protobuf::int32 to_column() const;
  void set_to_column(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fast.Log.Commit.Diff.Hunk)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fast::Element > element_;
  ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit_Diff_Hunk_ModLine > mod_;
  ::google::protobuf::internal::ArenaStringPtr context_;
  ::fast::Slices* slice_;
  ::google::protobuf::int32 from_lineno_;
  ::google::protobuf::int32 from_column_;
  ::google::protobuf::int32 to_lineno_;
  ::google::protobuf::int32 to_column_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Log_Commit_Diff : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Log.Commit.Diff) */ {
 public:
  Log_Commit_Diff();
  virtual ~Log_Commit_Diff();

  Log_Commit_Diff(const Log_Commit_Diff& from);

  inline Log_Commit_Diff& operator=(const Log_Commit_Diff& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log_Commit_Diff& default_instance();

  static inline const Log_Commit_Diff* internal_default_instance() {
    return reinterpret_cast<const Log_Commit_Diff*>(
               &_Log_Commit_Diff_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(Log_Commit_Diff* other);

  // implements Message ----------------------------------------------

  inline Log_Commit_Diff* New() const PROTOBUF_FINAL { return New(NULL); }

  Log_Commit_Diff* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Log_Commit_Diff& from);
  void MergeFrom(const Log_Commit_Diff& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Log_Commit_Diff* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Log_Commit_Diff_Hunk Hunk;

  // accessors -------------------------------------------------------

  // repeated .fast.Log.Commit.Diff.Hunk hunk = 8;
  int hunk_size() const;
  void clear_hunk();
  static const int kHunkFieldNumber = 8;
  const ::fast::Log_Commit_Diff_Hunk& hunk(int index) const;
  ::fast::Log_Commit_Diff_Hunk* mutable_hunk(int index);
  ::fast::Log_Commit_Diff_Hunk* add_hunk();
  ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit_Diff_Hunk >*
      mutable_hunk();
  const ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit_Diff_Hunk >&
      hunk() const;

  // string a = 1;
  void clear_a();
  static const int kAFieldNumber = 1;
  const ::std::string& a() const;
  void set_a(const ::std::string& value);
  #if LANG_CXX11
  void set_a(::std::string&& value);
  #endif
  void set_a(const char* value);
  void set_a(const char* value, size_t size);
  ::std::string* mutable_a();
  ::std::string* release_a();
  void set_allocated_a(::std::string* a);

  // string b = 2;
  void clear_b();
  static const int kBFieldNumber = 2;
  const ::std::string& b() const;
  void set_b(const ::std::string& value);
  #if LANG_CXX11
  void set_b(::std::string&& value);
  #endif
  void set_b(const char* value);
  void set_b(const char* value, size_t size);
  ::std::string* mutable_b();
  ::std::string* release_b();
  void set_allocated_b(::std::string* b);

  // string is_code = 4;
  void clear_is_code();
  static const int kIsCodeFieldNumber = 4;
  const ::std::string& is_code() const;
  void set_is_code(const ::std::string& value);
  #if LANG_CXX11
  void set_is_code(::std::string&& value);
  #endif
  void set_is_code(const char* value);
  void set_is_code(const char* value, size_t size);
  ::std::string* mutable_is_code();
  ::std::string* release_is_code();
  void set_allocated_is_code(::std::string* is_code);

  // string index_from = 5;
  void clear_index_from();
  static const int kIndexFromFieldNumber = 5;
  const ::std::string& index_from() const;
  void set_index_from(const ::std::string& value);
  #if LANG_CXX11
  void set_index_from(::std::string&& value);
  #endif
  void set_index_from(const char* value);
  void set_index_from(const char* value, size_t size);
  ::std::string* mutable_index_from();
  ::std::string* release_index_from();
  void set_allocated_index_from(::std::string* index_from);

  // string index_to = 6;
  void clear_index_to();
  static const int kIndexToFieldNumber = 6;
  const ::std::string& index_to() const;
  void set_index_to(const ::std::string& value);
  #if LANG_CXX11
  void set_index_to(::std::string&& value);
  #endif
  void set_index_to(const char* value);
  void set_index_to(const char* value, size_t size);
  ::std::string* mutable_index_to();
  ::std::string* release_index_to();
  void set_allocated_index_to(::std::string* index_to);

  // string mode = 7;
  void clear_mode();
  static const int kModeFieldNumber = 7;
  const ::std::string& mode() const;
  void set_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_mode(::std::string&& value);
  #endif
  void set_mode(const char* value);
  void set_mode(const char* value, size_t size);
  ::std::string* mutable_mode();
  ::std::string* release_mode();
  void set_allocated_mode(::std::string* mode);

  // bool is_new = 3;
  void clear_is_new();
  static const int kIsNewFieldNumber = 3;
  bool is_new() const;
  void set_is_new(bool value);

  // @@protoc_insertion_point(class_scope:fast.Log.Commit.Diff)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit_Diff_Hunk > hunk_;
  ::google::protobuf::internal::ArenaStringPtr a_;
  ::google::protobuf::internal::ArenaStringPtr b_;
  ::google::protobuf::internal::ArenaStringPtr is_code_;
  ::google::protobuf::internal::ArenaStringPtr index_from_;
  ::google::protobuf::internal::ArenaStringPtr index_to_;
  ::google::protobuf::internal::ArenaStringPtr mode_;
  bool is_new_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Log_Commit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Log.Commit) */ {
 public:
  Log_Commit();
  virtual ~Log_Commit();

  Log_Commit(const Log_Commit& from);

  inline Log_Commit& operator=(const Log_Commit& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log_Commit& default_instance();

  enum ExtraCase {
    kCommitter = 5,
    EXTRA_NOT_SET = 0,
  };

  static inline const Log_Commit* internal_default_instance() {
    return reinterpret_cast<const Log_Commit*>(
               &_Log_Commit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(Log_Commit* other);

  // implements Message ----------------------------------------------

  inline Log_Commit* New() const PROTOBUF_FINAL { return New(NULL); }

  Log_Commit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Log_Commit& from);
  void MergeFrom(const Log_Commit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Log_Commit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Log_Commit_Committer Committer;
  typedef Log_Commit_Diff Diff;

  // accessors -------------------------------------------------------

  // repeated .fast.Log.Commit.Diff diff = 6;
  int diff_size() const;
  void clear_diff();
  static const int kDiffFieldNumber = 6;
  const ::fast::Log_Commit_Diff& diff(int index) const;
  ::fast::Log_Commit_Diff* mutable_diff(int index);
  ::fast::Log_Commit_Diff* add_diff();
  ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit_Diff >*
      mutable_diff();
  const ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit_Diff >&
      diff() const;

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // bytes text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const void* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // string author_date = 4;
  void clear_author_date();
  static const int kAuthorDateFieldNumber = 4;
  const ::std::string& author_date() const;
  void set_author_date(const ::std::string& value);
  #if LANG_CXX11
  void set_author_date(::std::string&& value);
  #endif
  void set_author_date(const char* value);
  void set_author_date(const char* value, size_t size);
  ::std::string* mutable_author_date();
  ::std::string* release_author_date();
  void set_allocated_author_date(::std::string* author_date);

  // .fast.Slices slice = 7;
  bool has_slice() const;
  void clear_slice();
  static const int kSliceFieldNumber = 7;
  const ::fast::Slices& slice() const;
  ::fast::Slices* mutable_slice();
  ::fast::Slices* release_slice();
  void set_allocated_slice(::fast::Slices* slice);

  // int32 author_id = 3;
  void clear_author_id();
  static const int kAuthorIdFieldNumber = 3;
  ::google::protobuf::int32 author_id() const;
  void set_author_id(::google::protobuf::int32 value);

  // .fast.Log.Commit.Committer committer = 5;
  bool has_committer() const;
  void clear_committer();
  static const int kCommitterFieldNumber = 5;
  const ::fast::Log_Commit_Committer& committer() const;
  ::fast::Log_Commit_Committer* mutable_committer();
  ::fast::Log_Commit_Committer* release_committer();
  void set_allocated_committer(::fast::Log_Commit_Committer* committer);

  ExtraCase extra_case() const;
  // @@protoc_insertion_point(class_scope:fast.Log.Commit)
 private:
  void set_has_committer();

  inline bool has_extra() const;
  void clear_extra();
  inline void clear_has_extra();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit_Diff > diff_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr author_date_;
  ::fast::Slices* slice_;
  ::google::protobuf::int32 author_id_;
  union ExtraUnion {
    ExtraUnion() {}
    ::fast::Log_Commit_Committer* committer_;
  } extra_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Log_Author : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Log.Author) */ {
 public:
  Log_Author();
  virtual ~Log_Author();

  Log_Author(const Log_Author& from);

  inline Log_Author& operator=(const Log_Author& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log_Author& default_instance();

  static inline const Log_Author* internal_default_instance() {
    return reinterpret_cast<const Log_Author*>(
               &_Log_Author_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(Log_Author* other);

  // implements Message ----------------------------------------------

  inline Log_Author* New() const PROTOBUF_FINAL { return New(NULL); }

  Log_Author* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Log_Author& from);
  void MergeFrom(const Log_Author& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Log_Author* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string email = 3;
  void clear_email();
  static const int kEmailFieldNumber = 3;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fast.Log.Author)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Log : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Log) */ {
 public:
  Log();
  virtual ~Log();

  Log(const Log& from);

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log& default_instance();

  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(Log* other);

  // implements Message ----------------------------------------------

  inline Log* New() const PROTOBUF_FINAL { return New(NULL); }

  Log* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Log& from);
  void MergeFrom(const Log& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Log* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Log_Commit Commit;
  typedef Log_Author Author;

  // accessors -------------------------------------------------------

  // repeated .fast.Log.Commit commit = 1;
  int commit_size() const;
  void clear_commit();
  static const int kCommitFieldNumber = 1;
  const ::fast::Log_Commit& commit(int index) const;
  ::fast::Log_Commit* mutable_commit(int index);
  ::fast::Log_Commit* add_commit();
  ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit >*
      mutable_commit();
  const ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit >&
      commit() const;

  // repeated .fast.Log.Author author = 2;
  int author_size() const;
  void clear_author();
  static const int kAuthorFieldNumber = 2;
  const ::fast::Log_Author& author(int index) const;
  ::fast::Log_Author* mutable_author(int index);
  ::fast::Log_Author* add_author();
  ::google::protobuf::RepeatedPtrField< ::fast::Log_Author >*
      mutable_author();
  const ::google::protobuf::RepeatedPtrField< ::fast::Log_Author >&
      author() const;

  // @@protoc_insertion_point(class_scope:fast.Log)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit > commit_;
  ::google::protobuf::RepeatedPtrField< ::fast::Log_Author > author_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Slices_Slice_SourceFile_Function_Variable_Position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Slices.Slice.SourceFile.Function.Variable.Position) */ {
 public:
  Slices_Slice_SourceFile_Function_Variable_Position();
  virtual ~Slices_Slice_SourceFile_Function_Variable_Position();

  Slices_Slice_SourceFile_Function_Variable_Position(const Slices_Slice_SourceFile_Function_Variable_Position& from);

  inline Slices_Slice_SourceFile_Function_Variable_Position& operator=(const Slices_Slice_SourceFile_Function_Variable_Position& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Slices_Slice_SourceFile_Function_Variable_Position& default_instance();

  static inline const Slices_Slice_SourceFile_Function_Variable_Position* internal_default_instance() {
    return reinterpret_cast<const Slices_Slice_SourceFile_Function_Variable_Position*>(
               &_Slices_Slice_SourceFile_Function_Variable_Position_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(Slices_Slice_SourceFile_Function_Variable_Position* other);

  // implements Message ----------------------------------------------

  inline Slices_Slice_SourceFile_Function_Variable_Position* New() const PROTOBUF_FINAL { return New(NULL); }

  Slices_Slice_SourceFile_Function_Variable_Position* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Slices_Slice_SourceFile_Function_Variable_Position& from);
  void MergeFrom(const Slices_Slice_SourceFile_Function_Variable_Position& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Slices_Slice_SourceFile_Function_Variable_Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 lineno = 1;
  void clear_lineno();
  static const int kLinenoFieldNumber = 1;
  ::google::protobuf::int32 lineno() const;
  void set_lineno(::google::protobuf::int32 value);

  // .fast.Slices.Slice.ChangeType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::fast::Slices_Slice_ChangeType type() const;
  void set_type(::fast::Slices_Slice_ChangeType value);

  // int32 delta_lineno = 5;
  void clear_delta_lineno();
  static const int kDeltaLinenoFieldNumber = 5;
  ::google::protobuf::int32 delta_lineno() const;
  void set_delta_lineno(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fast.Slices.Slice.SourceFile.Function.Variable.Position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 lineno_;
  int type_;
  ::google::protobuf::int32 delta_lineno_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Slices_Slice_SourceFile_Function_Variable_FunctionDecl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Slices.Slice.SourceFile.Function.Variable.FunctionDecl) */ {
 public:
  Slices_Slice_SourceFile_Function_Variable_FunctionDecl();
  virtual ~Slices_Slice_SourceFile_Function_Variable_FunctionDecl();

  Slices_Slice_SourceFile_Function_Variable_FunctionDecl(const Slices_Slice_SourceFile_Function_Variable_FunctionDecl& from);

  inline Slices_Slice_SourceFile_Function_Variable_FunctionDecl& operator=(const Slices_Slice_SourceFile_Function_Variable_FunctionDecl& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Slices_Slice_SourceFile_Function_Variable_FunctionDecl& default_instance();

  static inline const Slices_Slice_SourceFile_Function_Variable_FunctionDecl* internal_default_instance() {
    return reinterpret_cast<const Slices_Slice_SourceFile_Function_Variable_FunctionDecl*>(
               &_Slices_Slice_SourceFile_Function_Variable_FunctionDecl_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(Slices_Slice_SourceFile_Function_Variable_FunctionDecl* other);

  // implements Message ----------------------------------------------

  inline Slices_Slice_SourceFile_Function_Variable_FunctionDecl* New() const PROTOBUF_FINAL { return New(NULL); }

  Slices_Slice_SourceFile_Function_Variable_FunctionDecl* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Slices_Slice_SourceFile_Function_Variable_FunctionDecl& from);
  void MergeFrom(const Slices_Slice_SourceFile_Function_Variable_FunctionDecl& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Slices_Slice_SourceFile_Function_Variable_FunctionDecl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int32 lineno = 2;
  void clear_lineno();
  static const int kLinenoFieldNumber = 2;
  ::google::protobuf::int32 lineno() const;
  void set_lineno(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fast.Slices.Slice.SourceFile.Function.Variable.FunctionDecl)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 lineno_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Slices_Slice_SourceFile_Function_Variable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Slices.Slice.SourceFile.Function.Variable) */ {
 public:
  Slices_Slice_SourceFile_Function_Variable();
  virtual ~Slices_Slice_SourceFile_Function_Variable();

  Slices_Slice_SourceFile_Function_Variable(const Slices_Slice_SourceFile_Function_Variable& from);

  inline Slices_Slice_SourceFile_Function_Variable& operator=(const Slices_Slice_SourceFile_Function_Variable& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Slices_Slice_SourceFile_Function_Variable& default_instance();

  static inline const Slices_Slice_SourceFile_Function_Variable* internal_default_instance() {
    return reinterpret_cast<const Slices_Slice_SourceFile_Function_Variable*>(
               &_Slices_Slice_SourceFile_Function_Variable_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(Slices_Slice_SourceFile_Function_Variable* other);

  // implements Message ----------------------------------------------

  inline Slices_Slice_SourceFile_Function_Variable* New() const PROTOBUF_FINAL { return New(NULL); }

  Slices_Slice_SourceFile_Function_Variable* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Slices_Slice_SourceFile_Function_Variable& from);
  void MergeFrom(const Slices_Slice_SourceFile_Function_Variable& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Slices_Slice_SourceFile_Function_Variable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Slices_Slice_SourceFile_Function_Variable_Position Position;
  typedef Slices_Slice_SourceFile_Function_Variable_FunctionDecl FunctionDecl;

  // accessors -------------------------------------------------------

  // repeated .fast.Slices.Slice.SourceFile.Function.Variable.Position defn = 4;
  int defn_size() const;
  void clear_defn();
  static const int kDefnFieldNumber = 4;
  const ::fast::Slices_Slice_SourceFile_Function_Variable_Position& defn(int index) const;
  ::fast::Slices_Slice_SourceFile_Function_Variable_Position* mutable_defn(int index);
  ::fast::Slices_Slice_SourceFile_Function_Variable_Position* add_defn();
  ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable_Position >*
      mutable_defn();
  const ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable_Position >&
      defn() const;

  // repeated .fast.Slices.Slice.SourceFile.Function.Variable.Position use = 5;
  int use_size() const;
  void clear_use();
  static const int kUseFieldNumber = 5;
  const ::fast::Slices_Slice_SourceFile_Function_Variable_Position& use(int index) const;
  ::fast::Slices_Slice_SourceFile_Function_Variable_Position* mutable_use(int index);
  ::fast::Slices_Slice_SourceFile_Function_Variable_Position* add_use();
  ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable_Position >*
      mutable_use();
  const ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable_Position >&
      use() const;

  // repeated string dvar = 6;
  int dvar_size() const;
  void clear_dvar();
  static const int kDvarFieldNumber = 6;
  const ::std::string& dvar(int index) const;
  ::std::string* mutable_dvar(int index);
  void set_dvar(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dvar(int index, ::std::string&& value);
  #endif
  void set_dvar(int index, const char* value);
  void set_dvar(int index, const char* value, size_t size);
  ::std::string* add_dvar();
  void add_dvar(const ::std::string& value);
  #if LANG_CXX11
  void add_dvar(::std::string&& value);
  #endif
  void add_dvar(const char* value);
  void add_dvar(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dvar() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dvar();

  // repeated string alias = 7;
  int alias_size() const;
  void clear_alias();
  static const int kAliasFieldNumber = 7;
  const ::std::string& alias(int index) const;
  ::std::string* mutable_alias(int index);
  void set_alias(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_alias(int index, ::std::string&& value);
  #endif
  void set_alias(int index, const char* value);
  void set_alias(int index, const char* value, size_t size);
  ::std::string* add_alias();
  void add_alias(const ::std::string& value);
  #if LANG_CXX11
  void add_alias(::std::string&& value);
  #endif
  void add_alias(const char* value);
  void add_alias(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& alias() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_alias();

  // repeated .fast.Slices.Slice.SourceFile.Function.Variable.FunctionDecl cfunc = 8;
  int cfunc_size() const;
  void clear_cfunc();
  static const int kCfuncFieldNumber = 8;
  const ::fast::Slices_Slice_SourceFile_Function_Variable_FunctionDecl& cfunc(int index) const;
  ::fast::Slices_Slice_SourceFile_Function_Variable_FunctionDecl* mutable_cfunc(int index);
  ::fast::Slices_Slice_SourceFile_Function_Variable_FunctionDecl* add_cfunc();
  ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable_FunctionDecl >*
      mutable_cfunc();
  const ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable_FunctionDecl >&
      cfunc() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .fast.Slices.Slice.SourceFile.Function.Variable.Position pos = 2;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 2;
  const ::fast::Slices_Slice_SourceFile_Function_Variable_Position& pos() const;
  ::fast::Slices_Slice_SourceFile_Function_Variable_Position* mutable_pos();
  ::fast::Slices_Slice_SourceFile_Function_Variable_Position* release_pos();
  void set_allocated_pos(::fast::Slices_Slice_SourceFile_Function_Variable_Position* pos);

  // .fast.Slices.Slice.ChangeType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::fast::Slices_Slice_ChangeType type() const;
  void set_type(::fast::Slices_Slice_ChangeType value);

  // @@protoc_insertion_point(class_scope:fast.Slices.Slice.SourceFile.Function.Variable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable_Position > defn_;
  ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable_Position > use_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dvar_;
  ::google::protobuf::RepeatedPtrField< ::std::string> alias_;
  ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable_FunctionDecl > cfunc_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::fast::Slices_Slice_SourceFile_Function_Variable_Position* pos_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Slices_Slice_SourceFile_Function : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Slices.Slice.SourceFile.Function) */ {
 public:
  Slices_Slice_SourceFile_Function();
  virtual ~Slices_Slice_SourceFile_Function();

  Slices_Slice_SourceFile_Function(const Slices_Slice_SourceFile_Function& from);

  inline Slices_Slice_SourceFile_Function& operator=(const Slices_Slice_SourceFile_Function& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Slices_Slice_SourceFile_Function& default_instance();

  static inline const Slices_Slice_SourceFile_Function* internal_default_instance() {
    return reinterpret_cast<const Slices_Slice_SourceFile_Function*>(
               &_Slices_Slice_SourceFile_Function_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(Slices_Slice_SourceFile_Function* other);

  // implements Message ----------------------------------------------

  inline Slices_Slice_SourceFile_Function* New() const PROTOBUF_FINAL { return New(NULL); }

  Slices_Slice_SourceFile_Function* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Slices_Slice_SourceFile_Function& from);
  void MergeFrom(const Slices_Slice_SourceFile_Function& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Slices_Slice_SourceFile_Function* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Slices_Slice_SourceFile_Function_Variable Variable;

  // accessors -------------------------------------------------------

  // repeated .fast.Slices.Slice.SourceFile.Function.Variable variable = 1;
  int variable_size() const;
  void clear_variable();
  static const int kVariableFieldNumber = 1;
  const ::fast::Slices_Slice_SourceFile_Function_Variable& variable(int index) const;
  ::fast::Slices_Slice_SourceFile_Function_Variable* mutable_variable(int index);
  ::fast::Slices_Slice_SourceFile_Function_Variable* add_variable();
  ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable >*
      mutable_variable();
  const ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable >&
      variable() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .fast.Slices.Slice.ChangeType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::fast::Slices_Slice_ChangeType type() const;
  void set_type(::fast::Slices_Slice_ChangeType value);

  // @@protoc_insertion_point(class_scope:fast.Slices.Slice.SourceFile.Function)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable > variable_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Slices_Slice_SourceFile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Slices.Slice.SourceFile) */ {
 public:
  Slices_Slice_SourceFile();
  virtual ~Slices_Slice_SourceFile();

  Slices_Slice_SourceFile(const Slices_Slice_SourceFile& from);

  inline Slices_Slice_SourceFile& operator=(const Slices_Slice_SourceFile& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Slices_Slice_SourceFile& default_instance();

  static inline const Slices_Slice_SourceFile* internal_default_instance() {
    return reinterpret_cast<const Slices_Slice_SourceFile*>(
               &_Slices_Slice_SourceFile_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(Slices_Slice_SourceFile* other);

  // implements Message ----------------------------------------------

  inline Slices_Slice_SourceFile* New() const PROTOBUF_FINAL { return New(NULL); }

  Slices_Slice_SourceFile* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Slices_Slice_SourceFile& from);
  void MergeFrom(const Slices_Slice_SourceFile& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Slices_Slice_SourceFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Slices_Slice_SourceFile_Function Function;

  // accessors -------------------------------------------------------

  // repeated .fast.Slices.Slice.SourceFile.Function function = 1;
  int function_size() const;
  void clear_function();
  static const int kFunctionFieldNumber = 1;
  const ::fast::Slices_Slice_SourceFile_Function& function(int index) const;
  ::fast::Slices_Slice_SourceFile_Function* mutable_function(int index);
  ::fast::Slices_Slice_SourceFile_Function* add_function();
  ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function >*
      mutable_function();
  const ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function >&
      function() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .fast.Slices.Slice.ChangeType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::fast::Slices_Slice_ChangeType type() const;
  void set_type(::fast::Slices_Slice_ChangeType value);

  // @@protoc_insertion_point(class_scope:fast.Slices.Slice.SourceFile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function > function_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Slices_Slice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Slices.Slice) */ {
 public:
  Slices_Slice();
  virtual ~Slices_Slice();

  Slices_Slice(const Slices_Slice& from);

  inline Slices_Slice& operator=(const Slices_Slice& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Slices_Slice& default_instance();

  static inline const Slices_Slice* internal_default_instance() {
    return reinterpret_cast<const Slices_Slice*>(
               &_Slices_Slice_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(Slices_Slice* other);

  // implements Message ----------------------------------------------

  inline Slices_Slice* New() const PROTOBUF_FINAL { return New(NULL); }

  Slices_Slice* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Slices_Slice& from);
  void MergeFrom(const Slices_Slice& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Slices_Slice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Slices_Slice_SourceFile SourceFile;

  typedef Slices_Slice_ChangeType ChangeType;
  static const ChangeType UNCHANGED =
    Slices_Slice_ChangeType_UNCHANGED;
  static const ChangeType ADD =
    Slices_Slice_ChangeType_ADD;
  static const ChangeType DEL =
    Slices_Slice_ChangeType_DEL;
  static inline bool ChangeType_IsValid(int value) {
    return Slices_Slice_ChangeType_IsValid(value);
  }
  static const ChangeType ChangeType_MIN =
    Slices_Slice_ChangeType_ChangeType_MIN;
  static const ChangeType ChangeType_MAX =
    Slices_Slice_ChangeType_ChangeType_MAX;
  static const int ChangeType_ARRAYSIZE =
    Slices_Slice_ChangeType_ChangeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ChangeType_descriptor() {
    return Slices_Slice_ChangeType_descriptor();
  }
  static inline const ::std::string& ChangeType_Name(ChangeType value) {
    return Slices_Slice_ChangeType_Name(value);
  }
  static inline bool ChangeType_Parse(const ::std::string& name,
      ChangeType* value) {
    return Slices_Slice_ChangeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .fast.Slices.Slice.SourceFile file = 1;
  int file_size() const;
  void clear_file();
  static const int kFileFieldNumber = 1;
  const ::fast::Slices_Slice_SourceFile& file(int index) const;
  ::fast::Slices_Slice_SourceFile* mutable_file(int index);
  ::fast::Slices_Slice_SourceFile* add_file();
  ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile >*
      mutable_file();
  const ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile >&
      file() const;

  // string hash = 2;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:fast.Slices.Slice)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile > file_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Slices : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Slices) */ {
 public:
  Slices();
  virtual ~Slices();

  Slices(const Slices& from);

  inline Slices& operator=(const Slices& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Slices& default_instance();

  static inline const Slices* internal_default_instance() {
    return reinterpret_cast<const Slices*>(
               &_Slices_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(Slices* other);

  // implements Message ----------------------------------------------

  inline Slices* New() const PROTOBUF_FINAL { return New(NULL); }

  Slices* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Slices& from);
  void MergeFrom(const Slices& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Slices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Slices_Slice Slice;

  // accessors -------------------------------------------------------

  // repeated .fast.Slices.Slice slice = 1;
  int slice_size() const;
  void clear_slice();
  static const int kSliceFieldNumber = 1;
  const ::fast::Slices_Slice& slice(int index) const;
  ::fast::Slices_Slice* mutable_slice(int index);
  ::fast::Slices_Slice* add_slice();
  ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice >*
      mutable_slice();
  const ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice >&
      slice() const;

  // @@protoc_insertion_point(class_scope:fast.Slices)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice > slice_;
  mutable int _cached_size_;
  friend struct protobuf_fast_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fast.Data) */ {
 public:
  Data();
  virtual ~Data();

  Data(const Data& from);

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Data& default_instance();

  enum RecordTypeCase {
    kElement = 1,
    kLog = 2,
    kDelta = 3,
    kPairs = 4,
    kSlices = 5,
    RECORDTYPE_NOT_SET = 0,
  };

  static inline const Data* internal_default_instance() {
    return reinterpret_cast<const Data*>(
               &_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(Data* other);

  // implements Message ----------------------------------------------

  inline Data* New() const PROTOBUF_FINAL { return New(NULL); }

  Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Data& from);
  void MergeFrom(const Data& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .fast.Element element = 1;
  bool has_element() const;
  void clear_element();
  static const int kElementFieldNumber = 1;
  const ::fast::Element& element() const;
  ::fast::Element* mutable_element();
  ::fast::Element* release_element();
  void set_allocated_element(::fast::Element* element);

  // .fast.Log log = 2;
  bool has_log() const;
  void clear_log();
  static const int kLogFieldNumber = 2;
  const ::fast::Log& log() const;
  ::fast::Log* mutable_log();
  ::fast::Log* release_log();
  void set_allocated_log(::fast::Log* log);

  // .fast.Delta delta = 3;
  bool has_delta() const;
  void clear_delta();
  static const int kDeltaFieldNumber = 3;
  const ::fast::Delta& delta() const;
  ::fast::Delta* mutable_delta();
  ::fast::Delta* release_delta();
  void set_allocated_delta(::fast::Delta* delta);

  // .fast.Pairs pairs = 4;
  bool has_pairs() const;
  void clear_pairs();
  static const int kPairsFieldNumber = 4;
  const ::fast::Pairs& pairs() const;
  ::fast::Pairs* mutable_pairs();
  ::fast::Pairs* release_pairs();
  void set_allocated_pairs(::fast::Pairs* pairs);

  // .fast.Slices slices = 5;
  bool has_slices() const;
  void clear_slices();
  static const int kSlicesFieldNumber = 5;
  const ::fast::Slices& slices() const;
  ::fast::Slices* mutable_slices();
  ::fast::Slices* release_slices();
  void set_allocated_slices(::fast::Slices* slices);

  RecordTypeCase RecordType_case() const;
  // @@protoc_insertion_point(class_scope:fast.Data)
 private:
  void set_has_element();
  void set_has_log();
  void set_has_delta();
  void set_has_pairs();
  void set_has_slices();

  inline bool has_RecordType() const;
  void clear_RecordType();
  inline void clear_has_RecordType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union RecordTypeUnion {
    RecordTypeUnion() {}
    ::fast::Element* element_;
    ::fast::Log* log_;
    ::fast::Delta* delta_;
    ::fast::Pairs* pairs_;
    ::fast::Slices* slices_;
  } RecordType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_fast_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Element_Unit

// string filename = 1;
inline void Element_Unit::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Element_Unit::filename() const {
  // @@protoc_insertion_point(field_get:fast.Element.Unit.filename)
  return filename_.GetNoArena();
}
inline void Element_Unit::set_filename(const ::std::string& value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Element.Unit.filename)
}
#if LANG_CXX11
inline void Element_Unit::set_filename(::std::string&& value) {
  
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Element.Unit.filename)
}
#endif
inline void Element_Unit::set_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Element.Unit.filename)
}
inline void Element_Unit::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Element.Unit.filename)
}
inline ::std::string* Element_Unit::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:fast.Element.Unit.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Element_Unit::release_filename() {
  // @@protoc_insertion_point(field_release:fast.Element.Unit.filename)
  
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Element_Unit::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:fast.Element.Unit.filename)
}

// string revision = 2;
inline void Element_Unit::clear_revision() {
  revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Element_Unit::revision() const {
  // @@protoc_insertion_point(field_get:fast.Element.Unit.revision)
  return revision_.GetNoArena();
}
inline void Element_Unit::set_revision(const ::std::string& value) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Element.Unit.revision)
}
#if LANG_CXX11
inline void Element_Unit::set_revision(::std::string&& value) {
  
  revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Element.Unit.revision)
}
#endif
inline void Element_Unit::set_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Element.Unit.revision)
}
inline void Element_Unit::set_revision(const char* value, size_t size) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Element.Unit.revision)
}
inline ::std::string* Element_Unit::mutable_revision() {
  
  // @@protoc_insertion_point(field_mutable:fast.Element.Unit.revision)
  return revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Element_Unit::release_revision() {
  // @@protoc_insertion_point(field_release:fast.Element.Unit.revision)
  
  return revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Element_Unit::set_allocated_revision(::std::string* revision) {
  if (revision != NULL) {
    
  } else {
    
  }
  revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), revision);
  // @@protoc_insertion_point(field_set_allocated:fast.Element.Unit.revision)
}

// .fast.Element.Unit.LanguageType language = 3;
inline void Element_Unit::clear_language() {
  language_ = 0;
}
inline ::fast::Element_Unit_LanguageType Element_Unit::language() const {
  // @@protoc_insertion_point(field_get:fast.Element.Unit.language)
  return static_cast< ::fast::Element_Unit_LanguageType >(language_);
}
inline void Element_Unit::set_language(::fast::Element_Unit_LanguageType value) {
  
  language_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.Unit.language)
}

// int32 item = 4;
inline void Element_Unit::clear_item() {
  item_ = 0;
}
inline ::google::protobuf::int32 Element_Unit::item() const {
  // @@protoc_insertion_point(field_get:fast.Element.Unit.item)
  return item_;
}
inline void Element_Unit::set_item(::google::protobuf::int32 value) {
  
  item_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.Unit.item)
}

// -------------------------------------------------------------------

// Element_Literal

// .fast.Element.Literal.LiteralType type = 1;
inline void Element_Literal::clear_type() {
  type_ = 0;
}
inline ::fast::Element_Literal_LiteralType Element_Literal::type() const {
  // @@protoc_insertion_point(field_get:fast.Element.Literal.type)
  return static_cast< ::fast::Element_Literal_LiteralType >(type_);
}
inline void Element_Literal::set_type(::fast::Element_Literal_LiteralType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.Literal.type)
}

// -------------------------------------------------------------------

// Element

// .fast.Element.Kind kind = 1;
inline bool Element::has_kind() const {
  return type_case() == kKind;
}
inline void Element::set_has_kind() {
  _oneof_case_[0] = kKind;
}
inline void Element::clear_kind() {
  if (has_kind()) {
    type_.kind_ = 0;
    clear_has_type();
  }
}
inline ::fast::Element_Kind Element::kind() const {
  // @@protoc_insertion_point(field_get:fast.Element.kind)
  if (has_kind()) {
    return static_cast< ::fast::Element_Kind >(type_.kind_);
  }
  return static_cast< ::fast::Element_Kind >(0);
}
inline void Element::set_kind(::fast::Element_Kind value) {
  if (!has_kind()) {
    clear_type();
    set_has_kind();
  }
  type_.kind_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.kind)
}

// .fast.SmaliKind smali_kind = 2;
inline bool Element::has_smali_kind() const {
  return type_case() == kSmaliKind;
}
inline void Element::set_has_smali_kind() {
  _oneof_case_[0] = kSmaliKind;
}
inline void Element::clear_smali_kind() {
  if (has_smali_kind()) {
    type_.smali_kind_ = 0;
    clear_has_type();
  }
}
inline ::fast::SmaliKind Element::smali_kind() const {
  // @@protoc_insertion_point(field_get:fast.Element.smali_kind)
  if (has_smali_kind()) {
    return static_cast< ::fast::SmaliKind >(type_.smali_kind_);
  }
  return static_cast< ::fast::SmaliKind >(0);
}
inline void Element::set_smali_kind(::fast::SmaliKind value) {
  if (!has_smali_kind()) {
    clear_type();
    set_has_smali_kind();
  }
  type_.smali_kind_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.smali_kind)
}

// string text = 3;
inline void Element::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Element::text() const {
  // @@protoc_insertion_point(field_get:fast.Element.text)
  return text_.GetNoArena();
}
inline void Element::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Element.text)
}
#if LANG_CXX11
inline void Element::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Element.text)
}
#endif
inline void Element::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Element.text)
}
inline void Element::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Element.text)
}
inline ::std::string* Element::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:fast.Element.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Element::release_text() {
  // @@protoc_insertion_point(field_release:fast.Element.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Element::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:fast.Element.text)
}

// int32 pos = 4;
inline void Element::clear_pos() {
  pos_ = 0;
}
inline ::google::protobuf::int32 Element::pos() const {
  // @@protoc_insertion_point(field_get:fast.Element.pos)
  return pos_;
}
inline void Element::set_pos(::google::protobuf::int32 value) {
  
  pos_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.pos)
}

// int32 length = 5;
inline void Element::clear_length() {
  length_ = 0;
}
inline ::google::protobuf::int32 Element::length() const {
  // @@protoc_insertion_point(field_get:fast.Element.length)
  return length_;
}
inline void Element::set_length(::google::protobuf::int32 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.length)
}

// repeated .fast.Element child = 6;
inline int Element::child_size() const {
  return child_.size();
}
inline void Element::clear_child() {
  child_.Clear();
}
inline const ::fast::Element& Element::child(int index) const {
  // @@protoc_insertion_point(field_get:fast.Element.child)
  return child_.Get(index);
}
inline ::fast::Element* Element::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Element.child)
  return child_.Mutable(index);
}
inline ::fast::Element* Element::add_child() {
  // @@protoc_insertion_point(field_add:fast.Element.child)
  return child_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Element >*
Element::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:fast.Element.child)
  return &child_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Element >&
Element::child() const {
  // @@protoc_insertion_point(field_list:fast.Element.child)
  return child_;
}

// string tail = 7;
inline void Element::clear_tail() {
  tail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Element::tail() const {
  // @@protoc_insertion_point(field_get:fast.Element.tail)
  return tail_.GetNoArena();
}
inline void Element::set_tail(const ::std::string& value) {
  
  tail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Element.tail)
}
#if LANG_CXX11
inline void Element::set_tail(::std::string&& value) {
  
  tail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Element.tail)
}
#endif
inline void Element::set_tail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Element.tail)
}
inline void Element::set_tail(const char* value, size_t size) {
  
  tail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Element.tail)
}
inline ::std::string* Element::mutable_tail() {
  
  // @@protoc_insertion_point(field_mutable:fast.Element.tail)
  return tail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Element::release_tail() {
  // @@protoc_insertion_point(field_release:fast.Element.tail)
  
  return tail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Element::set_allocated_tail(::std::string* tail) {
  if (tail != NULL) {
    
  } else {
    
  }
  tail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tail);
  // @@protoc_insertion_point(field_set_allocated:fast.Element.tail)
}

// .fast.Element.Unit unit = 8;
inline bool Element::has_unit() const {
  return extra_case() == kUnit;
}
inline void Element::set_has_unit() {
  _oneof_case_[1] = kUnit;
}
inline void Element::clear_unit() {
  if (has_unit()) {
    delete extra_.unit_;
    clear_has_extra();
  }
}
inline  const ::fast::Element_Unit& Element::unit() const {
  // @@protoc_insertion_point(field_get:fast.Element.unit)
  return has_unit()
      ? *extra_.unit_
      : ::fast::Element_Unit::default_instance();
}
inline ::fast::Element_Unit* Element::mutable_unit() {
  if (!has_unit()) {
    clear_extra();
    set_has_unit();
    extra_.unit_ = new ::fast::Element_Unit;
  }
  // @@protoc_insertion_point(field_mutable:fast.Element.unit)
  return extra_.unit_;
}
inline ::fast::Element_Unit* Element::release_unit() {
  // @@protoc_insertion_point(field_release:fast.Element.unit)
  if (has_unit()) {
    clear_has_extra();
    ::fast::Element_Unit* temp = extra_.unit_;
    extra_.unit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Element::set_allocated_unit(::fast::Element_Unit* unit) {
  clear_extra();
  if (unit) {
    set_has_unit();
    extra_.unit_ = unit;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Element.unit)
}

// .fast.Element.Literal literal = 9;
inline bool Element::has_literal() const {
  return extra_case() == kLiteral;
}
inline void Element::set_has_literal() {
  _oneof_case_[1] = kLiteral;
}
inline void Element::clear_literal() {
  if (has_literal()) {
    delete extra_.literal_;
    clear_has_extra();
  }
}
inline  const ::fast::Element_Literal& Element::literal() const {
  // @@protoc_insertion_point(field_get:fast.Element.literal)
  return has_literal()
      ? *extra_.literal_
      : ::fast::Element_Literal::default_instance();
}
inline ::fast::Element_Literal* Element::mutable_literal() {
  if (!has_literal()) {
    clear_extra();
    set_has_literal();
    extra_.literal_ = new ::fast::Element_Literal;
  }
  // @@protoc_insertion_point(field_mutable:fast.Element.literal)
  return extra_.literal_;
}
inline ::fast::Element_Literal* Element::release_literal() {
  // @@protoc_insertion_point(field_release:fast.Element.literal)
  if (has_literal()) {
    clear_has_extra();
    ::fast::Element_Literal* temp = extra_.literal_;
    extra_.literal_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Element::set_allocated_literal(::fast::Element_Literal* literal) {
  clear_extra();
  if (literal) {
    set_has_literal();
    extra_.literal_ = literal;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Element.literal)
}

// int32 line = 10;
inline void Element::clear_line() {
  line_ = 0;
}
inline ::google::protobuf::int32 Element::line() const {
  // @@protoc_insertion_point(field_get:fast.Element.line)
  return line_;
}
inline void Element::set_line(::google::protobuf::int32 value) {
  
  line_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.line)
}

// int32 column = 11;
inline void Element::clear_column() {
  column_ = 0;
}
inline ::google::protobuf::int32 Element::column() const {
  // @@protoc_insertion_point(field_get:fast.Element.column)
  return column_;
}
inline void Element::set_column(::google::protobuf::int32 value) {
  
  column_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.column)
}

inline bool Element::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Element::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline bool Element::has_extra() const {
  return extra_case() != EXTRA_NOT_SET;
}
inline void Element::clear_has_extra() {
  _oneof_case_[1] = EXTRA_NOT_SET;
}
inline Element::TypeCase Element::type_case() const {
  return Element::TypeCase(_oneof_case_[0]);
}
inline Element::ExtraCase Element::extra_case() const {
  return Element::ExtraCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// Delta_Diff_Match

// int32 src = 1;
inline void Delta_Diff_Match::clear_src() {
  src_ = 0;
}
inline ::google::protobuf::int32 Delta_Diff_Match::src() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.Match.src)
  return src_;
}
inline void Delta_Diff_Match::set_src(::google::protobuf::int32 value) {
  
  src_ = value;
  // @@protoc_insertion_point(field_set:fast.Delta.Diff.Match.src)
}

// int32 dst = 2;
inline void Delta_Diff_Match::clear_dst() {
  dst_ = 0;
}
inline ::google::protobuf::int32 Delta_Diff_Match::dst() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.Match.dst)
  return dst_;
}
inline void Delta_Diff_Match::set_dst(::google::protobuf::int32 value) {
  
  dst_ = value;
  // @@protoc_insertion_point(field_set:fast.Delta.Diff.Match.dst)
}

// -------------------------------------------------------------------

// Delta_Diff_Add

// int32 src = 1;
inline void Delta_Diff_Add::clear_src() {
  src_ = 0;
}
inline ::google::protobuf::int32 Delta_Diff_Add::src() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.Add.src)
  return src_;
}
inline void Delta_Diff_Add::set_src(::google::protobuf::int32 value) {
  
  src_ = value;
  // @@protoc_insertion_point(field_set:fast.Delta.Diff.Add.src)
}

// int32 dst = 2;
inline void Delta_Diff_Add::clear_dst() {
  dst_ = 0;
}
inline ::google::protobuf::int32 Delta_Diff_Add::dst() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.Add.dst)
  return dst_;
}
inline void Delta_Diff_Add::set_dst(::google::protobuf::int32 value) {
  
  dst_ = value;
  // @@protoc_insertion_point(field_set:fast.Delta.Diff.Add.dst)
}

// int32 position = 3;
inline void Delta_Diff_Add::clear_position() {
  position_ = 0;
}
inline ::google::protobuf::int32 Delta_Diff_Add::position() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.Add.position)
  return position_;
}
inline void Delta_Diff_Add::set_position(::google::protobuf::int32 value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:fast.Delta.Diff.Add.position)
}

// -------------------------------------------------------------------

// Delta_Diff_Del

// int32 src = 1;
inline void Delta_Diff_Del::clear_src() {
  src_ = 0;
}
inline ::google::protobuf::int32 Delta_Diff_Del::src() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.Del.src)
  return src_;
}
inline void Delta_Diff_Del::set_src(::google::protobuf::int32 value) {
  
  src_ = value;
  // @@protoc_insertion_point(field_set:fast.Delta.Diff.Del.src)
}

// -------------------------------------------------------------------

// Delta_Diff_Move

// int32 src = 1;
inline void Delta_Diff_Move::clear_src() {
  src_ = 0;
}
inline ::google::protobuf::int32 Delta_Diff_Move::src() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.Move.src)
  return src_;
}
inline void Delta_Diff_Move::set_src(::google::protobuf::int32 value) {
  
  src_ = value;
  // @@protoc_insertion_point(field_set:fast.Delta.Diff.Move.src)
}

// int32 dst = 2;
inline void Delta_Diff_Move::clear_dst() {
  dst_ = 0;
}
inline ::google::protobuf::int32 Delta_Diff_Move::dst() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.Move.dst)
  return dst_;
}
inline void Delta_Diff_Move::set_dst(::google::protobuf::int32 value) {
  
  dst_ = value;
  // @@protoc_insertion_point(field_set:fast.Delta.Diff.Move.dst)
}

// int32 position = 3;
inline void Delta_Diff_Move::clear_position() {
  position_ = 0;
}
inline ::google::protobuf::int32 Delta_Diff_Move::position() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.Move.position)
  return position_;
}
inline void Delta_Diff_Move::set_position(::google::protobuf::int32 value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:fast.Delta.Diff.Move.position)
}

// -------------------------------------------------------------------

// Delta_Diff_Update

// int32 src = 1;
inline void Delta_Diff_Update::clear_src() {
  src_ = 0;
}
inline ::google::protobuf::int32 Delta_Diff_Update::src() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.Update.src)
  return src_;
}
inline void Delta_Diff_Update::set_src(::google::protobuf::int32 value) {
  
  src_ = value;
  // @@protoc_insertion_point(field_set:fast.Delta.Diff.Update.src)
}

// string label = 2;
inline void Delta_Diff_Update::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Delta_Diff_Update::label() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.Update.label)
  return label_.GetNoArena();
}
inline void Delta_Diff_Update::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Delta.Diff.Update.label)
}
#if LANG_CXX11
inline void Delta_Diff_Update::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Delta.Diff.Update.label)
}
#endif
inline void Delta_Diff_Update::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Delta.Diff.Update.label)
}
inline void Delta_Diff_Update::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Delta.Diff.Update.label)
}
inline ::std::string* Delta_Diff_Update::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:fast.Delta.Diff.Update.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Delta_Diff_Update::release_label() {
  // @@protoc_insertion_point(field_release:fast.Delta.Diff.Update.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Delta_Diff_Update::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:fast.Delta.Diff.Update.label)
}

// -------------------------------------------------------------------

// Delta_Diff

// .fast.Delta.Diff.DeltaType type = 1;
inline void Delta_Diff::clear_type() {
  type_ = 0;
}
inline ::fast::Delta_Diff_DeltaType Delta_Diff::type() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.type)
  return static_cast< ::fast::Delta_Diff_DeltaType >(type_);
}
inline void Delta_Diff::set_type(::fast::Delta_Diff_DeltaType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:fast.Delta.Diff.type)
}

// .fast.Delta.Diff.Match match = 2;
inline bool Delta_Diff::has_match() const {
  return delta_case() == kMatch;
}
inline void Delta_Diff::set_has_match() {
  _oneof_case_[0] = kMatch;
}
inline void Delta_Diff::clear_match() {
  if (has_match()) {
    delete delta_.match_;
    clear_has_delta();
  }
}
inline  const ::fast::Delta_Diff_Match& Delta_Diff::match() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.match)
  return has_match()
      ? *delta_.match_
      : ::fast::Delta_Diff_Match::default_instance();
}
inline ::fast::Delta_Diff_Match* Delta_Diff::mutable_match() {
  if (!has_match()) {
    clear_delta();
    set_has_match();
    delta_.match_ = new ::fast::Delta_Diff_Match;
  }
  // @@protoc_insertion_point(field_mutable:fast.Delta.Diff.match)
  return delta_.match_;
}
inline ::fast::Delta_Diff_Match* Delta_Diff::release_match() {
  // @@protoc_insertion_point(field_release:fast.Delta.Diff.match)
  if (has_match()) {
    clear_has_delta();
    ::fast::Delta_Diff_Match* temp = delta_.match_;
    delta_.match_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Delta_Diff::set_allocated_match(::fast::Delta_Diff_Match* match) {
  clear_delta();
  if (match) {
    set_has_match();
    delta_.match_ = match;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Delta.Diff.match)
}

// .fast.Delta.Diff.Add add = 3;
inline bool Delta_Diff::has_add() const {
  return delta_case() == kAdd;
}
inline void Delta_Diff::set_has_add() {
  _oneof_case_[0] = kAdd;
}
inline void Delta_Diff::clear_add() {
  if (has_add()) {
    delete delta_.add_;
    clear_has_delta();
  }
}
inline  const ::fast::Delta_Diff_Add& Delta_Diff::add() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.add)
  return has_add()
      ? *delta_.add_
      : ::fast::Delta_Diff_Add::default_instance();
}
inline ::fast::Delta_Diff_Add* Delta_Diff::mutable_add() {
  if (!has_add()) {
    clear_delta();
    set_has_add();
    delta_.add_ = new ::fast::Delta_Diff_Add;
  }
  // @@protoc_insertion_point(field_mutable:fast.Delta.Diff.add)
  return delta_.add_;
}
inline ::fast::Delta_Diff_Add* Delta_Diff::release_add() {
  // @@protoc_insertion_point(field_release:fast.Delta.Diff.add)
  if (has_add()) {
    clear_has_delta();
    ::fast::Delta_Diff_Add* temp = delta_.add_;
    delta_.add_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Delta_Diff::set_allocated_add(::fast::Delta_Diff_Add* add) {
  clear_delta();
  if (add) {
    set_has_add();
    delta_.add_ = add;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Delta.Diff.add)
}

// .fast.Delta.Diff.Del del = 4;
inline bool Delta_Diff::has_del() const {
  return delta_case() == kDel;
}
inline void Delta_Diff::set_has_del() {
  _oneof_case_[0] = kDel;
}
inline void Delta_Diff::clear_del() {
  if (has_del()) {
    delete delta_.del_;
    clear_has_delta();
  }
}
inline  const ::fast::Delta_Diff_Del& Delta_Diff::del() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.del)
  return has_del()
      ? *delta_.del_
      : ::fast::Delta_Diff_Del::default_instance();
}
inline ::fast::Delta_Diff_Del* Delta_Diff::mutable_del() {
  if (!has_del()) {
    clear_delta();
    set_has_del();
    delta_.del_ = new ::fast::Delta_Diff_Del;
  }
  // @@protoc_insertion_point(field_mutable:fast.Delta.Diff.del)
  return delta_.del_;
}
inline ::fast::Delta_Diff_Del* Delta_Diff::release_del() {
  // @@protoc_insertion_point(field_release:fast.Delta.Diff.del)
  if (has_del()) {
    clear_has_delta();
    ::fast::Delta_Diff_Del* temp = delta_.del_;
    delta_.del_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Delta_Diff::set_allocated_del(::fast::Delta_Diff_Del* del) {
  clear_delta();
  if (del) {
    set_has_del();
    delta_.del_ = del;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Delta.Diff.del)
}

// .fast.Delta.Diff.Move move = 5;
inline bool Delta_Diff::has_move() const {
  return delta_case() == kMove;
}
inline void Delta_Diff::set_has_move() {
  _oneof_case_[0] = kMove;
}
inline void Delta_Diff::clear_move() {
  if (has_move()) {
    delete delta_.move_;
    clear_has_delta();
  }
}
inline  const ::fast::Delta_Diff_Move& Delta_Diff::move() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.move)
  return has_move()
      ? *delta_.move_
      : ::fast::Delta_Diff_Move::default_instance();
}
inline ::fast::Delta_Diff_Move* Delta_Diff::mutable_move() {
  if (!has_move()) {
    clear_delta();
    set_has_move();
    delta_.move_ = new ::fast::Delta_Diff_Move;
  }
  // @@protoc_insertion_point(field_mutable:fast.Delta.Diff.move)
  return delta_.move_;
}
inline ::fast::Delta_Diff_Move* Delta_Diff::release_move() {
  // @@protoc_insertion_point(field_release:fast.Delta.Diff.move)
  if (has_move()) {
    clear_has_delta();
    ::fast::Delta_Diff_Move* temp = delta_.move_;
    delta_.move_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Delta_Diff::set_allocated_move(::fast::Delta_Diff_Move* move) {
  clear_delta();
  if (move) {
    set_has_move();
    delta_.move_ = move;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Delta.Diff.move)
}

// .fast.Delta.Diff.Update update = 6;
inline bool Delta_Diff::has_update() const {
  return delta_case() == kUpdate;
}
inline void Delta_Diff::set_has_update() {
  _oneof_case_[0] = kUpdate;
}
inline void Delta_Diff::clear_update() {
  if (has_update()) {
    delete delta_.update_;
    clear_has_delta();
  }
}
inline  const ::fast::Delta_Diff_Update& Delta_Diff::update() const {
  // @@protoc_insertion_point(field_get:fast.Delta.Diff.update)
  return has_update()
      ? *delta_.update_
      : ::fast::Delta_Diff_Update::default_instance();
}
inline ::fast::Delta_Diff_Update* Delta_Diff::mutable_update() {
  if (!has_update()) {
    clear_delta();
    set_has_update();
    delta_.update_ = new ::fast::Delta_Diff_Update;
  }
  // @@protoc_insertion_point(field_mutable:fast.Delta.Diff.update)
  return delta_.update_;
}
inline ::fast::Delta_Diff_Update* Delta_Diff::release_update() {
  // @@protoc_insertion_point(field_release:fast.Delta.Diff.update)
  if (has_update()) {
    clear_has_delta();
    ::fast::Delta_Diff_Update* temp = delta_.update_;
    delta_.update_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Delta_Diff::set_allocated_update(::fast::Delta_Diff_Update* update) {
  clear_delta();
  if (update) {
    set_has_update();
    delta_.update_ = update;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Delta.Diff.update)
}

inline bool Delta_Diff::has_delta() const {
  return delta_case() != DELTA_NOT_SET;
}
inline void Delta_Diff::clear_has_delta() {
  _oneof_case_[0] = DELTA_NOT_SET;
}
inline Delta_Diff::DeltaCase Delta_Diff::delta_case() const {
  return Delta_Diff::DeltaCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Delta

// string src = 1;
inline void Delta::clear_src() {
  src_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Delta::src() const {
  // @@protoc_insertion_point(field_get:fast.Delta.src)
  return src_.GetNoArena();
}
inline void Delta::set_src(const ::std::string& value) {
  
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Delta.src)
}
#if LANG_CXX11
inline void Delta::set_src(::std::string&& value) {
  
  src_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Delta.src)
}
#endif
inline void Delta::set_src(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Delta.src)
}
inline void Delta::set_src(const char* value, size_t size) {
  
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Delta.src)
}
inline ::std::string* Delta::mutable_src() {
  
  // @@protoc_insertion_point(field_mutable:fast.Delta.src)
  return src_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Delta::release_src() {
  // @@protoc_insertion_point(field_release:fast.Delta.src)
  
  return src_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Delta::set_allocated_src(::std::string* src) {
  if (src != NULL) {
    
  } else {
    
  }
  src_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src);
  // @@protoc_insertion_point(field_set_allocated:fast.Delta.src)
}

// string dst = 2;
inline void Delta::clear_dst() {
  dst_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Delta::dst() const {
  // @@protoc_insertion_point(field_get:fast.Delta.dst)
  return dst_.GetNoArena();
}
inline void Delta::set_dst(const ::std::string& value) {
  
  dst_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Delta.dst)
}
#if LANG_CXX11
inline void Delta::set_dst(::std::string&& value) {
  
  dst_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Delta.dst)
}
#endif
inline void Delta::set_dst(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dst_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Delta.dst)
}
inline void Delta::set_dst(const char* value, size_t size) {
  
  dst_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Delta.dst)
}
inline ::std::string* Delta::mutable_dst() {
  
  // @@protoc_insertion_point(field_mutable:fast.Delta.dst)
  return dst_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Delta::release_dst() {
  // @@protoc_insertion_point(field_release:fast.Delta.dst)
  
  return dst_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Delta::set_allocated_dst(::std::string* dst) {
  if (dst != NULL) {
    
  } else {
    
  }
  dst_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dst);
  // @@protoc_insertion_point(field_set_allocated:fast.Delta.dst)
}

// repeated .fast.Delta.Diff diff = 3;
inline int Delta::diff_size() const {
  return diff_.size();
}
inline void Delta::clear_diff() {
  diff_.Clear();
}
inline const ::fast::Delta_Diff& Delta::diff(int index) const {
  // @@protoc_insertion_point(field_get:fast.Delta.diff)
  return diff_.Get(index);
}
inline ::fast::Delta_Diff* Delta::mutable_diff(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Delta.diff)
  return diff_.Mutable(index);
}
inline ::fast::Delta_Diff* Delta::add_diff() {
  // @@protoc_insertion_point(field_add:fast.Delta.diff)
  return diff_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Delta_Diff >*
Delta::mutable_diff() {
  // @@protoc_insertion_point(field_mutable_list:fast.Delta.diff)
  return &diff_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Delta_Diff >&
Delta::diff() const {
  // @@protoc_insertion_point(field_list:fast.Delta.diff)
  return diff_;
}

// -------------------------------------------------------------------

// Pairs_Pair_Diff

// int32 left_line = 1;
inline void Pairs_Pair_Diff::clear_left_line() {
  left_line_ = 0;
}
inline ::google::protobuf::int32 Pairs_Pair_Diff::left_line() const {
  // @@protoc_insertion_point(field_get:fast.Pairs.Pair.Diff.left_line)
  return left_line_;
}
inline void Pairs_Pair_Diff::set_left_line(::google::protobuf::int32 value) {
  
  left_line_ = value;
  // @@protoc_insertion_point(field_set:fast.Pairs.Pair.Diff.left_line)
}

// int32 left_column = 2;
inline void Pairs_Pair_Diff::clear_left_column() {
  left_column_ = 0;
}
inline ::google::protobuf::int32 Pairs_Pair_Diff::left_column() const {
  // @@protoc_insertion_point(field_get:fast.Pairs.Pair.Diff.left_column)
  return left_column_;
}
inline void Pairs_Pair_Diff::set_left_column(::google::protobuf::int32 value) {
  
  left_column_ = value;
  // @@protoc_insertion_point(field_set:fast.Pairs.Pair.Diff.left_column)
}

// int32 right_line = 3;
inline void Pairs_Pair_Diff::clear_right_line() {
  right_line_ = 0;
}
inline ::google::protobuf::int32 Pairs_Pair_Diff::right_line() const {
  // @@protoc_insertion_point(field_get:fast.Pairs.Pair.Diff.right_line)
  return right_line_;
}
inline void Pairs_Pair_Diff::set_right_line(::google::protobuf::int32 value) {
  
  right_line_ = value;
  // @@protoc_insertion_point(field_set:fast.Pairs.Pair.Diff.right_line)
}

// int32 right_column = 4;
inline void Pairs_Pair_Diff::clear_right_column() {
  right_column_ = 0;
}
inline ::google::protobuf::int32 Pairs_Pair_Diff::right_column() const {
  // @@protoc_insertion_point(field_get:fast.Pairs.Pair.Diff.right_column)
  return right_column_;
}
inline void Pairs_Pair_Diff::set_right_column(::google::protobuf::int32 value) {
  
  right_column_ = value;
  // @@protoc_insertion_point(field_set:fast.Pairs.Pair.Diff.right_column)
}

// .fast.Element old_code = 5;
inline bool Pairs_Pair_Diff::has_old_code() const {
  return this != internal_default_instance() && old_code_ != NULL;
}
inline void Pairs_Pair_Diff::clear_old_code() {
  if (GetArenaNoVirtual() == NULL && old_code_ != NULL) delete old_code_;
  old_code_ = NULL;
}
inline const ::fast::Element& Pairs_Pair_Diff::old_code() const {
  // @@protoc_insertion_point(field_get:fast.Pairs.Pair.Diff.old_code)
  return old_code_ != NULL ? *old_code_
                         : *::fast::Element::internal_default_instance();
}
inline ::fast::Element* Pairs_Pair_Diff::mutable_old_code() {
  
  if (old_code_ == NULL) {
    old_code_ = new ::fast::Element;
  }
  // @@protoc_insertion_point(field_mutable:fast.Pairs.Pair.Diff.old_code)
  return old_code_;
}
inline ::fast::Element* Pairs_Pair_Diff::release_old_code() {
  // @@protoc_insertion_point(field_release:fast.Pairs.Pair.Diff.old_code)
  
  ::fast::Element* temp = old_code_;
  old_code_ = NULL;
  return temp;
}
inline void Pairs_Pair_Diff::set_allocated_old_code(::fast::Element* old_code) {
  delete old_code_;
  old_code_ = old_code;
  if (old_code) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Pairs.Pair.Diff.old_code)
}

// .fast.Element new_code = 6;
inline bool Pairs_Pair_Diff::has_new_code() const {
  return this != internal_default_instance() && new_code_ != NULL;
}
inline void Pairs_Pair_Diff::clear_new_code() {
  if (GetArenaNoVirtual() == NULL && new_code_ != NULL) delete new_code_;
  new_code_ = NULL;
}
inline const ::fast::Element& Pairs_Pair_Diff::new_code() const {
  // @@protoc_insertion_point(field_get:fast.Pairs.Pair.Diff.new_code)
  return new_code_ != NULL ? *new_code_
                         : *::fast::Element::internal_default_instance();
}
inline ::fast::Element* Pairs_Pair_Diff::mutable_new_code() {
  
  if (new_code_ == NULL) {
    new_code_ = new ::fast::Element;
  }
  // @@protoc_insertion_point(field_mutable:fast.Pairs.Pair.Diff.new_code)
  return new_code_;
}
inline ::fast::Element* Pairs_Pair_Diff::release_new_code() {
  // @@protoc_insertion_point(field_release:fast.Pairs.Pair.Diff.new_code)
  
  ::fast::Element* temp = new_code_;
  new_code_ = NULL;
  return temp;
}
inline void Pairs_Pair_Diff::set_allocated_new_code(::fast::Element* new_code) {
  delete new_code_;
  new_code_ = new_code;
  if (new_code) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Pairs.Pair.Diff.new_code)
}

// string hash = 7;
inline void Pairs_Pair_Diff::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Pairs_Pair_Diff::hash() const {
  // @@protoc_insertion_point(field_get:fast.Pairs.Pair.Diff.hash)
  return hash_.GetNoArena();
}
inline void Pairs_Pair_Diff::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Pairs.Pair.Diff.hash)
}
#if LANG_CXX11
inline void Pairs_Pair_Diff::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Pairs.Pair.Diff.hash)
}
#endif
inline void Pairs_Pair_Diff::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Pairs.Pair.Diff.hash)
}
inline void Pairs_Pair_Diff::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Pairs.Pair.Diff.hash)
}
inline ::std::string* Pairs_Pair_Diff::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:fast.Pairs.Pair.Diff.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Pairs_Pair_Diff::release_hash() {
  // @@protoc_insertion_point(field_release:fast.Pairs.Pair.Diff.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Pairs_Pair_Diff::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:fast.Pairs.Pair.Diff.hash)
}

// -------------------------------------------------------------------

// Pairs_Pair

// string project = 1;
inline void Pairs_Pair::clear_project() {
  project_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Pairs_Pair::project() const {
  // @@protoc_insertion_point(field_get:fast.Pairs.Pair.project)
  return project_.GetNoArena();
}
inline void Pairs_Pair::set_project(const ::std::string& value) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Pairs.Pair.project)
}
#if LANG_CXX11
inline void Pairs_Pair::set_project(::std::string&& value) {
  
  project_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Pairs.Pair.project)
}
#endif
inline void Pairs_Pair::set_project(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Pairs.Pair.project)
}
inline void Pairs_Pair::set_project(const char* value, size_t size) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Pairs.Pair.project)
}
inline ::std::string* Pairs_Pair::mutable_project() {
  
  // @@protoc_insertion_point(field_mutable:fast.Pairs.Pair.project)
  return project_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Pairs_Pair::release_project() {
  // @@protoc_insertion_point(field_release:fast.Pairs.Pair.project)
  
  return project_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Pairs_Pair::set_allocated_project(::std::string* project) {
  if (project != NULL) {
    
  } else {
    
  }
  project_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), project);
  // @@protoc_insertion_point(field_set_allocated:fast.Pairs.Pair.project)
}

// .fast.Pairs.Pair.Diff left = 2;
inline bool Pairs_Pair::has_left() const {
  return this != internal_default_instance() && left_ != NULL;
}
inline void Pairs_Pair::clear_left() {
  if (GetArenaNoVirtual() == NULL && left_ != NULL) delete left_;
  left_ = NULL;
}
inline const ::fast::Pairs_Pair_Diff& Pairs_Pair::left() const {
  // @@protoc_insertion_point(field_get:fast.Pairs.Pair.left)
  return left_ != NULL ? *left_
                         : *::fast::Pairs_Pair_Diff::internal_default_instance();
}
inline ::fast::Pairs_Pair_Diff* Pairs_Pair::mutable_left() {
  
  if (left_ == NULL) {
    left_ = new ::fast::Pairs_Pair_Diff;
  }
  // @@protoc_insertion_point(field_mutable:fast.Pairs.Pair.left)
  return left_;
}
inline ::fast::Pairs_Pair_Diff* Pairs_Pair::release_left() {
  // @@protoc_insertion_point(field_release:fast.Pairs.Pair.left)
  
  ::fast::Pairs_Pair_Diff* temp = left_;
  left_ = NULL;
  return temp;
}
inline void Pairs_Pair::set_allocated_left(::fast::Pairs_Pair_Diff* left) {
  delete left_;
  left_ = left;
  if (left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Pairs.Pair.left)
}

// .fast.Pairs.Pair.Diff right = 3;
inline bool Pairs_Pair::has_right() const {
  return this != internal_default_instance() && right_ != NULL;
}
inline void Pairs_Pair::clear_right() {
  if (GetArenaNoVirtual() == NULL && right_ != NULL) delete right_;
  right_ = NULL;
}
inline const ::fast::Pairs_Pair_Diff& Pairs_Pair::right() const {
  // @@protoc_insertion_point(field_get:fast.Pairs.Pair.right)
  return right_ != NULL ? *right_
                         : *::fast::Pairs_Pair_Diff::internal_default_instance();
}
inline ::fast::Pairs_Pair_Diff* Pairs_Pair::mutable_right() {
  
  if (right_ == NULL) {
    right_ = new ::fast::Pairs_Pair_Diff;
  }
  // @@protoc_insertion_point(field_mutable:fast.Pairs.Pair.right)
  return right_;
}
inline ::fast::Pairs_Pair_Diff* Pairs_Pair::release_right() {
  // @@protoc_insertion_point(field_release:fast.Pairs.Pair.right)
  
  ::fast::Pairs_Pair_Diff* temp = right_;
  right_ = NULL;
  return temp;
}
inline void Pairs_Pair::set_allocated_right(::fast::Pairs_Pair_Diff* right) {
  delete right_;
  right_ = right;
  if (right) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Pairs.Pair.right)
}

// .fast.Pairs.Pair.CloneType type = 4;
inline void Pairs_Pair::clear_type() {
  type_ = 0;
}
inline ::fast::Pairs_Pair_CloneType Pairs_Pair::type() const {
  // @@protoc_insertion_point(field_get:fast.Pairs.Pair.type)
  return static_cast< ::fast::Pairs_Pair_CloneType >(type_);
}
inline void Pairs_Pair::set_type(::fast::Pairs_Pair_CloneType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:fast.Pairs.Pair.type)
}

// -------------------------------------------------------------------

// Pairs

// repeated .fast.Pairs.Pair pair = 1;
inline int Pairs::pair_size() const {
  return pair_.size();
}
inline void Pairs::clear_pair() {
  pair_.Clear();
}
inline const ::fast::Pairs_Pair& Pairs::pair(int index) const {
  // @@protoc_insertion_point(field_get:fast.Pairs.pair)
  return pair_.Get(index);
}
inline ::fast::Pairs_Pair* Pairs::mutable_pair(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Pairs.pair)
  return pair_.Mutable(index);
}
inline ::fast::Pairs_Pair* Pairs::add_pair() {
  // @@protoc_insertion_point(field_add:fast.Pairs.pair)
  return pair_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Pairs_Pair >*
Pairs::mutable_pair() {
  // @@protoc_insertion_point(field_mutable_list:fast.Pairs.pair)
  return &pair_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Pairs_Pair >&
Pairs::pair() const {
  // @@protoc_insertion_point(field_list:fast.Pairs.pair)
  return pair_;
}

// -------------------------------------------------------------------

// Log_Commit_Committer

// int32 committer_id = 1;
inline void Log_Commit_Committer::clear_committer_id() {
  committer_id_ = 0;
}
inline ::google::protobuf::int32 Log_Commit_Committer::committer_id() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Committer.committer_id)
  return committer_id_;
}
inline void Log_Commit_Committer::set_committer_id(::google::protobuf::int32 value) {
  
  committer_id_ = value;
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Committer.committer_id)
}

// string commit_date = 2;
inline void Log_Commit_Committer::clear_commit_date() {
  commit_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log_Commit_Committer::commit_date() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Committer.commit_date)
  return commit_date_.GetNoArena();
}
inline void Log_Commit_Committer::set_commit_date(const ::std::string& value) {
  
  commit_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Committer.commit_date)
}
#if LANG_CXX11
inline void Log_Commit_Committer::set_commit_date(::std::string&& value) {
  
  commit_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Log.Commit.Committer.commit_date)
}
#endif
inline void Log_Commit_Committer::set_commit_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  commit_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Log.Commit.Committer.commit_date)
}
inline void Log_Commit_Committer::set_commit_date(const char* value, size_t size) {
  
  commit_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Log.Commit.Committer.commit_date)
}
inline ::std::string* Log_Commit_Committer::mutable_commit_date() {
  
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.Committer.commit_date)
  return commit_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Commit_Committer::release_commit_date() {
  // @@protoc_insertion_point(field_release:fast.Log.Commit.Committer.commit_date)
  
  return commit_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Commit_Committer::set_allocated_commit_date(::std::string* commit_date) {
  if (commit_date != NULL) {
    
  } else {
    
  }
  commit_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), commit_date);
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Commit.Committer.commit_date)
}

// -------------------------------------------------------------------

// Log_Commit_Diff_Hunk_ModLine

// bytes line = 1;
inline void Log_Commit_Diff_Hunk_ModLine::clear_line() {
  line_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log_Commit_Diff_Hunk_ModLine::line() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.Hunk.ModLine.line)
  return line_.GetNoArena();
}
inline void Log_Commit_Diff_Hunk_ModLine::set_line(const ::std::string& value) {
  
  line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Diff.Hunk.ModLine.line)
}
#if LANG_CXX11
inline void Log_Commit_Diff_Hunk_ModLine::set_line(::std::string&& value) {
  
  line_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Log.Commit.Diff.Hunk.ModLine.line)
}
#endif
inline void Log_Commit_Diff_Hunk_ModLine::set_line(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Log.Commit.Diff.Hunk.ModLine.line)
}
inline void Log_Commit_Diff_Hunk_ModLine::set_line(const void* value, size_t size) {
  
  line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Log.Commit.Diff.Hunk.ModLine.line)
}
inline ::std::string* Log_Commit_Diff_Hunk_ModLine::mutable_line() {
  
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.Diff.Hunk.ModLine.line)
  return line_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Commit_Diff_Hunk_ModLine::release_line() {
  // @@protoc_insertion_point(field_release:fast.Log.Commit.Diff.Hunk.ModLine.line)
  
  return line_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Commit_Diff_Hunk_ModLine::set_allocated_line(::std::string* line) {
  if (line != NULL) {
    
  } else {
    
  }
  line_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), line);
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Commit.Diff.Hunk.ModLine.line)
}

// bool is_add = 2;
inline void Log_Commit_Diff_Hunk_ModLine::clear_is_add() {
  is_add_ = false;
}
inline bool Log_Commit_Diff_Hunk_ModLine::is_add() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.Hunk.ModLine.is_add)
  return is_add_;
}
inline void Log_Commit_Diff_Hunk_ModLine::set_is_add(bool value) {
  
  is_add_ = value;
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Diff.Hunk.ModLine.is_add)
}

// bool is_del = 3;
inline void Log_Commit_Diff_Hunk_ModLine::clear_is_del() {
  is_del_ = false;
}
inline bool Log_Commit_Diff_Hunk_ModLine::is_del() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.Hunk.ModLine.is_del)
  return is_del_;
}
inline void Log_Commit_Diff_Hunk_ModLine::set_is_del(bool value) {
  
  is_del_ = value;
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Diff.Hunk.ModLine.is_del)
}

// -------------------------------------------------------------------

// Log_Commit_Diff_Hunk

// int32 from_lineno = 1;
inline void Log_Commit_Diff_Hunk::clear_from_lineno() {
  from_lineno_ = 0;
}
inline ::google::protobuf::int32 Log_Commit_Diff_Hunk::from_lineno() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.Hunk.from_lineno)
  return from_lineno_;
}
inline void Log_Commit_Diff_Hunk::set_from_lineno(::google::protobuf::int32 value) {
  
  from_lineno_ = value;
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Diff.Hunk.from_lineno)
}

// int32 from_column = 2;
inline void Log_Commit_Diff_Hunk::clear_from_column() {
  from_column_ = 0;
}
inline ::google::protobuf::int32 Log_Commit_Diff_Hunk::from_column() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.Hunk.from_column)
  return from_column_;
}
inline void Log_Commit_Diff_Hunk::set_from_column(::google::protobuf::int32 value) {
  
  from_column_ = value;
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Diff.Hunk.from_column)
}

// int32 to_lineno = 3;
inline void Log_Commit_Diff_Hunk::clear_to_lineno() {
  to_lineno_ = 0;
}
inline ::google::protobuf::int32 Log_Commit_Diff_Hunk::to_lineno() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.Hunk.to_lineno)
  return to_lineno_;
}
inline void Log_Commit_Diff_Hunk::set_to_lineno(::google::protobuf::int32 value) {
  
  to_lineno_ = value;
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Diff.Hunk.to_lineno)
}

// int32 to_column = 4;
inline void Log_Commit_Diff_Hunk::clear_to_column() {
  to_column_ = 0;
}
inline ::google::protobuf::int32 Log_Commit_Diff_Hunk::to_column() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.Hunk.to_column)
  return to_column_;
}
inline void Log_Commit_Diff_Hunk::set_to_column(::google::protobuf::int32 value) {
  
  to_column_ = value;
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Diff.Hunk.to_column)
}

// string context = 5;
inline void Log_Commit_Diff_Hunk::clear_context() {
  context_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log_Commit_Diff_Hunk::context() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.Hunk.context)
  return context_.GetNoArena();
}
inline void Log_Commit_Diff_Hunk::set_context(const ::std::string& value) {
  
  context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Diff.Hunk.context)
}
#if LANG_CXX11
inline void Log_Commit_Diff_Hunk::set_context(::std::string&& value) {
  
  context_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Log.Commit.Diff.Hunk.context)
}
#endif
inline void Log_Commit_Diff_Hunk::set_context(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Log.Commit.Diff.Hunk.context)
}
inline void Log_Commit_Diff_Hunk::set_context(const char* value, size_t size) {
  
  context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Log.Commit.Diff.Hunk.context)
}
inline ::std::string* Log_Commit_Diff_Hunk::mutable_context() {
  
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.Diff.Hunk.context)
  return context_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Commit_Diff_Hunk::release_context() {
  // @@protoc_insertion_point(field_release:fast.Log.Commit.Diff.Hunk.context)
  
  return context_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Commit_Diff_Hunk::set_allocated_context(::std::string* context) {
  if (context != NULL) {
    
  } else {
    
  }
  context_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), context);
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Commit.Diff.Hunk.context)
}

// repeated .fast.Element element = 6;
inline int Log_Commit_Diff_Hunk::element_size() const {
  return element_.size();
}
inline void Log_Commit_Diff_Hunk::clear_element() {
  element_.Clear();
}
inline const ::fast::Element& Log_Commit_Diff_Hunk::element(int index) const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.Hunk.element)
  return element_.Get(index);
}
inline ::fast::Element* Log_Commit_Diff_Hunk::mutable_element(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.Diff.Hunk.element)
  return element_.Mutable(index);
}
inline ::fast::Element* Log_Commit_Diff_Hunk::add_element() {
  // @@protoc_insertion_point(field_add:fast.Log.Commit.Diff.Hunk.element)
  return element_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Element >*
Log_Commit_Diff_Hunk::mutable_element() {
  // @@protoc_insertion_point(field_mutable_list:fast.Log.Commit.Diff.Hunk.element)
  return &element_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Element >&
Log_Commit_Diff_Hunk::element() const {
  // @@protoc_insertion_point(field_list:fast.Log.Commit.Diff.Hunk.element)
  return element_;
}

// repeated .fast.Log.Commit.Diff.Hunk.ModLine mod = 7;
inline int Log_Commit_Diff_Hunk::mod_size() const {
  return mod_.size();
}
inline void Log_Commit_Diff_Hunk::clear_mod() {
  mod_.Clear();
}
inline const ::fast::Log_Commit_Diff_Hunk_ModLine& Log_Commit_Diff_Hunk::mod(int index) const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.Hunk.mod)
  return mod_.Get(index);
}
inline ::fast::Log_Commit_Diff_Hunk_ModLine* Log_Commit_Diff_Hunk::mutable_mod(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.Diff.Hunk.mod)
  return mod_.Mutable(index);
}
inline ::fast::Log_Commit_Diff_Hunk_ModLine* Log_Commit_Diff_Hunk::add_mod() {
  // @@protoc_insertion_point(field_add:fast.Log.Commit.Diff.Hunk.mod)
  return mod_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit_Diff_Hunk_ModLine >*
Log_Commit_Diff_Hunk::mutable_mod() {
  // @@protoc_insertion_point(field_mutable_list:fast.Log.Commit.Diff.Hunk.mod)
  return &mod_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit_Diff_Hunk_ModLine >&
Log_Commit_Diff_Hunk::mod() const {
  // @@protoc_insertion_point(field_list:fast.Log.Commit.Diff.Hunk.mod)
  return mod_;
}

// .fast.Slices slice = 8;
inline bool Log_Commit_Diff_Hunk::has_slice() const {
  return this != internal_default_instance() && slice_ != NULL;
}
inline void Log_Commit_Diff_Hunk::clear_slice() {
  if (GetArenaNoVirtual() == NULL && slice_ != NULL) delete slice_;
  slice_ = NULL;
}
inline const ::fast::Slices& Log_Commit_Diff_Hunk::slice() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.Hunk.slice)
  return slice_ != NULL ? *slice_
                         : *::fast::Slices::internal_default_instance();
}
inline ::fast::Slices* Log_Commit_Diff_Hunk::mutable_slice() {
  
  if (slice_ == NULL) {
    slice_ = new ::fast::Slices;
  }
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.Diff.Hunk.slice)
  return slice_;
}
inline ::fast::Slices* Log_Commit_Diff_Hunk::release_slice() {
  // @@protoc_insertion_point(field_release:fast.Log.Commit.Diff.Hunk.slice)
  
  ::fast::Slices* temp = slice_;
  slice_ = NULL;
  return temp;
}
inline void Log_Commit_Diff_Hunk::set_allocated_slice(::fast::Slices* slice) {
  delete slice_;
  slice_ = slice;
  if (slice) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Commit.Diff.Hunk.slice)
}

// -------------------------------------------------------------------

// Log_Commit_Diff

// string a = 1;
inline void Log_Commit_Diff::clear_a() {
  a_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log_Commit_Diff::a() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.a)
  return a_.GetNoArena();
}
inline void Log_Commit_Diff::set_a(const ::std::string& value) {
  
  a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Diff.a)
}
#if LANG_CXX11
inline void Log_Commit_Diff::set_a(::std::string&& value) {
  
  a_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Log.Commit.Diff.a)
}
#endif
inline void Log_Commit_Diff::set_a(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Log.Commit.Diff.a)
}
inline void Log_Commit_Diff::set_a(const char* value, size_t size) {
  
  a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Log.Commit.Diff.a)
}
inline ::std::string* Log_Commit_Diff::mutable_a() {
  
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.Diff.a)
  return a_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Commit_Diff::release_a() {
  // @@protoc_insertion_point(field_release:fast.Log.Commit.Diff.a)
  
  return a_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Commit_Diff::set_allocated_a(::std::string* a) {
  if (a != NULL) {
    
  } else {
    
  }
  a_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), a);
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Commit.Diff.a)
}

// string b = 2;
inline void Log_Commit_Diff::clear_b() {
  b_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log_Commit_Diff::b() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.b)
  return b_.GetNoArena();
}
inline void Log_Commit_Diff::set_b(const ::std::string& value) {
  
  b_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Diff.b)
}
#if LANG_CXX11
inline void Log_Commit_Diff::set_b(::std::string&& value) {
  
  b_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Log.Commit.Diff.b)
}
#endif
inline void Log_Commit_Diff::set_b(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  b_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Log.Commit.Diff.b)
}
inline void Log_Commit_Diff::set_b(const char* value, size_t size) {
  
  b_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Log.Commit.Diff.b)
}
inline ::std::string* Log_Commit_Diff::mutable_b() {
  
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.Diff.b)
  return b_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Commit_Diff::release_b() {
  // @@protoc_insertion_point(field_release:fast.Log.Commit.Diff.b)
  
  return b_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Commit_Diff::set_allocated_b(::std::string* b) {
  if (b != NULL) {
    
  } else {
    
  }
  b_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), b);
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Commit.Diff.b)
}

// bool is_new = 3;
inline void Log_Commit_Diff::clear_is_new() {
  is_new_ = false;
}
inline bool Log_Commit_Diff::is_new() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.is_new)
  return is_new_;
}
inline void Log_Commit_Diff::set_is_new(bool value) {
  
  is_new_ = value;
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Diff.is_new)
}

// string is_code = 4;
inline void Log_Commit_Diff::clear_is_code() {
  is_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log_Commit_Diff::is_code() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.is_code)
  return is_code_.GetNoArena();
}
inline void Log_Commit_Diff::set_is_code(const ::std::string& value) {
  
  is_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Diff.is_code)
}
#if LANG_CXX11
inline void Log_Commit_Diff::set_is_code(::std::string&& value) {
  
  is_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Log.Commit.Diff.is_code)
}
#endif
inline void Log_Commit_Diff::set_is_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  is_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Log.Commit.Diff.is_code)
}
inline void Log_Commit_Diff::set_is_code(const char* value, size_t size) {
  
  is_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Log.Commit.Diff.is_code)
}
inline ::std::string* Log_Commit_Diff::mutable_is_code() {
  
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.Diff.is_code)
  return is_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Commit_Diff::release_is_code() {
  // @@protoc_insertion_point(field_release:fast.Log.Commit.Diff.is_code)
  
  return is_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Commit_Diff::set_allocated_is_code(::std::string* is_code) {
  if (is_code != NULL) {
    
  } else {
    
  }
  is_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), is_code);
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Commit.Diff.is_code)
}

// string index_from = 5;
inline void Log_Commit_Diff::clear_index_from() {
  index_from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log_Commit_Diff::index_from() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.index_from)
  return index_from_.GetNoArena();
}
inline void Log_Commit_Diff::set_index_from(const ::std::string& value) {
  
  index_from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Diff.index_from)
}
#if LANG_CXX11
inline void Log_Commit_Diff::set_index_from(::std::string&& value) {
  
  index_from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Log.Commit.Diff.index_from)
}
#endif
inline void Log_Commit_Diff::set_index_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  index_from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Log.Commit.Diff.index_from)
}
inline void Log_Commit_Diff::set_index_from(const char* value, size_t size) {
  
  index_from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Log.Commit.Diff.index_from)
}
inline ::std::string* Log_Commit_Diff::mutable_index_from() {
  
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.Diff.index_from)
  return index_from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Commit_Diff::release_index_from() {
  // @@protoc_insertion_point(field_release:fast.Log.Commit.Diff.index_from)
  
  return index_from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Commit_Diff::set_allocated_index_from(::std::string* index_from) {
  if (index_from != NULL) {
    
  } else {
    
  }
  index_from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), index_from);
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Commit.Diff.index_from)
}

// string index_to = 6;
inline void Log_Commit_Diff::clear_index_to() {
  index_to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log_Commit_Diff::index_to() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.index_to)
  return index_to_.GetNoArena();
}
inline void Log_Commit_Diff::set_index_to(const ::std::string& value) {
  
  index_to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Diff.index_to)
}
#if LANG_CXX11
inline void Log_Commit_Diff::set_index_to(::std::string&& value) {
  
  index_to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Log.Commit.Diff.index_to)
}
#endif
inline void Log_Commit_Diff::set_index_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  index_to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Log.Commit.Diff.index_to)
}
inline void Log_Commit_Diff::set_index_to(const char* value, size_t size) {
  
  index_to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Log.Commit.Diff.index_to)
}
inline ::std::string* Log_Commit_Diff::mutable_index_to() {
  
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.Diff.index_to)
  return index_to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Commit_Diff::release_index_to() {
  // @@protoc_insertion_point(field_release:fast.Log.Commit.Diff.index_to)
  
  return index_to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Commit_Diff::set_allocated_index_to(::std::string* index_to) {
  if (index_to != NULL) {
    
  } else {
    
  }
  index_to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), index_to);
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Commit.Diff.index_to)
}

// string mode = 7;
inline void Log_Commit_Diff::clear_mode() {
  mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log_Commit_Diff::mode() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.mode)
  return mode_.GetNoArena();
}
inline void Log_Commit_Diff::set_mode(const ::std::string& value) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Log.Commit.Diff.mode)
}
#if LANG_CXX11
inline void Log_Commit_Diff::set_mode(::std::string&& value) {
  
  mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Log.Commit.Diff.mode)
}
#endif
inline void Log_Commit_Diff::set_mode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Log.Commit.Diff.mode)
}
inline void Log_Commit_Diff::set_mode(const char* value, size_t size) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Log.Commit.Diff.mode)
}
inline ::std::string* Log_Commit_Diff::mutable_mode() {
  
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.Diff.mode)
  return mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Commit_Diff::release_mode() {
  // @@protoc_insertion_point(field_release:fast.Log.Commit.Diff.mode)
  
  return mode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Commit_Diff::set_allocated_mode(::std::string* mode) {
  if (mode != NULL) {
    
  } else {
    
  }
  mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mode);
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Commit.Diff.mode)
}

// repeated .fast.Log.Commit.Diff.Hunk hunk = 8;
inline int Log_Commit_Diff::hunk_size() const {
  return hunk_.size();
}
inline void Log_Commit_Diff::clear_hunk() {
  hunk_.Clear();
}
inline const ::fast::Log_Commit_Diff_Hunk& Log_Commit_Diff::hunk(int index) const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.Diff.hunk)
  return hunk_.Get(index);
}
inline ::fast::Log_Commit_Diff_Hunk* Log_Commit_Diff::mutable_hunk(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.Diff.hunk)
  return hunk_.Mutable(index);
}
inline ::fast::Log_Commit_Diff_Hunk* Log_Commit_Diff::add_hunk() {
  // @@protoc_insertion_point(field_add:fast.Log.Commit.Diff.hunk)
  return hunk_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit_Diff_Hunk >*
Log_Commit_Diff::mutable_hunk() {
  // @@protoc_insertion_point(field_mutable_list:fast.Log.Commit.Diff.hunk)
  return &hunk_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit_Diff_Hunk >&
Log_Commit_Diff::hunk() const {
  // @@protoc_insertion_point(field_list:fast.Log.Commit.Diff.hunk)
  return hunk_;
}

// -------------------------------------------------------------------

// Log_Commit

// string id = 1;
inline void Log_Commit::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log_Commit::id() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.id)
  return id_.GetNoArena();
}
inline void Log_Commit::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Log.Commit.id)
}
#if LANG_CXX11
inline void Log_Commit::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Log.Commit.id)
}
#endif
inline void Log_Commit::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Log.Commit.id)
}
inline void Log_Commit::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Log.Commit.id)
}
inline ::std::string* Log_Commit::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Commit::release_id() {
  // @@protoc_insertion_point(field_release:fast.Log.Commit.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Commit::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Commit.id)
}

// bytes text = 2;
inline void Log_Commit::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log_Commit::text() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.text)
  return text_.GetNoArena();
}
inline void Log_Commit::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Log.Commit.text)
}
#if LANG_CXX11
inline void Log_Commit::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Log.Commit.text)
}
#endif
inline void Log_Commit::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Log.Commit.text)
}
inline void Log_Commit::set_text(const void* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Log.Commit.text)
}
inline ::std::string* Log_Commit::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Commit::release_text() {
  // @@protoc_insertion_point(field_release:fast.Log.Commit.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Commit::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Commit.text)
}

// int32 author_id = 3;
inline void Log_Commit::clear_author_id() {
  author_id_ = 0;
}
inline ::google::protobuf::int32 Log_Commit::author_id() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.author_id)
  return author_id_;
}
inline void Log_Commit::set_author_id(::google::protobuf::int32 value) {
  
  author_id_ = value;
  // @@protoc_insertion_point(field_set:fast.Log.Commit.author_id)
}

// string author_date = 4;
inline void Log_Commit::clear_author_date() {
  author_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log_Commit::author_date() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.author_date)
  return author_date_.GetNoArena();
}
inline void Log_Commit::set_author_date(const ::std::string& value) {
  
  author_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Log.Commit.author_date)
}
#if LANG_CXX11
inline void Log_Commit::set_author_date(::std::string&& value) {
  
  author_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Log.Commit.author_date)
}
#endif
inline void Log_Commit::set_author_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  author_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Log.Commit.author_date)
}
inline void Log_Commit::set_author_date(const char* value, size_t size) {
  
  author_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Log.Commit.author_date)
}
inline ::std::string* Log_Commit::mutable_author_date() {
  
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.author_date)
  return author_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Commit::release_author_date() {
  // @@protoc_insertion_point(field_release:fast.Log.Commit.author_date)
  
  return author_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Commit::set_allocated_author_date(::std::string* author_date) {
  if (author_date != NULL) {
    
  } else {
    
  }
  author_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), author_date);
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Commit.author_date)
}

// .fast.Log.Commit.Committer committer = 5;
inline bool Log_Commit::has_committer() const {
  return extra_case() == kCommitter;
}
inline void Log_Commit::set_has_committer() {
  _oneof_case_[0] = kCommitter;
}
inline void Log_Commit::clear_committer() {
  if (has_committer()) {
    delete extra_.committer_;
    clear_has_extra();
  }
}
inline  const ::fast::Log_Commit_Committer& Log_Commit::committer() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.committer)
  return has_committer()
      ? *extra_.committer_
      : ::fast::Log_Commit_Committer::default_instance();
}
inline ::fast::Log_Commit_Committer* Log_Commit::mutable_committer() {
  if (!has_committer()) {
    clear_extra();
    set_has_committer();
    extra_.committer_ = new ::fast::Log_Commit_Committer;
  }
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.committer)
  return extra_.committer_;
}
inline ::fast::Log_Commit_Committer* Log_Commit::release_committer() {
  // @@protoc_insertion_point(field_release:fast.Log.Commit.committer)
  if (has_committer()) {
    clear_has_extra();
    ::fast::Log_Commit_Committer* temp = extra_.committer_;
    extra_.committer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Log_Commit::set_allocated_committer(::fast::Log_Commit_Committer* committer) {
  clear_extra();
  if (committer) {
    set_has_committer();
    extra_.committer_ = committer;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Commit.committer)
}

// repeated .fast.Log.Commit.Diff diff = 6;
inline int Log_Commit::diff_size() const {
  return diff_.size();
}
inline void Log_Commit::clear_diff() {
  diff_.Clear();
}
inline const ::fast::Log_Commit_Diff& Log_Commit::diff(int index) const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.diff)
  return diff_.Get(index);
}
inline ::fast::Log_Commit_Diff* Log_Commit::mutable_diff(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.diff)
  return diff_.Mutable(index);
}
inline ::fast::Log_Commit_Diff* Log_Commit::add_diff() {
  // @@protoc_insertion_point(field_add:fast.Log.Commit.diff)
  return diff_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit_Diff >*
Log_Commit::mutable_diff() {
  // @@protoc_insertion_point(field_mutable_list:fast.Log.Commit.diff)
  return &diff_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit_Diff >&
Log_Commit::diff() const {
  // @@protoc_insertion_point(field_list:fast.Log.Commit.diff)
  return diff_;
}

// .fast.Slices slice = 7;
inline bool Log_Commit::has_slice() const {
  return this != internal_default_instance() && slice_ != NULL;
}
inline void Log_Commit::clear_slice() {
  if (GetArenaNoVirtual() == NULL && slice_ != NULL) delete slice_;
  slice_ = NULL;
}
inline const ::fast::Slices& Log_Commit::slice() const {
  // @@protoc_insertion_point(field_get:fast.Log.Commit.slice)
  return slice_ != NULL ? *slice_
                         : *::fast::Slices::internal_default_instance();
}
inline ::fast::Slices* Log_Commit::mutable_slice() {
  
  if (slice_ == NULL) {
    slice_ = new ::fast::Slices;
  }
  // @@protoc_insertion_point(field_mutable:fast.Log.Commit.slice)
  return slice_;
}
inline ::fast::Slices* Log_Commit::release_slice() {
  // @@protoc_insertion_point(field_release:fast.Log.Commit.slice)
  
  ::fast::Slices* temp = slice_;
  slice_ = NULL;
  return temp;
}
inline void Log_Commit::set_allocated_slice(::fast::Slices* slice) {
  delete slice_;
  slice_ = slice;
  if (slice) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Commit.slice)
}

inline bool Log_Commit::has_extra() const {
  return extra_case() != EXTRA_NOT_SET;
}
inline void Log_Commit::clear_has_extra() {
  _oneof_case_[0] = EXTRA_NOT_SET;
}
inline Log_Commit::ExtraCase Log_Commit::extra_case() const {
  return Log_Commit::ExtraCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Log_Author

// int32 id = 1;
inline void Log_Author::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Log_Author::id() const {
  // @@protoc_insertion_point(field_get:fast.Log.Author.id)
  return id_;
}
inline void Log_Author::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:fast.Log.Author.id)
}

// string name = 2;
inline void Log_Author::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log_Author::name() const {
  // @@protoc_insertion_point(field_get:fast.Log.Author.name)
  return name_.GetNoArena();
}
inline void Log_Author::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Log.Author.name)
}
#if LANG_CXX11
inline void Log_Author::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Log.Author.name)
}
#endif
inline void Log_Author::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Log.Author.name)
}
inline void Log_Author::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Log.Author.name)
}
inline ::std::string* Log_Author::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:fast.Log.Author.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Author::release_name() {
  // @@protoc_insertion_point(field_release:fast.Log.Author.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Author::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Author.name)
}

// string email = 3;
inline void Log_Author::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log_Author::email() const {
  // @@protoc_insertion_point(field_get:fast.Log.Author.email)
  return email_.GetNoArena();
}
inline void Log_Author::set_email(const ::std::string& value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Log.Author.email)
}
#if LANG_CXX11
inline void Log_Author::set_email(::std::string&& value) {
  
  email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Log.Author.email)
}
#endif
inline void Log_Author::set_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Log.Author.email)
}
inline void Log_Author::set_email(const char* value, size_t size) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Log.Author.email)
}
inline ::std::string* Log_Author::mutable_email() {
  
  // @@protoc_insertion_point(field_mutable:fast.Log.Author.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Author::release_email() {
  // @@protoc_insertion_point(field_release:fast.Log.Author.email)
  
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Author::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    
  } else {
    
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:fast.Log.Author.email)
}

// -------------------------------------------------------------------

// Log

// repeated .fast.Log.Commit commit = 1;
inline int Log::commit_size() const {
  return commit_.size();
}
inline void Log::clear_commit() {
  commit_.Clear();
}
inline const ::fast::Log_Commit& Log::commit(int index) const {
  // @@protoc_insertion_point(field_get:fast.Log.commit)
  return commit_.Get(index);
}
inline ::fast::Log_Commit* Log::mutable_commit(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Log.commit)
  return commit_.Mutable(index);
}
inline ::fast::Log_Commit* Log::add_commit() {
  // @@protoc_insertion_point(field_add:fast.Log.commit)
  return commit_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit >*
Log::mutable_commit() {
  // @@protoc_insertion_point(field_mutable_list:fast.Log.commit)
  return &commit_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Log_Commit >&
Log::commit() const {
  // @@protoc_insertion_point(field_list:fast.Log.commit)
  return commit_;
}

// repeated .fast.Log.Author author = 2;
inline int Log::author_size() const {
  return author_.size();
}
inline void Log::clear_author() {
  author_.Clear();
}
inline const ::fast::Log_Author& Log::author(int index) const {
  // @@protoc_insertion_point(field_get:fast.Log.author)
  return author_.Get(index);
}
inline ::fast::Log_Author* Log::mutable_author(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Log.author)
  return author_.Mutable(index);
}
inline ::fast::Log_Author* Log::add_author() {
  // @@protoc_insertion_point(field_add:fast.Log.author)
  return author_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Log_Author >*
Log::mutable_author() {
  // @@protoc_insertion_point(field_mutable_list:fast.Log.author)
  return &author_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Log_Author >&
Log::author() const {
  // @@protoc_insertion_point(field_list:fast.Log.author)
  return author_;
}

// -------------------------------------------------------------------

// Slices_Slice_SourceFile_Function_Variable_Position

// int32 lineno = 1;
inline void Slices_Slice_SourceFile_Function_Variable_Position::clear_lineno() {
  lineno_ = 0;
}
inline ::google::protobuf::int32 Slices_Slice_SourceFile_Function_Variable_Position::lineno() const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.Function.Variable.Position.lineno)
  return lineno_;
}
inline void Slices_Slice_SourceFile_Function_Variable_Position::set_lineno(::google::protobuf::int32 value) {
  
  lineno_ = value;
  // @@protoc_insertion_point(field_set:fast.Slices.Slice.SourceFile.Function.Variable.Position.lineno)
}

// .fast.Slices.Slice.ChangeType type = 2;
inline void Slices_Slice_SourceFile_Function_Variable_Position::clear_type() {
  type_ = 0;
}
inline ::fast::Slices_Slice_ChangeType Slices_Slice_SourceFile_Function_Variable_Position::type() const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.Function.Variable.Position.type)
  return static_cast< ::fast::Slices_Slice_ChangeType >(type_);
}
inline void Slices_Slice_SourceFile_Function_Variable_Position::set_type(::fast::Slices_Slice_ChangeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:fast.Slices.Slice.SourceFile.Function.Variable.Position.type)
}

// int32 delta_lineno = 5;
inline void Slices_Slice_SourceFile_Function_Variable_Position::clear_delta_lineno() {
  delta_lineno_ = 0;
}
inline ::google::protobuf::int32 Slices_Slice_SourceFile_Function_Variable_Position::delta_lineno() const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.Function.Variable.Position.delta_lineno)
  return delta_lineno_;
}
inline void Slices_Slice_SourceFile_Function_Variable_Position::set_delta_lineno(::google::protobuf::int32 value) {
  
  delta_lineno_ = value;
  // @@protoc_insertion_point(field_set:fast.Slices.Slice.SourceFile.Function.Variable.Position.delta_lineno)
}

// -------------------------------------------------------------------

// Slices_Slice_SourceFile_Function_Variable_FunctionDecl

// string name = 1;
inline void Slices_Slice_SourceFile_Function_Variable_FunctionDecl::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Slices_Slice_SourceFile_Function_Variable_FunctionDecl::name() const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.Function.Variable.FunctionDecl.name)
  return name_.GetNoArena();
}
inline void Slices_Slice_SourceFile_Function_Variable_FunctionDecl::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Slices.Slice.SourceFile.Function.Variable.FunctionDecl.name)
}
#if LANG_CXX11
inline void Slices_Slice_SourceFile_Function_Variable_FunctionDecl::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Slices.Slice.SourceFile.Function.Variable.FunctionDecl.name)
}
#endif
inline void Slices_Slice_SourceFile_Function_Variable_FunctionDecl::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Slices.Slice.SourceFile.Function.Variable.FunctionDecl.name)
}
inline void Slices_Slice_SourceFile_Function_Variable_FunctionDecl::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Slices.Slice.SourceFile.Function.Variable.FunctionDecl.name)
}
inline ::std::string* Slices_Slice_SourceFile_Function_Variable_FunctionDecl::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:fast.Slices.Slice.SourceFile.Function.Variable.FunctionDecl.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Slices_Slice_SourceFile_Function_Variable_FunctionDecl::release_name() {
  // @@protoc_insertion_point(field_release:fast.Slices.Slice.SourceFile.Function.Variable.FunctionDecl.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Slices_Slice_SourceFile_Function_Variable_FunctionDecl::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:fast.Slices.Slice.SourceFile.Function.Variable.FunctionDecl.name)
}

// int32 lineno = 2;
inline void Slices_Slice_SourceFile_Function_Variable_FunctionDecl::clear_lineno() {
  lineno_ = 0;
}
inline ::google::protobuf::int32 Slices_Slice_SourceFile_Function_Variable_FunctionDecl::lineno() const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.Function.Variable.FunctionDecl.lineno)
  return lineno_;
}
inline void Slices_Slice_SourceFile_Function_Variable_FunctionDecl::set_lineno(::google::protobuf::int32 value) {
  
  lineno_ = value;
  // @@protoc_insertion_point(field_set:fast.Slices.Slice.SourceFile.Function.Variable.FunctionDecl.lineno)
}

// -------------------------------------------------------------------

// Slices_Slice_SourceFile_Function_Variable

// string name = 1;
inline void Slices_Slice_SourceFile_Function_Variable::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Slices_Slice_SourceFile_Function_Variable::name() const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.Function.Variable.name)
  return name_.GetNoArena();
}
inline void Slices_Slice_SourceFile_Function_Variable::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Slices.Slice.SourceFile.Function.Variable.name)
}
#if LANG_CXX11
inline void Slices_Slice_SourceFile_Function_Variable::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Slices.Slice.SourceFile.Function.Variable.name)
}
#endif
inline void Slices_Slice_SourceFile_Function_Variable::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Slices.Slice.SourceFile.Function.Variable.name)
}
inline void Slices_Slice_SourceFile_Function_Variable::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Slices.Slice.SourceFile.Function.Variable.name)
}
inline ::std::string* Slices_Slice_SourceFile_Function_Variable::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:fast.Slices.Slice.SourceFile.Function.Variable.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Slices_Slice_SourceFile_Function_Variable::release_name() {
  // @@protoc_insertion_point(field_release:fast.Slices.Slice.SourceFile.Function.Variable.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Slices_Slice_SourceFile_Function_Variable::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:fast.Slices.Slice.SourceFile.Function.Variable.name)
}

// .fast.Slices.Slice.SourceFile.Function.Variable.Position pos = 2;
inline bool Slices_Slice_SourceFile_Function_Variable::has_pos() const {
  return this != internal_default_instance() && pos_ != NULL;
}
inline void Slices_Slice_SourceFile_Function_Variable::clear_pos() {
  if (GetArenaNoVirtual() == NULL && pos_ != NULL) delete pos_;
  pos_ = NULL;
}
inline const ::fast::Slices_Slice_SourceFile_Function_Variable_Position& Slices_Slice_SourceFile_Function_Variable::pos() const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.Function.Variable.pos)
  return pos_ != NULL ? *pos_
                         : *::fast::Slices_Slice_SourceFile_Function_Variable_Position::internal_default_instance();
}
inline ::fast::Slices_Slice_SourceFile_Function_Variable_Position* Slices_Slice_SourceFile_Function_Variable::mutable_pos() {
  
  if (pos_ == NULL) {
    pos_ = new ::fast::Slices_Slice_SourceFile_Function_Variable_Position;
  }
  // @@protoc_insertion_point(field_mutable:fast.Slices.Slice.SourceFile.Function.Variable.pos)
  return pos_;
}
inline ::fast::Slices_Slice_SourceFile_Function_Variable_Position* Slices_Slice_SourceFile_Function_Variable::release_pos() {
  // @@protoc_insertion_point(field_release:fast.Slices.Slice.SourceFile.Function.Variable.pos)
  
  ::fast::Slices_Slice_SourceFile_Function_Variable_Position* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void Slices_Slice_SourceFile_Function_Variable::set_allocated_pos(::fast::Slices_Slice_SourceFile_Function_Variable_Position* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Slices.Slice.SourceFile.Function.Variable.pos)
}

// .fast.Slices.Slice.ChangeType type = 3;
inline void Slices_Slice_SourceFile_Function_Variable::clear_type() {
  type_ = 0;
}
inline ::fast::Slices_Slice_ChangeType Slices_Slice_SourceFile_Function_Variable::type() const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.Function.Variable.type)
  return static_cast< ::fast::Slices_Slice_ChangeType >(type_);
}
inline void Slices_Slice_SourceFile_Function_Variable::set_type(::fast::Slices_Slice_ChangeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:fast.Slices.Slice.SourceFile.Function.Variable.type)
}

// repeated .fast.Slices.Slice.SourceFile.Function.Variable.Position defn = 4;
inline int Slices_Slice_SourceFile_Function_Variable::defn_size() const {
  return defn_.size();
}
inline void Slices_Slice_SourceFile_Function_Variable::clear_defn() {
  defn_.Clear();
}
inline const ::fast::Slices_Slice_SourceFile_Function_Variable_Position& Slices_Slice_SourceFile_Function_Variable::defn(int index) const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.Function.Variable.defn)
  return defn_.Get(index);
}
inline ::fast::Slices_Slice_SourceFile_Function_Variable_Position* Slices_Slice_SourceFile_Function_Variable::mutable_defn(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Slices.Slice.SourceFile.Function.Variable.defn)
  return defn_.Mutable(index);
}
inline ::fast::Slices_Slice_SourceFile_Function_Variable_Position* Slices_Slice_SourceFile_Function_Variable::add_defn() {
  // @@protoc_insertion_point(field_add:fast.Slices.Slice.SourceFile.Function.Variable.defn)
  return defn_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable_Position >*
Slices_Slice_SourceFile_Function_Variable::mutable_defn() {
  // @@protoc_insertion_point(field_mutable_list:fast.Slices.Slice.SourceFile.Function.Variable.defn)
  return &defn_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable_Position >&
Slices_Slice_SourceFile_Function_Variable::defn() const {
  // @@protoc_insertion_point(field_list:fast.Slices.Slice.SourceFile.Function.Variable.defn)
  return defn_;
}

// repeated .fast.Slices.Slice.SourceFile.Function.Variable.Position use = 5;
inline int Slices_Slice_SourceFile_Function_Variable::use_size() const {
  return use_.size();
}
inline void Slices_Slice_SourceFile_Function_Variable::clear_use() {
  use_.Clear();
}
inline const ::fast::Slices_Slice_SourceFile_Function_Variable_Position& Slices_Slice_SourceFile_Function_Variable::use(int index) const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.Function.Variable.use)
  return use_.Get(index);
}
inline ::fast::Slices_Slice_SourceFile_Function_Variable_Position* Slices_Slice_SourceFile_Function_Variable::mutable_use(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Slices.Slice.SourceFile.Function.Variable.use)
  return use_.Mutable(index);
}
inline ::fast::Slices_Slice_SourceFile_Function_Variable_Position* Slices_Slice_SourceFile_Function_Variable::add_use() {
  // @@protoc_insertion_point(field_add:fast.Slices.Slice.SourceFile.Function.Variable.use)
  return use_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable_Position >*
Slices_Slice_SourceFile_Function_Variable::mutable_use() {
  // @@protoc_insertion_point(field_mutable_list:fast.Slices.Slice.SourceFile.Function.Variable.use)
  return &use_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable_Position >&
Slices_Slice_SourceFile_Function_Variable::use() const {
  // @@protoc_insertion_point(field_list:fast.Slices.Slice.SourceFile.Function.Variable.use)
  return use_;
}

// repeated string dvar = 6;
inline int Slices_Slice_SourceFile_Function_Variable::dvar_size() const {
  return dvar_.size();
}
inline void Slices_Slice_SourceFile_Function_Variable::clear_dvar() {
  dvar_.Clear();
}
inline const ::std::string& Slices_Slice_SourceFile_Function_Variable::dvar(int index) const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.Function.Variable.dvar)
  return dvar_.Get(index);
}
inline ::std::string* Slices_Slice_SourceFile_Function_Variable::mutable_dvar(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Slices.Slice.SourceFile.Function.Variable.dvar)
  return dvar_.Mutable(index);
}
inline void Slices_Slice_SourceFile_Function_Variable::set_dvar(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:fast.Slices.Slice.SourceFile.Function.Variable.dvar)
  dvar_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Slices_Slice_SourceFile_Function_Variable::set_dvar(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:fast.Slices.Slice.SourceFile.Function.Variable.dvar)
  dvar_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Slices_Slice_SourceFile_Function_Variable::set_dvar(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dvar_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fast.Slices.Slice.SourceFile.Function.Variable.dvar)
}
inline void Slices_Slice_SourceFile_Function_Variable::set_dvar(int index, const char* value, size_t size) {
  dvar_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fast.Slices.Slice.SourceFile.Function.Variable.dvar)
}
inline ::std::string* Slices_Slice_SourceFile_Function_Variable::add_dvar() {
  // @@protoc_insertion_point(field_add_mutable:fast.Slices.Slice.SourceFile.Function.Variable.dvar)
  return dvar_.Add();
}
inline void Slices_Slice_SourceFile_Function_Variable::add_dvar(const ::std::string& value) {
  dvar_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fast.Slices.Slice.SourceFile.Function.Variable.dvar)
}
#if LANG_CXX11
inline void Slices_Slice_SourceFile_Function_Variable::add_dvar(::std::string&& value) {
  dvar_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fast.Slices.Slice.SourceFile.Function.Variable.dvar)
}
#endif
inline void Slices_Slice_SourceFile_Function_Variable::add_dvar(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dvar_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fast.Slices.Slice.SourceFile.Function.Variable.dvar)
}
inline void Slices_Slice_SourceFile_Function_Variable::add_dvar(const char* value, size_t size) {
  dvar_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fast.Slices.Slice.SourceFile.Function.Variable.dvar)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Slices_Slice_SourceFile_Function_Variable::dvar() const {
  // @@protoc_insertion_point(field_list:fast.Slices.Slice.SourceFile.Function.Variable.dvar)
  return dvar_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Slices_Slice_SourceFile_Function_Variable::mutable_dvar() {
  // @@protoc_insertion_point(field_mutable_list:fast.Slices.Slice.SourceFile.Function.Variable.dvar)
  return &dvar_;
}

// repeated string alias = 7;
inline int Slices_Slice_SourceFile_Function_Variable::alias_size() const {
  return alias_.size();
}
inline void Slices_Slice_SourceFile_Function_Variable::clear_alias() {
  alias_.Clear();
}
inline const ::std::string& Slices_Slice_SourceFile_Function_Variable::alias(int index) const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.Function.Variable.alias)
  return alias_.Get(index);
}
inline ::std::string* Slices_Slice_SourceFile_Function_Variable::mutable_alias(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Slices.Slice.SourceFile.Function.Variable.alias)
  return alias_.Mutable(index);
}
inline void Slices_Slice_SourceFile_Function_Variable::set_alias(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:fast.Slices.Slice.SourceFile.Function.Variable.alias)
  alias_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Slices_Slice_SourceFile_Function_Variable::set_alias(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:fast.Slices.Slice.SourceFile.Function.Variable.alias)
  alias_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Slices_Slice_SourceFile_Function_Variable::set_alias(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  alias_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fast.Slices.Slice.SourceFile.Function.Variable.alias)
}
inline void Slices_Slice_SourceFile_Function_Variable::set_alias(int index, const char* value, size_t size) {
  alias_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fast.Slices.Slice.SourceFile.Function.Variable.alias)
}
inline ::std::string* Slices_Slice_SourceFile_Function_Variable::add_alias() {
  // @@protoc_insertion_point(field_add_mutable:fast.Slices.Slice.SourceFile.Function.Variable.alias)
  return alias_.Add();
}
inline void Slices_Slice_SourceFile_Function_Variable::add_alias(const ::std::string& value) {
  alias_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fast.Slices.Slice.SourceFile.Function.Variable.alias)
}
#if LANG_CXX11
inline void Slices_Slice_SourceFile_Function_Variable::add_alias(::std::string&& value) {
  alias_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fast.Slices.Slice.SourceFile.Function.Variable.alias)
}
#endif
inline void Slices_Slice_SourceFile_Function_Variable::add_alias(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  alias_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fast.Slices.Slice.SourceFile.Function.Variable.alias)
}
inline void Slices_Slice_SourceFile_Function_Variable::add_alias(const char* value, size_t size) {
  alias_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fast.Slices.Slice.SourceFile.Function.Variable.alias)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Slices_Slice_SourceFile_Function_Variable::alias() const {
  // @@protoc_insertion_point(field_list:fast.Slices.Slice.SourceFile.Function.Variable.alias)
  return alias_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Slices_Slice_SourceFile_Function_Variable::mutable_alias() {
  // @@protoc_insertion_point(field_mutable_list:fast.Slices.Slice.SourceFile.Function.Variable.alias)
  return &alias_;
}

// repeated .fast.Slices.Slice.SourceFile.Function.Variable.FunctionDecl cfunc = 8;
inline int Slices_Slice_SourceFile_Function_Variable::cfunc_size() const {
  return cfunc_.size();
}
inline void Slices_Slice_SourceFile_Function_Variable::clear_cfunc() {
  cfunc_.Clear();
}
inline const ::fast::Slices_Slice_SourceFile_Function_Variable_FunctionDecl& Slices_Slice_SourceFile_Function_Variable::cfunc(int index) const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.Function.Variable.cfunc)
  return cfunc_.Get(index);
}
inline ::fast::Slices_Slice_SourceFile_Function_Variable_FunctionDecl* Slices_Slice_SourceFile_Function_Variable::mutable_cfunc(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Slices.Slice.SourceFile.Function.Variable.cfunc)
  return cfunc_.Mutable(index);
}
inline ::fast::Slices_Slice_SourceFile_Function_Variable_FunctionDecl* Slices_Slice_SourceFile_Function_Variable::add_cfunc() {
  // @@protoc_insertion_point(field_add:fast.Slices.Slice.SourceFile.Function.Variable.cfunc)
  return cfunc_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable_FunctionDecl >*
Slices_Slice_SourceFile_Function_Variable::mutable_cfunc() {
  // @@protoc_insertion_point(field_mutable_list:fast.Slices.Slice.SourceFile.Function.Variable.cfunc)
  return &cfunc_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable_FunctionDecl >&
Slices_Slice_SourceFile_Function_Variable::cfunc() const {
  // @@protoc_insertion_point(field_list:fast.Slices.Slice.SourceFile.Function.Variable.cfunc)
  return cfunc_;
}

// -------------------------------------------------------------------

// Slices_Slice_SourceFile_Function

// repeated .fast.Slices.Slice.SourceFile.Function.Variable variable = 1;
inline int Slices_Slice_SourceFile_Function::variable_size() const {
  return variable_.size();
}
inline void Slices_Slice_SourceFile_Function::clear_variable() {
  variable_.Clear();
}
inline const ::fast::Slices_Slice_SourceFile_Function_Variable& Slices_Slice_SourceFile_Function::variable(int index) const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.Function.variable)
  return variable_.Get(index);
}
inline ::fast::Slices_Slice_SourceFile_Function_Variable* Slices_Slice_SourceFile_Function::mutable_variable(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Slices.Slice.SourceFile.Function.variable)
  return variable_.Mutable(index);
}
inline ::fast::Slices_Slice_SourceFile_Function_Variable* Slices_Slice_SourceFile_Function::add_variable() {
  // @@protoc_insertion_point(field_add:fast.Slices.Slice.SourceFile.Function.variable)
  return variable_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable >*
Slices_Slice_SourceFile_Function::mutable_variable() {
  // @@protoc_insertion_point(field_mutable_list:fast.Slices.Slice.SourceFile.Function.variable)
  return &variable_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function_Variable >&
Slices_Slice_SourceFile_Function::variable() const {
  // @@protoc_insertion_point(field_list:fast.Slices.Slice.SourceFile.Function.variable)
  return variable_;
}

// string name = 2;
inline void Slices_Slice_SourceFile_Function::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Slices_Slice_SourceFile_Function::name() const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.Function.name)
  return name_.GetNoArena();
}
inline void Slices_Slice_SourceFile_Function::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Slices.Slice.SourceFile.Function.name)
}
#if LANG_CXX11
inline void Slices_Slice_SourceFile_Function::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Slices.Slice.SourceFile.Function.name)
}
#endif
inline void Slices_Slice_SourceFile_Function::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Slices.Slice.SourceFile.Function.name)
}
inline void Slices_Slice_SourceFile_Function::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Slices.Slice.SourceFile.Function.name)
}
inline ::std::string* Slices_Slice_SourceFile_Function::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:fast.Slices.Slice.SourceFile.Function.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Slices_Slice_SourceFile_Function::release_name() {
  // @@protoc_insertion_point(field_release:fast.Slices.Slice.SourceFile.Function.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Slices_Slice_SourceFile_Function::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:fast.Slices.Slice.SourceFile.Function.name)
}

// .fast.Slices.Slice.ChangeType type = 3;
inline void Slices_Slice_SourceFile_Function::clear_type() {
  type_ = 0;
}
inline ::fast::Slices_Slice_ChangeType Slices_Slice_SourceFile_Function::type() const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.Function.type)
  return static_cast< ::fast::Slices_Slice_ChangeType >(type_);
}
inline void Slices_Slice_SourceFile_Function::set_type(::fast::Slices_Slice_ChangeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:fast.Slices.Slice.SourceFile.Function.type)
}

// -------------------------------------------------------------------

// Slices_Slice_SourceFile

// repeated .fast.Slices.Slice.SourceFile.Function function = 1;
inline int Slices_Slice_SourceFile::function_size() const {
  return function_.size();
}
inline void Slices_Slice_SourceFile::clear_function() {
  function_.Clear();
}
inline const ::fast::Slices_Slice_SourceFile_Function& Slices_Slice_SourceFile::function(int index) const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.function)
  return function_.Get(index);
}
inline ::fast::Slices_Slice_SourceFile_Function* Slices_Slice_SourceFile::mutable_function(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Slices.Slice.SourceFile.function)
  return function_.Mutable(index);
}
inline ::fast::Slices_Slice_SourceFile_Function* Slices_Slice_SourceFile::add_function() {
  // @@protoc_insertion_point(field_add:fast.Slices.Slice.SourceFile.function)
  return function_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function >*
Slices_Slice_SourceFile::mutable_function() {
  // @@protoc_insertion_point(field_mutable_list:fast.Slices.Slice.SourceFile.function)
  return &function_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile_Function >&
Slices_Slice_SourceFile::function() const {
  // @@protoc_insertion_point(field_list:fast.Slices.Slice.SourceFile.function)
  return function_;
}

// string name = 2;
inline void Slices_Slice_SourceFile::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Slices_Slice_SourceFile::name() const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.name)
  return name_.GetNoArena();
}
inline void Slices_Slice_SourceFile::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Slices.Slice.SourceFile.name)
}
#if LANG_CXX11
inline void Slices_Slice_SourceFile::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Slices.Slice.SourceFile.name)
}
#endif
inline void Slices_Slice_SourceFile::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Slices.Slice.SourceFile.name)
}
inline void Slices_Slice_SourceFile::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Slices.Slice.SourceFile.name)
}
inline ::std::string* Slices_Slice_SourceFile::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:fast.Slices.Slice.SourceFile.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Slices_Slice_SourceFile::release_name() {
  // @@protoc_insertion_point(field_release:fast.Slices.Slice.SourceFile.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Slices_Slice_SourceFile::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:fast.Slices.Slice.SourceFile.name)
}

// .fast.Slices.Slice.ChangeType type = 3;
inline void Slices_Slice_SourceFile::clear_type() {
  type_ = 0;
}
inline ::fast::Slices_Slice_ChangeType Slices_Slice_SourceFile::type() const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.SourceFile.type)
  return static_cast< ::fast::Slices_Slice_ChangeType >(type_);
}
inline void Slices_Slice_SourceFile::set_type(::fast::Slices_Slice_ChangeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:fast.Slices.Slice.SourceFile.type)
}

// -------------------------------------------------------------------

// Slices_Slice

// repeated .fast.Slices.Slice.SourceFile file = 1;
inline int Slices_Slice::file_size() const {
  return file_.size();
}
inline void Slices_Slice::clear_file() {
  file_.Clear();
}
inline const ::fast::Slices_Slice_SourceFile& Slices_Slice::file(int index) const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.file)
  return file_.Get(index);
}
inline ::fast::Slices_Slice_SourceFile* Slices_Slice::mutable_file(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Slices.Slice.file)
  return file_.Mutable(index);
}
inline ::fast::Slices_Slice_SourceFile* Slices_Slice::add_file() {
  // @@protoc_insertion_point(field_add:fast.Slices.Slice.file)
  return file_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile >*
Slices_Slice::mutable_file() {
  // @@protoc_insertion_point(field_mutable_list:fast.Slices.Slice.file)
  return &file_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice_SourceFile >&
Slices_Slice::file() const {
  // @@protoc_insertion_point(field_list:fast.Slices.Slice.file)
  return file_;
}

// string hash = 2;
inline void Slices_Slice::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Slices_Slice::hash() const {
  // @@protoc_insertion_point(field_get:fast.Slices.Slice.hash)
  return hash_.GetNoArena();
}
inline void Slices_Slice::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Slices.Slice.hash)
}
#if LANG_CXX11
inline void Slices_Slice::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Slices.Slice.hash)
}
#endif
inline void Slices_Slice::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Slices.Slice.hash)
}
inline void Slices_Slice::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Slices.Slice.hash)
}
inline ::std::string* Slices_Slice::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:fast.Slices.Slice.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Slices_Slice::release_hash() {
  // @@protoc_insertion_point(field_release:fast.Slices.Slice.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Slices_Slice::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:fast.Slices.Slice.hash)
}

// -------------------------------------------------------------------

// Slices

// repeated .fast.Slices.Slice slice = 1;
inline int Slices::slice_size() const {
  return slice_.size();
}
inline void Slices::clear_slice() {
  slice_.Clear();
}
inline const ::fast::Slices_Slice& Slices::slice(int index) const {
  // @@protoc_insertion_point(field_get:fast.Slices.slice)
  return slice_.Get(index);
}
inline ::fast::Slices_Slice* Slices::mutable_slice(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Slices.slice)
  return slice_.Mutable(index);
}
inline ::fast::Slices_Slice* Slices::add_slice() {
  // @@protoc_insertion_point(field_add:fast.Slices.slice)
  return slice_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice >*
Slices::mutable_slice() {
  // @@protoc_insertion_point(field_mutable_list:fast.Slices.slice)
  return &slice_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fast::Slices_Slice >&
Slices::slice() const {
  // @@protoc_insertion_point(field_list:fast.Slices.slice)
  return slice_;
}

// -------------------------------------------------------------------

// Data

// .fast.Element element = 1;
inline bool Data::has_element() const {
  return RecordType_case() == kElement;
}
inline void Data::set_has_element() {
  _oneof_case_[0] = kElement;
}
inline void Data::clear_element() {
  if (has_element()) {
    delete RecordType_.element_;
    clear_has_RecordType();
  }
}
inline  const ::fast::Element& Data::element() const {
  // @@protoc_insertion_point(field_get:fast.Data.element)
  return has_element()
      ? *RecordType_.element_
      : ::fast::Element::default_instance();
}
inline ::fast::Element* Data::mutable_element() {
  if (!has_element()) {
    clear_RecordType();
    set_has_element();
    RecordType_.element_ = new ::fast::Element;
  }
  // @@protoc_insertion_point(field_mutable:fast.Data.element)
  return RecordType_.element_;
}
inline ::fast::Element* Data::release_element() {
  // @@protoc_insertion_point(field_release:fast.Data.element)
  if (has_element()) {
    clear_has_RecordType();
    ::fast::Element* temp = RecordType_.element_;
    RecordType_.element_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Data::set_allocated_element(::fast::Element* element) {
  clear_RecordType();
  if (element) {
    set_has_element();
    RecordType_.element_ = element;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Data.element)
}

// .fast.Log log = 2;
inline bool Data::has_log() const {
  return RecordType_case() == kLog;
}
inline void Data::set_has_log() {
  _oneof_case_[0] = kLog;
}
inline void Data::clear_log() {
  if (has_log()) {
    delete RecordType_.log_;
    clear_has_RecordType();
  }
}
inline  const ::fast::Log& Data::log() const {
  // @@protoc_insertion_point(field_get:fast.Data.log)
  return has_log()
      ? *RecordType_.log_
      : ::fast::Log::default_instance();
}
inline ::fast::Log* Data::mutable_log() {
  if (!has_log()) {
    clear_RecordType();
    set_has_log();
    RecordType_.log_ = new ::fast::Log;
  }
  // @@protoc_insertion_point(field_mutable:fast.Data.log)
  return RecordType_.log_;
}
inline ::fast::Log* Data::release_log() {
  // @@protoc_insertion_point(field_release:fast.Data.log)
  if (has_log()) {
    clear_has_RecordType();
    ::fast::Log* temp = RecordType_.log_;
    RecordType_.log_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Data::set_allocated_log(::fast::Log* log) {
  clear_RecordType();
  if (log) {
    set_has_log();
    RecordType_.log_ = log;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Data.log)
}

// .fast.Delta delta = 3;
inline bool Data::has_delta() const {
  return RecordType_case() == kDelta;
}
inline void Data::set_has_delta() {
  _oneof_case_[0] = kDelta;
}
inline void Data::clear_delta() {
  if (has_delta()) {
    delete RecordType_.delta_;
    clear_has_RecordType();
  }
}
inline  const ::fast::Delta& Data::delta() const {
  // @@protoc_insertion_point(field_get:fast.Data.delta)
  return has_delta()
      ? *RecordType_.delta_
      : ::fast::Delta::default_instance();
}
inline ::fast::Delta* Data::mutable_delta() {
  if (!has_delta()) {
    clear_RecordType();
    set_has_delta();
    RecordType_.delta_ = new ::fast::Delta;
  }
  // @@protoc_insertion_point(field_mutable:fast.Data.delta)
  return RecordType_.delta_;
}
inline ::fast::Delta* Data::release_delta() {
  // @@protoc_insertion_point(field_release:fast.Data.delta)
  if (has_delta()) {
    clear_has_RecordType();
    ::fast::Delta* temp = RecordType_.delta_;
    RecordType_.delta_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Data::set_allocated_delta(::fast::Delta* delta) {
  clear_RecordType();
  if (delta) {
    set_has_delta();
    RecordType_.delta_ = delta;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Data.delta)
}

// .fast.Pairs pairs = 4;
inline bool Data::has_pairs() const {
  return RecordType_case() == kPairs;
}
inline void Data::set_has_pairs() {
  _oneof_case_[0] = kPairs;
}
inline void Data::clear_pairs() {
  if (has_pairs()) {
    delete RecordType_.pairs_;
    clear_has_RecordType();
  }
}
inline  const ::fast::Pairs& Data::pairs() const {
  // @@protoc_insertion_point(field_get:fast.Data.pairs)
  return has_pairs()
      ? *RecordType_.pairs_
      : ::fast::Pairs::default_instance();
}
inline ::fast::Pairs* Data::mutable_pairs() {
  if (!has_pairs()) {
    clear_RecordType();
    set_has_pairs();
    RecordType_.pairs_ = new ::fast::Pairs;
  }
  // @@protoc_insertion_point(field_mutable:fast.Data.pairs)
  return RecordType_.pairs_;
}
inline ::fast::Pairs* Data::release_pairs() {
  // @@protoc_insertion_point(field_release:fast.Data.pairs)
  if (has_pairs()) {
    clear_has_RecordType();
    ::fast::Pairs* temp = RecordType_.pairs_;
    RecordType_.pairs_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Data::set_allocated_pairs(::fast::Pairs* pairs) {
  clear_RecordType();
  if (pairs) {
    set_has_pairs();
    RecordType_.pairs_ = pairs;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Data.pairs)
}

// .fast.Slices slices = 5;
inline bool Data::has_slices() const {
  return RecordType_case() == kSlices;
}
inline void Data::set_has_slices() {
  _oneof_case_[0] = kSlices;
}
inline void Data::clear_slices() {
  if (has_slices()) {
    delete RecordType_.slices_;
    clear_has_RecordType();
  }
}
inline  const ::fast::Slices& Data::slices() const {
  // @@protoc_insertion_point(field_get:fast.Data.slices)
  return has_slices()
      ? *RecordType_.slices_
      : ::fast::Slices::default_instance();
}
inline ::fast::Slices* Data::mutable_slices() {
  if (!has_slices()) {
    clear_RecordType();
    set_has_slices();
    RecordType_.slices_ = new ::fast::Slices;
  }
  // @@protoc_insertion_point(field_mutable:fast.Data.slices)
  return RecordType_.slices_;
}
inline ::fast::Slices* Data::release_slices() {
  // @@protoc_insertion_point(field_release:fast.Data.slices)
  if (has_slices()) {
    clear_has_RecordType();
    ::fast::Slices* temp = RecordType_.slices_;
    RecordType_.slices_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Data::set_allocated_slices(::fast::Slices* slices) {
  clear_RecordType();
  if (slices) {
    set_has_slices();
    RecordType_.slices_ = slices;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Data.slices)
}

inline bool Data::has_RecordType() const {
  return RecordType_case() != RECORDTYPE_NOT_SET;
}
inline void Data::clear_has_RecordType() {
  _oneof_case_[0] = RECORDTYPE_NOT_SET;
}
inline Data::RecordTypeCase Data::RecordType_case() const {
  return Data::RecordTypeCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace fast

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::fast::Element_Unit_LanguageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fast::Element_Unit_LanguageType>() {
  return ::fast::Element_Unit_LanguageType_descriptor();
}
template <> struct is_proto_enum< ::fast::Element_Literal_LiteralType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fast::Element_Literal_LiteralType>() {
  return ::fast::Element_Literal_LiteralType_descriptor();
}
template <> struct is_proto_enum< ::fast::Element_Kind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fast::Element_Kind>() {
  return ::fast::Element_Kind_descriptor();
}
template <> struct is_proto_enum< ::fast::Delta_Diff_DeltaType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fast::Delta_Diff_DeltaType>() {
  return ::fast::Delta_Diff_DeltaType_descriptor();
}
template <> struct is_proto_enum< ::fast::Pairs_Pair_CloneType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fast::Pairs_Pair_CloneType>() {
  return ::fast::Pairs_Pair_CloneType_descriptor();
}
template <> struct is_proto_enum< ::fast::Slices_Slice_ChangeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fast::Slices_Slice_ChangeType>() {
  return ::fast::Slices_Slice_ChangeType_descriptor();
}
template <> struct is_proto_enum< ::fast::SmaliKind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fast::SmaliKind>() {
  return ::fast::SmaliKind_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_fast_2eproto__INCLUDED
