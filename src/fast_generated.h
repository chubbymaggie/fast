// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FAST__FAST__PAIRS__PAIR_H_
#define FLATBUFFERS_GENERATED_FAST__FAST__PAIRS__PAIR_H_

#include "flatbuffers/flatbuffers.h"

namespace _fast {

struct Element;

namespace _Element {

struct Anonymous0;

struct Unit;

struct Literal;

}  // namespace _Element

struct Delta;

namespace _Delta {

struct Diff;

namespace _Diff {

struct Anonymous1;

struct Match;

struct Add;

struct Del;

struct Move;

struct Update;

}  // namespace _Diff
}  // namespace _Delta

struct Pairs;

namespace _Pairs {

struct Pair;

namespace _Pair {

struct Diff;

}  // namespace _Pair
}  // namespace _Pairs

namespace _Element {

enum Kind {
  Kind_UNIT_KIND = 0,
  Kind_DECL = 1,
  Kind_DECL_STMT = 2,
  Kind_INIT = 3,
  Kind_EXPR = 4,
  Kind_EXPR_STMT = 5,
  Kind_COMMENT = 6,
  Kind_CALL = 7,
  Kind_CONTROL = 8,
  Kind_INCR = 9,
  Kind_NONE = 10,
  Kind_VARIABLE = 11,
  Kind_FUNCTION = 12,
  Kind_FUNCTION_DECL = 13,
  Kind_CONSTRUCTOR = 14,
  Kind_CONSTRUCTOR_DECL = 15,
  Kind_DESTRUCTOR = 16,
  Kind_DESTRUCTOR_DECL = 17,
  Kind_MACRO = 18,
  Kind_SINGLE_MACRO = 19,
  Kind_NULLOPERATOR = 20,
  Kind_ENUM_DEFN = 21,
  Kind_ENUM_DECL = 22,
  Kind_GLOBAL_ATTRIBUTE = 23,
  Kind_PROPERTY_ACCESSOR = 24,
  Kind_PROPERTY_ACCESSOR_DECL = 25,
  Kind_EXPRESSION = 26,
  Kind_CLASS_DEFN = 27,
  Kind_CLASS_DECL = 28,
  Kind_UNION_DEFN = 29,
  Kind_UNION_DECL = 30,
  Kind_STRUCT_DEFN = 31,
  Kind_STRUCT_DECL = 32,
  Kind_INTERFACE_DEFN = 33,
  Kind_INTERFACE_DECL = 34,
  Kind_ACCESS_REGION = 35,
  Kind_USING = 36,
  Kind_OPERATOR_FUNCTION = 37,
  Kind_OPERATOR_FUNCTION_DECL = 38,
  Kind_EVENT = 39,
  Kind_PROPERTY = 40,
  Kind_ANNOTATION_DEFN = 41,
  Kind_GLOBAL_TEMPLATE = 42,
  Kind_UNIT = 43,
  Kind_TART_ELEMENT_TOKEN = 44,
  Kind_NOP = 45,
  Kind_STRING = 46,
  Kind_CHAR = 47,
  Kind_LITERAL = 48,
  Kind_BOOLEAN = 49,
  Kind_NULL = 50,
  Kind_COMPLEX = 51,
  Kind_OPERATOR = 52,
  Kind_MODIFIER = 53,
  Kind_NAME = 54,
  Kind_ONAME = 55,
  Kind_CNAME = 56,
  Kind_TYPE = 57,
  Kind_TYPEPREV = 58,
  Kind_CONDITION = 59,
  Kind_BLOCK = 60,
  Kind_PSEUDO_BLOCK = 61,
  Kind_INDEX = 62,
  Kind_ENUM = 63,
  Kind_ENUM_DECLARATION = 64,
  Kind_IF_STATEMENT = 65,
  Kind_TERNARY = 66,
  Kind_THEN = 67,
  Kind_ELSE = 68,
  Kind_ELSEIF = 69,
  Kind_WHILE_STATEMENT = 70,
  Kind_DO_STATEMENT = 71,
  Kind_FOR_STATEMENT = 72,
  Kind_FOREACH_STATEMENT = 73,
  Kind_FOR_CONTROL = 74,
  Kind_FOR_INITIALIZATION = 75,
  Kind_FOR_CONDITION = 76,
  Kind_FOR_INCREMENT = 77,
  Kind_FOR_LIKE_CONTROL = 78,
  Kind_EXPRESSION_STATEMENT = 79,
  Kind_FUNCTION_CALL = 80,
  Kind_DECLARATION_STATEMENT = 81,
  Kind_DECLARATION = 82,
  Kind_DECLARATION_INITIALIZATION = 83,
  Kind_DECLARATION_RANGE = 84,
  Kind_RANGE = 85,
  Kind_GOTO_STATEMENT = 86,
  Kind_CONTINUE_STATEMENT = 87,
  Kind_BREAK_STATEMENT = 88,
  Kind_LABEL_STATEMENT = 89,
  Kind_LABEL = 90,
  Kind_SWITCH = 91,
  Kind_CASE = 92,
  Kind_DEFAULT = 93,
  Kind_FUNCTION_DEFINITION = 94,
  Kind_FUNCTION_DECLARATION = 95,
  Kind_LAMBDA = 96,
  Kind_FUNCTION_LAMBDA = 97,
  Kind_FUNCTION_SPECIFIER = 98,
  Kind_RETURN_STATEMENT = 99,
  Kind_PARAMETER_LIST = 100,
  Kind_PARAMETER = 101,
  Kind_KRPARAMETER_LIST = 102,
  Kind_KRPARAMETER = 103,
  Kind_ARGUMENT_LIST = 104,
  Kind_ARGUMENT = 105,
  Kind_PSEUDO_PARAMETER_LIST = 106,
  Kind_INDEXER_PARAMETER_LIST = 107,
  Kind_CLASS = 108,
  Kind_CLASS_DECLARATION = 109,
  Kind_STRUCT = 110,
  Kind_STRUCT_DECLARATION = 111,
  Kind_UNION = 112,
  Kind_UNION_DECLARATION = 113,
  Kind_DERIVATION_LIST = 114,
  Kind_PUBLIC_ACCESS = 115,
  Kind_PUBLIC_ACCESS_DEFAULT = 116,
  Kind_PRIVATE_ACCESS = 117,
  Kind_PRIVATE_ACCESS_DEFAULT = 118,
  Kind_PROTECTED_ACCESS = 119,
  Kind_PROTECTED_ACCESS_DEFAULT = 120,
  Kind_MEMBER_INIT_LIST = 121,
  Kind_MEMBER_INITIALIZATION_LIST = 122,
  Kind_MEMBER_INITIALIZATION = 123,
  Kind_CONSTRUCTOR_DEFINITION = 124,
  Kind_CONSTRUCTOR_DECLARATION = 125,
  Kind_DESTRUCTOR_DEFINITION = 126,
  Kind_DESTRUCTOR_DECLARATION = 127,
  Kind_FRIEND = 128,
  Kind_CLASS_SPECIFIER = 129,
  Kind_TRY_BLOCK = 130,
  Kind_CATCH_BLOCK = 131,
  Kind_FINALLY_BLOCK = 132,
  Kind_THROW_STATEMENT = 133,
  Kind_THROW_SPECIFIER = 134,
  Kind_THROW_SPECIFIER_JAVA = 135,
  Kind_TEMPLATE = 136,
  Kind_GENERIC_ARGUMENT = 137,
  Kind_GENERIC_ARGUMENT_LIST = 138,
  Kind_TEMPLATE_PARAMETER = 139,
  Kind_TEMPLATE_PARAMETER_LIST = 140,
  Kind_GENERIC_PARAMETER = 141,
  Kind_GENERIC_PARAMETER_LIST = 142,
  Kind_TYPEDEF = 143,
  Kind_ASM = 144,
  Kind_MACRO_CALL = 145,
  Kind_SIZEOF_CALL = 146,
  Kind_EXTERN = 147,
  Kind_NAMESPACE = 148,
  Kind_USING_DIRECTIVE = 149,
  Kind_DIRECTIVE = 150,
  Kind_ATOMIC = 151,
  Kind_STATIC_ASSERT_STATEMENT = 152,
  Kind_GENERIC_SELECTION = 153,
  Kind_GENERIC_SELECTOR = 154,
  Kind_GENERIC_ASSOCIATION_LIST = 155,
  Kind_GENERIC_ASSOCIATION = 156,
  Kind_ALIGNAS = 157,
  Kind_DECLTYPE = 158,
  Kind_CAPTURE = 159,
  Kind_LAMBDA_CAPTURE = 160,
  Kind_NOEXCEPT = 161,
  Kind_TYPENAME = 162,
  Kind_ALIGNOF = 163,
  Kind_TYPEID = 164,
  Kind_SIZEOF_PACK = 165,
  Kind_ENUM_CLASS = 166,
  Kind_ENUM_CLASS_DECLARATION = 167,
  Kind_REF_QUALIFIER = 168,
  Kind_SIGNAL_ACCESS = 169,
  Kind_FOREVER_STATEMENT = 170,
  Kind_EMIT_STATEMENT = 171,
  Kind_CPP_DIRECTIVE = 172,
  Kind_CPP_FILENAME = 173,
  Kind_FILE = 174,
  Kind_NUMBER = 175,
  Kind_CPP_NUMBER = 176,
  Kind_CPP_LITERAL = 177,
  Kind_CPP_MACRO_DEFN = 178,
  Kind_CPP_MACRO_VALUE = 179,
  Kind_ERROR = 180,
  Kind_CPP_ERROR = 181,
  Kind_CPP_WARNING = 182,
  Kind_CPP_PRAGMA = 183,
  Kind_CPP_INCLUDE = 184,
  Kind_CPP_DEFINE = 185,
  Kind_CPP_UNDEF = 186,
  Kind_CPP_LINE = 187,
  Kind_CPP_IF = 188,
  Kind_CPP_IFDEF = 189,
  Kind_CPP_IFNDEF = 190,
  Kind_CPP_THEN = 191,
  Kind_CPP_ELSE = 192,
  Kind_CPP_ELIF = 193,
  Kind_CPP_EMPTY = 194,
  Kind_CPP_REGION = 195,
  Kind_CPP_ENDREGION = 196,
  Kind_USING_STMT = 197,
  Kind_ESCAPE = 198,
  Kind_VALUE = 199,
  Kind_CPP_IMPORT = 200,
  Kind_CPP_ENDIF = 201,
  Kind_MARKER = 202,
  Kind_ERROR_PARSE = 203,
  Kind_ERROR_MODE = 204,
  Kind_IMPLEMENTS = 205,
  Kind_EXTENDS = 206,
  Kind_IMPORT = 207,
  Kind_PACKAGE = 208,
  Kind_ASSERT_STATEMENT = 209,
  Kind_INTERFACE = 210,
  Kind_INTERFACE_DECLARATION = 211,
  Kind_SYNCHRONIZED_STATEMENT = 212,
  Kind_ANNOTATION = 213,
  Kind_STATIC_BLOCK = 214,
  Kind_CHECKED_STATEMENT = 215,
  Kind_UNCHECKED_STATEMENT = 216,
  Kind_ATTRIBUTE = 217,
  Kind_TARGET = 218,
  Kind_UNSAFE_STATEMENT = 219,
  Kind_LOCK_STATEMENT = 220,
  Kind_FIXED_STATEMENT = 221,
  Kind_TYPEOF = 222,
  Kind_USING_STATEMENT = 223,
  Kind_FUNCTION_DELEGATE = 224,
  Kind_CONSTRAINT = 225,
  Kind_LINQ = 226,
  Kind_FROM = 227,
  Kind_WHERE = 228,
  Kind_SELECT = 229,
  Kind_LET = 230,
  Kind_ORDERBY = 231,
  Kind_JOIN = 232,
  Kind_GROUP = 233,
  Kind_IN = 234,
  Kind_ON = 235,
  Kind_EQUALS = 236,
  Kind_BY = 237,
  Kind_INTO = 238,
  Kind_EMPTY = 239,
  Kind_EMPTY_STMT = 240,
  Kind_RECEIVER = 241,
  Kind_MESSAGE = 242,
  Kind_SELECTOR = 243,
  Kind_PROTOCOL_LIST = 244,
  Kind_CATEGORY = 245,
  Kind_PROTOCOL = 246,
  Kind_REQUIRED_DEFAULT = 247,
  Kind_REQUIRED = 248,
  Kind_OPTIONAL = 249,
  Kind_ATTRIBUTE_LIST = 250,
  Kind_SYNTHESIZE = 251,
  Kind_DYNAMIC = 252,
  Kind_ENCODE = 253,
  Kind_AUTORELEASEPOOL = 254,
  Kind_COMPATIBILITY_ALIAS = 255,
  Kind_NIL = 256,
  Kind_CLASS_INTERFACE = 257,
  Kind_CLASS_IMPLEMENTATION = 258,
  Kind_PROTOCOL_DECLARATION = 259,
  Kind_CAST = 260,
  Kind_CONST_CAST = 261,
  Kind_DYNAMIC_CAST = 262,
  Kind_REINTERPRET_CAST = 263,
  Kind_STATIC_CAST = 264,
  Kind_POSITION = 265,
  Kind_CUDA_ARGUMENT_LIST = 266,
  Kind_OMP_DIRECTIVE = 267,
  Kind_OMP_NAME = 268,
  Kind_OMP_CLAUSE = 269,
  Kind_OMP_ARGUMENT_LIST = 270,
  Kind_OMP_ARGUMENT = 271,
  Kind_OMP_EXPRESSION = 272,
  Kind_END_ELEMENT_TOKEN = 273,
  Kind_MAIN = 274,
  Kind_BREAK = 275,
  Kind_CONTINUE = 276,
  Kind_WHILE = 277,
  Kind_DO = 278,
  Kind_FOR = 279,
  Kind_IF = 280,
  Kind_GOTO = 281,
  Kind_VISUAL_CXX_ASM = 282,
  Kind_SIZEOF = 283,
  Kind_AUTO = 284,
  Kind_REGISTER = 285,
  Kind_RESTRICT = 286,
  Kind_IMAGINARY = 287,
  Kind_NORETURN = 288,
  Kind_STATIC_ASSERT = 289,
  Kind_CRESTRICT = 290,
  Kind_CXX_TRY = 291,
  Kind_CXX_CATCH = 292,
  Kind_CXX_CLASS = 293,
  Kind_CONSTEXPR = 294,
  Kind_THREAD_LOCAL = 295,
  Kind_NULLPTR = 296,
  Kind_VOID = 297,
  Kind_RETURN = 298,
  Kind_INCLUDE = 299,
  Kind_DEFINE = 300,
  Kind_ELIF = 301,
  Kind_ENDIF = 302,
  Kind_ERRORPREC = 303,
  Kind_WARNING = 304,
  Kind_IFDEF = 305,
  Kind_IFNDEF = 306,
  Kind_LINE = 307,
  Kind_PRAGMA = 308,
  Kind_UNDEF = 309,
  Kind_INLINE = 310,
  Kind_MACRO_TYPE_NAME = 311,
  Kind_MACRO_CASE = 312,
  Kind_MACRO_LABEL = 313,
  Kind_SPECIFIER = 314,
  Kind_TRY = 315,
  Kind_CATCH = 316,
  Kind_THROW = 317,
  Kind_THROWS = 318,
  Kind_PUBLIC = 319,
  Kind_PRIVATE = 320,
  Kind_PROTECTED = 321,
  Kind_VIRTUAL = 322,
  Kind_EXPLICIT = 323,
  Kind_FOREVER = 324,
  Kind_SIGNAL = 325,
  Kind_EMIT = 326,
  Kind_NEW = 327,
  Kind_DELETE = 328,
  Kind_STATIC = 329,
  Kind_CONST = 330,
  Kind_MUTABLE = 331,
  Kind_VOLATILE = 332,
  Kind_TRANSIENT = 333,
  Kind_FINALLY = 334,
  Kind_FINAL = 335,
  Kind_ABSTRACT = 336,
  Kind_SUPER = 337,
  Kind_SYNCHRONIZED = 338,
  Kind_NATIVE = 339,
  Kind_STRICTFP = 340,
  Kind_NULLLITERAL = 341,
  Kind_ASSERT = 342,
  Kind_FOREACH = 343,
  Kind_REF = 344,
  Kind_OUT = 345,
  Kind_LOCK = 346,
  Kind_IS = 347,
  Kind_INTERNAL = 348,
  Kind_SEALED = 349,
  Kind_OVERRIDE = 350,
  Kind_IMPLICIT = 351,
  Kind_STACKALLOC = 352,
  Kind_AS = 353,
  Kind_DELEGATE = 354,
  Kind_FIXED = 355,
  Kind_CHECKED = 356,
  Kind_UNCHECKED = 357,
  Kind_REGION = 358,
  Kind_ENDREGION = 359,
  Kind_UNSAFE = 360,
  Kind_READONLY = 361,
  Kind_GET = 362,
  Kind_SET = 363,
  Kind_ADD = 364,
  Kind_REMOVE = 365,
  Kind_YIELD = 366,
  Kind_PARTIAL = 367,
  Kind_AWAIT = 368,
  Kind_ASYNC = 369,
  Kind_THIS = 370,
  Kind_PARAMS = 371,
  Kind_ALIAS = 372,
  Kind_ASCENDING = 373,
  Kind_DESCENDING = 374,
  Kind_ATINTERFACE = 375,
  Kind_ATIMPLEMENTATION = 376,
  Kind_ATEND = 377,
  Kind_ATPROTOCOL = 378,
  Kind_ATREQUIRED = 379,
  Kind_ATOPTIONAL = 380,
  Kind_ATCLASS = 381,
  Kind_WEAK = 382,
  Kind_STRONG = 383,
  Kind_OMP_OMP = 384,
  Kind_SPECIAL_CHARS = 385,
  Kind_MIN = Kind_UNIT_KIND,
  Kind_MAX = Kind_SPECIAL_CHARS
};

inline const char **EnumNamesKind() {
  static const char *names[] = {
    "UNIT_KIND",
    "DECL",
    "DECL_STMT",
    "INIT",
    "EXPR",
    "EXPR_STMT",
    "COMMENT",
    "CALL",
    "CONTROL",
    "INCR",
    "NONE",
    "VARIABLE",
    "FUNCTION",
    "FUNCTION_DECL",
    "CONSTRUCTOR",
    "CONSTRUCTOR_DECL",
    "DESTRUCTOR",
    "DESTRUCTOR_DECL",
    "MACRO",
    "SINGLE_MACRO",
    "NULLOPERATOR",
    "ENUM_DEFN",
    "ENUM_DECL",
    "GLOBAL_ATTRIBUTE",
    "PROPERTY_ACCESSOR",
    "PROPERTY_ACCESSOR_DECL",
    "EXPRESSION",
    "CLASS_DEFN",
    "CLASS_DECL",
    "UNION_DEFN",
    "UNION_DECL",
    "STRUCT_DEFN",
    "STRUCT_DECL",
    "INTERFACE_DEFN",
    "INTERFACE_DECL",
    "ACCESS_REGION",
    "USING",
    "OPERATOR_FUNCTION",
    "OPERATOR_FUNCTION_DECL",
    "EVENT",
    "PROPERTY",
    "ANNOTATION_DEFN",
    "GLOBAL_TEMPLATE",
    "UNIT",
    "TART_ELEMENT_TOKEN",
    "NOP",
    "STRING",
    "CHAR",
    "LITERAL",
    "BOOLEAN",
    "NULL",
    "COMPLEX",
    "OPERATOR",
    "MODIFIER",
    "NAME",
    "ONAME",
    "CNAME",
    "TYPE",
    "TYPEPREV",
    "CONDITION",
    "BLOCK",
    "PSEUDO_BLOCK",
    "INDEX",
    "ENUM",
    "ENUM_DECLARATION",
    "IF_STATEMENT",
    "TERNARY",
    "THEN",
    "ELSE",
    "ELSEIF",
    "WHILE_STATEMENT",
    "DO_STATEMENT",
    "FOR_STATEMENT",
    "FOREACH_STATEMENT",
    "FOR_CONTROL",
    "FOR_INITIALIZATION",
    "FOR_CONDITION",
    "FOR_INCREMENT",
    "FOR_LIKE_CONTROL",
    "EXPRESSION_STATEMENT",
    "FUNCTION_CALL",
    "DECLARATION_STATEMENT",
    "DECLARATION",
    "DECLARATION_INITIALIZATION",
    "DECLARATION_RANGE",
    "RANGE",
    "GOTO_STATEMENT",
    "CONTINUE_STATEMENT",
    "BREAK_STATEMENT",
    "LABEL_STATEMENT",
    "LABEL",
    "SWITCH",
    "CASE",
    "DEFAULT",
    "FUNCTION_DEFINITION",
    "FUNCTION_DECLARATION",
    "LAMBDA",
    "FUNCTION_LAMBDA",
    "FUNCTION_SPECIFIER",
    "RETURN_STATEMENT",
    "PARAMETER_LIST",
    "PARAMETER",
    "KRPARAMETER_LIST",
    "KRPARAMETER",
    "ARGUMENT_LIST",
    "ARGUMENT",
    "PSEUDO_PARAMETER_LIST",
    "INDEXER_PARAMETER_LIST",
    "CLASS",
    "CLASS_DECLARATION",
    "STRUCT",
    "STRUCT_DECLARATION",
    "UNION",
    "UNION_DECLARATION",
    "DERIVATION_LIST",
    "PUBLIC_ACCESS",
    "PUBLIC_ACCESS_DEFAULT",
    "PRIVATE_ACCESS",
    "PRIVATE_ACCESS_DEFAULT",
    "PROTECTED_ACCESS",
    "PROTECTED_ACCESS_DEFAULT",
    "MEMBER_INIT_LIST",
    "MEMBER_INITIALIZATION_LIST",
    "MEMBER_INITIALIZATION",
    "CONSTRUCTOR_DEFINITION",
    "CONSTRUCTOR_DECLARATION",
    "DESTRUCTOR_DEFINITION",
    "DESTRUCTOR_DECLARATION",
    "FRIEND",
    "CLASS_SPECIFIER",
    "TRY_BLOCK",
    "CATCH_BLOCK",
    "FINALLY_BLOCK",
    "THROW_STATEMENT",
    "THROW_SPECIFIER",
    "THROW_SPECIFIER_JAVA",
    "TEMPLATE",
    "GENERIC_ARGUMENT",
    "GENERIC_ARGUMENT_LIST",
    "TEMPLATE_PARAMETER",
    "TEMPLATE_PARAMETER_LIST",
    "GENERIC_PARAMETER",
    "GENERIC_PARAMETER_LIST",
    "TYPEDEF",
    "ASM",
    "MACRO_CALL",
    "SIZEOF_CALL",
    "EXTERN",
    "NAMESPACE",
    "USING_DIRECTIVE",
    "DIRECTIVE",
    "ATOMIC",
    "STATIC_ASSERT_STATEMENT",
    "GENERIC_SELECTION",
    "GENERIC_SELECTOR",
    "GENERIC_ASSOCIATION_LIST",
    "GENERIC_ASSOCIATION",
    "ALIGNAS",
    "DECLTYPE",
    "CAPTURE",
    "LAMBDA_CAPTURE",
    "NOEXCEPT",
    "TYPENAME",
    "ALIGNOF",
    "TYPEID",
    "SIZEOF_PACK",
    "ENUM_CLASS",
    "ENUM_CLASS_DECLARATION",
    "REF_QUALIFIER",
    "SIGNAL_ACCESS",
    "FOREVER_STATEMENT",
    "EMIT_STATEMENT",
    "CPP_DIRECTIVE",
    "CPP_FILENAME",
    "FILE",
    "NUMBER",
    "CPP_NUMBER",
    "CPP_LITERAL",
    "CPP_MACRO_DEFN",
    "CPP_MACRO_VALUE",
    "ERROR",
    "CPP_ERROR",
    "CPP_WARNING",
    "CPP_PRAGMA",
    "CPP_INCLUDE",
    "CPP_DEFINE",
    "CPP_UNDEF",
    "CPP_LINE",
    "CPP_IF",
    "CPP_IFDEF",
    "CPP_IFNDEF",
    "CPP_THEN",
    "CPP_ELSE",
    "CPP_ELIF",
    "CPP_EMPTY",
    "CPP_REGION",
    "CPP_ENDREGION",
    "USING_STMT",
    "ESCAPE",
    "VALUE",
    "CPP_IMPORT",
    "CPP_ENDIF",
    "MARKER",
    "ERROR_PARSE",
    "ERROR_MODE",
    "IMPLEMENTS",
    "EXTENDS",
    "IMPORT",
    "PACKAGE",
    "ASSERT_STATEMENT",
    "INTERFACE",
    "INTERFACE_DECLARATION",
    "SYNCHRONIZED_STATEMENT",
    "ANNOTATION",
    "STATIC_BLOCK",
    "CHECKED_STATEMENT",
    "UNCHECKED_STATEMENT",
    "ATTRIBUTE",
    "TARGET",
    "UNSAFE_STATEMENT",
    "LOCK_STATEMENT",
    "FIXED_STATEMENT",
    "TYPEOF",
    "USING_STATEMENT",
    "FUNCTION_DELEGATE",
    "CONSTRAINT",
    "LINQ",
    "FROM",
    "WHERE",
    "SELECT",
    "LET",
    "ORDERBY",
    "JOIN",
    "GROUP",
    "IN",
    "ON",
    "EQUALS",
    "BY",
    "INTO",
    "EMPTY",
    "EMPTY_STMT",
    "RECEIVER",
    "MESSAGE",
    "SELECTOR",
    "PROTOCOL_LIST",
    "CATEGORY",
    "PROTOCOL",
    "REQUIRED_DEFAULT",
    "REQUIRED",
    "OPTIONAL",
    "ATTRIBUTE_LIST",
    "SYNTHESIZE",
    "DYNAMIC",
    "ENCODE",
    "AUTORELEASEPOOL",
    "COMPATIBILITY_ALIAS",
    "NIL",
    "CLASS_INTERFACE",
    "CLASS_IMPLEMENTATION",
    "PROTOCOL_DECLARATION",
    "CAST",
    "CONST_CAST",
    "DYNAMIC_CAST",
    "REINTERPRET_CAST",
    "STATIC_CAST",
    "POSITION",
    "CUDA_ARGUMENT_LIST",
    "OMP_DIRECTIVE",
    "OMP_NAME",
    "OMP_CLAUSE",
    "OMP_ARGUMENT_LIST",
    "OMP_ARGUMENT",
    "OMP_EXPRESSION",
    "END_ELEMENT_TOKEN",
    "MAIN",
    "BREAK",
    "CONTINUE",
    "WHILE",
    "DO",
    "FOR",
    "IF",
    "GOTO",
    "VISUAL_CXX_ASM",
    "SIZEOF",
    "AUTO",
    "REGISTER",
    "RESTRICT",
    "IMAGINARY",
    "NORETURN",
    "STATIC_ASSERT",
    "CRESTRICT",
    "CXX_TRY",
    "CXX_CATCH",
    "CXX_CLASS",
    "CONSTEXPR",
    "THREAD_LOCAL",
    "NULLPTR",
    "VOID",
    "RETURN",
    "INCLUDE",
    "DEFINE",
    "ELIF",
    "ENDIF",
    "ERRORPREC",
    "WARNING",
    "IFDEF",
    "IFNDEF",
    "LINE",
    "PRAGMA",
    "UNDEF",
    "INLINE",
    "MACRO_TYPE_NAME",
    "MACRO_CASE",
    "MACRO_LABEL",
    "SPECIFIER",
    "TRY",
    "CATCH",
    "THROW",
    "THROWS",
    "PUBLIC",
    "PRIVATE",
    "PROTECTED",
    "VIRTUAL",
    "EXPLICIT",
    "FOREVER",
    "SIGNAL",
    "EMIT",
    "NEW",
    "DELETE",
    "STATIC",
    "CONST",
    "MUTABLE",
    "VOLATILE",
    "TRANSIENT",
    "FINALLY",
    "FINAL",
    "ABSTRACT",
    "SUPER",
    "SYNCHRONIZED",
    "NATIVE",
    "STRICTFP",
    "NULLLITERAL",
    "ASSERT",
    "FOREACH",
    "REF",
    "OUT",
    "LOCK",
    "IS",
    "INTERNAL",
    "SEALED",
    "OVERRIDE",
    "IMPLICIT",
    "STACKALLOC",
    "AS",
    "DELEGATE",
    "FIXED",
    "CHECKED",
    "UNCHECKED",
    "REGION",
    "ENDREGION",
    "UNSAFE",
    "READONLY",
    "GET",
    "SET",
    "ADD",
    "REMOVE",
    "YIELD",
    "PARTIAL",
    "AWAIT",
    "ASYNC",
    "THIS",
    "PARAMS",
    "ALIAS",
    "ASCENDING",
    "DESCENDING",
    "ATINTERFACE",
    "ATIMPLEMENTATION",
    "ATEND",
    "ATPROTOCOL",
    "ATREQUIRED",
    "ATOPTIONAL",
    "ATCLASS",
    "WEAK",
    "STRONG",
    "OMP_OMP",
    "SPECIAL_CHARS",
    nullptr
  };
  return names;
}

inline const char *EnumNameKind(Kind e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesKind()[index];
}

enum SmaliKind {
  SmaliKind_INVALID = 0,
  SmaliKind_EOR = 1,
  SmaliKind_DOWN = 2,
  SmaliKind_UP = 3,
  SmaliKind_ACCESS_SPEC = 4,
  SmaliKind_ANNOTATION_DIRECTIVE = 5,
  SmaliKind_ANNOTATION_VISIBILITY = 6,
  SmaliKind_ARRAY_DATA_DIRECTIVE = 7,
  SmaliKind_ARRAY_TYPE_PREFIX = 8,
  SmaliKind_ARROW = 9,
  SmaliKind_BOOL_LITERAL = 10,
  SmaliKind_BYTE_LITERAL = 11,
  SmaliKind_CATCHALL_DIRECTIVE = 12,
  SmaliKind_CATCH_DIRECTIVE = 13,
  SmaliKind_CHAR_LITERAL = 14,
  SmaliKind_CLASS_DESCRIPTOR = 15,
  SmaliKind_CLASS_DIRECTIVE = 16,
  SmaliKind_CLOSE_BRACE = 17,
  SmaliKind_CLOSE_PAREN = 18,
  SmaliKind_COLON = 19,
  SmaliKind_COMMA = 20,
  SmaliKind_DOTDOT = 21,
  SmaliKind_DOUBLE_LITERAL = 22,
  SmaliKind_DOUBLE_LITERAL_OR_ID = 23,
  SmaliKind_END_ANNOTATION_DIRECTIVE = 24,
  SmaliKind_END_ARRAY_DATA_DIRECTIVE = 25,
  SmaliKind_END_FIELD_DIRECTIVE = 26,
  SmaliKind_END_LOCAL_DIRECTIVE = 27,
  SmaliKind_END_METHOD_DIRECTIVE = 28,
  SmaliKind_END_PACKED_SWITCH_DIRECTIVE = 29,
  SmaliKind_END_PARAMETER_DIRECTIVE = 30,
  SmaliKind_END_SPARSE_SWITCH_DIRECTIVE = 31,
  SmaliKind_END_SUBANNOTATION_DIRECTIVE = 32,
  SmaliKind_ENUM_DIRECTIVE = 33,
  SmaliKind_EPILOGUE_DIRECTIVE = 34,
  SmaliKind_EQUAL = 35,
  SmaliKind_FIELD_DIRECTIVE = 36,
  SmaliKind_FIELD_OFFSET = 37,
  SmaliKind_FLOAT_LITERAL = 38,
  SmaliKind_FLOAT_LITERAL_OR_ID = 39,
  SmaliKind_IMPLEMENTS_DIRECTIVE = 40,
  SmaliKind_INLINE_INDEX = 41,
  SmaliKind_INSTRUCTION_FORMAT10t = 42,
  SmaliKind_INSTRUCTION_FORMAT10x = 43,
  SmaliKind_INSTRUCTION_FORMAT10x_ODEX = 44,
  SmaliKind_INSTRUCTION_FORMAT11n = 45,
  SmaliKind_INSTRUCTION_FORMAT11x = 46,
  SmaliKind_INSTRUCTION_FORMAT12x = 47,
  SmaliKind_INSTRUCTION_FORMAT12x_OR_ID = 48,
  SmaliKind_INSTRUCTION_FORMAT20bc = 49,
  SmaliKind_INSTRUCTION_FORMAT20t = 50,
  SmaliKind_INSTRUCTION_FORMAT21c_FIELD = 51,
  SmaliKind_INSTRUCTION_FORMAT21c_FIELD_ODEX = 52,
  SmaliKind_INSTRUCTION_FORMAT21c_STRING = 53,
  SmaliKind_INSTRUCTION_FORMAT21c_TYPE = 54,
  SmaliKind_INSTRUCTION_FORMAT21ih = 55,
  SmaliKind_INSTRUCTION_FORMAT21lh = 56,
  SmaliKind_INSTRUCTION_FORMAT21s = 57,
  SmaliKind_INSTRUCTION_FORMAT21t = 58,
  SmaliKind_INSTRUCTION_FORMAT22b = 59,
  SmaliKind_INSTRUCTION_FORMAT22c_FIELD = 60,
  SmaliKind_INSTRUCTION_FORMAT22c_FIELD_ODEX = 61,
  SmaliKind_INSTRUCTION_FORMAT22c_TYPE = 62,
  SmaliKind_INSTRUCTION_FORMAT22cs_FIELD = 63,
  SmaliKind_INSTRUCTION_FORMAT22s = 64,
  SmaliKind_INSTRUCTION_FORMAT22s_OR_ID = 65,
  SmaliKind_INSTRUCTION_FORMAT22t = 66,
  SmaliKind_INSTRUCTION_FORMAT22x = 67,
  SmaliKind_INSTRUCTION_FORMAT23x = 68,
  SmaliKind_INSTRUCTION_FORMAT30t = 69,
  SmaliKind_INSTRUCTION_FORMAT31c = 70,
  SmaliKind_INSTRUCTION_FORMAT31i = 71,
  SmaliKind_INSTRUCTION_FORMAT31i_OR_ID = 72,
  SmaliKind_INSTRUCTION_FORMAT31t = 73,
  SmaliKind_INSTRUCTION_FORMAT32x = 74,
  SmaliKind_INSTRUCTION_FORMAT35c_METHOD = 75,
  SmaliKind_INSTRUCTION_FORMAT35c_METHOD_ODEX = 76,
  SmaliKind_INSTRUCTION_FORMAT35c_TYPE = 77,
  SmaliKind_INSTRUCTION_FORMAT35mi_METHOD = 78,
  SmaliKind_INSTRUCTION_FORMAT35ms_METHOD = 79,
  SmaliKind_INSTRUCTION_FORMAT3rc_METHOD = 80,
  SmaliKind_INSTRUCTION_FORMAT3rc_METHOD_ODEX = 81,
  SmaliKind_INSTRUCTION_FORMAT3rc_TYPE = 82,
  SmaliKind_INSTRUCTION_FORMAT3rmi_METHOD = 83,
  SmaliKind_INSTRUCTION_FORMAT3rms_METHOD = 84,
  SmaliKind_INSTRUCTION_FORMAT45cc_METHOD = 85,
  SmaliKind_INSTRUCTION_FORMAT4rcc_METHOD = 86,
  SmaliKind_INSTRUCTION_FORMAT51l = 87,
  SmaliKind_INTEGER_LITERAL = 88,
  SmaliKind_INVALID_TOKEN = 89,
  SmaliKind_I_ACCESS_LIST = 90,
  SmaliKind_I_ANNOTATION = 91,
  SmaliKind_I_ANNOTATIONS = 92,
  SmaliKind_I_ANNOTATION_ELEMENT = 93,
  SmaliKind_I_ARRAY_ELEMENTS = 94,
  SmaliKind_I_ARRAY_ELEMENT_SIZE = 95,
  SmaliKind_I_CATCH = 96,
  SmaliKind_I_CATCHALL = 97,
  SmaliKind_I_CATCHES = 98,
  SmaliKind_I_CLASS_DEF = 99,
  SmaliKind_I_ENCODED_ARRAY = 100,
  SmaliKind_I_ENCODED_ENUM = 101,
  SmaliKind_I_ENCODED_FIELD = 102,
  SmaliKind_I_ENCODED_METHOD = 103,
  SmaliKind_I_END_LOCAL = 104,
  SmaliKind_I_EPILOGUE = 105,
  SmaliKind_I_FIELD = 106,
  SmaliKind_I_FIELDS = 107,
  SmaliKind_I_FIELD_INITIAL_VALUE = 108,
  SmaliKind_I_FIELD_TYPE = 109,
  SmaliKind_I_IMPLEMENTS = 110,
  SmaliKind_I_LABEL = 111,
  SmaliKind_I_LINE = 112,
  SmaliKind_I_LOCAL = 113,
  SmaliKind_I_LOCALS = 114,
  SmaliKind_I_METHOD = 115,
  SmaliKind_I_METHODS = 116,
  SmaliKind_I_METHOD_PROTOTYPE = 117,
  SmaliKind_I_METHOD_RETURN_TYPE = 118,
  SmaliKind_I_ORDERED_METHOD_ITEMS = 119,
  SmaliKind_I_PACKED_SWITCH_ELEMENTS = 120,
  SmaliKind_I_PACKED_SWITCH_START_KEY = 121,
  SmaliKind_I_PARAMETER = 122,
  SmaliKind_I_PARAMETERS = 123,
  SmaliKind_I_PARAMETER_NOT_SPECIFIED = 124,
  SmaliKind_I_PROLOGUE = 125,
  SmaliKind_I_REGISTERS = 126,
  SmaliKind_I_REGISTER_LIST = 127,
  SmaliKind_I_REGISTER_RANGE = 128,
  SmaliKind_I_RESTART_LOCAL = 129,
  SmaliKind_I_SOURCE = 130,
  SmaliKind_I_SPARSE_SWITCH_ELEMENTS = 131,
  SmaliKind_I_STATEMENT_ARRAY_DATA = 132,
  SmaliKind_I_STATEMENT_FORMAT10t = 133,
  SmaliKind_I_STATEMENT_FORMAT10x = 134,
  SmaliKind_I_STATEMENT_FORMAT11n = 135,
  SmaliKind_I_STATEMENT_FORMAT11x = 136,
  SmaliKind_I_STATEMENT_FORMAT12x = 137,
  SmaliKind_I_STATEMENT_FORMAT20bc = 138,
  SmaliKind_I_STATEMENT_FORMAT20t = 139,
  SmaliKind_I_STATEMENT_FORMAT21c_FIELD = 140,
  SmaliKind_I_STATEMENT_FORMAT21c_STRING = 141,
  SmaliKind_I_STATEMENT_FORMAT21c_TYPE = 142,
  SmaliKind_I_STATEMENT_FORMAT21ih = 143,
  SmaliKind_I_STATEMENT_FORMAT21lh = 144,
  SmaliKind_I_STATEMENT_FORMAT21s = 145,
  SmaliKind_I_STATEMENT_FORMAT21t = 146,
  SmaliKind_I_STATEMENT_FORMAT22b = 147,
  SmaliKind_I_STATEMENT_FORMAT22c_FIELD = 148,
  SmaliKind_I_STATEMENT_FORMAT22c_TYPE = 149,
  SmaliKind_I_STATEMENT_FORMAT22s = 150,
  SmaliKind_I_STATEMENT_FORMAT22t = 151,
  SmaliKind_I_STATEMENT_FORMAT22x = 152,
  SmaliKind_I_STATEMENT_FORMAT23x = 153,
  SmaliKind_I_STATEMENT_FORMAT30t = 154,
  SmaliKind_I_STATEMENT_FORMAT31c = 155,
  SmaliKind_I_STATEMENT_FORMAT31i = 156,
  SmaliKind_I_STATEMENT_FORMAT31t = 157,
  SmaliKind_I_STATEMENT_FORMAT32x = 158,
  SmaliKind_I_STATEMENT_FORMAT35c_METHOD = 159,
  SmaliKind_I_STATEMENT_FORMAT35c_TYPE = 160,
  SmaliKind_I_STATEMENT_FORMAT3rc_METHOD = 161,
  SmaliKind_I_STATEMENT_FORMAT3rc_TYPE = 162,
  SmaliKind_I_STATEMENT_FORMAT45cc_METHOD = 163,
  SmaliKind_I_STATEMENT_FORMAT4rcc_METHOD = 164,
  SmaliKind_I_STATEMENT_FORMAT51l = 165,
  SmaliKind_I_STATEMENT_PACKED_SWITCH = 166,
  SmaliKind_I_STATEMENT_SPARSE_SWITCH = 167,
  SmaliKind_I_SUBANNOTATION = 168,
  SmaliKind_I_SUPER = 169,
  SmaliKind_LINE_COMMENT = 170,
  SmaliKind_LINE_DIRECTIVE = 171,
  SmaliKind_LOCALS_DIRECTIVE = 172,
  SmaliKind_LOCAL_DIRECTIVE = 173,
  SmaliKind_LONG_LITERAL = 174,
  SmaliKind_MEMBER_NAME = 175,
  SmaliKind_METHOD_DIRECTIVE = 176,
  SmaliKind_NEGATIVE_INTEGER_LITERAL = 177,
  SmaliKind_NULL_LITERAL = 178,
  SmaliKind_OPEN_BRACE = 179,
  SmaliKind_OPEN_PAREN = 180,
  SmaliKind_PACKED_SWITCH_DIRECTIVE = 181,
  SmaliKind_PARAMETER_DIRECTIVE = 182,
  SmaliKind_PARAM_LIST_OR_ID_PRIMITIVE_TYPE = 183,
  SmaliKind_POSITIVE_INTEGER_LITERAL = 184,
  SmaliKind_PRIMITIVE_TYPE = 185,
  SmaliKind_PROLOGUE_DIRECTIVE = 186,
  SmaliKind_SMALI_REGISTER = 187,
  SmaliKind_REGISTERS_DIRECTIVE = 188,
  SmaliKind_RESTART_LOCAL_DIRECTIVE = 189,
  SmaliKind_SHORT_LITERAL = 190,
  SmaliKind_SIMPLE_NAME = 191,
  SmaliKind_SOURCE_DIRECTIVE = 192,
  SmaliKind_SPARSE_SWITCH_DIRECTIVE = 193,
  SmaliKind_STRING_LITERAL = 194,
  SmaliKind_SUBANNOTATION_DIRECTIVE = 195,
  SmaliKind_SUPER_DIRECTIVE = 196,
  SmaliKind_VERIFICATION_ERROR_TYPE = 197,
  SmaliKind_VOID_TYPE = 198,
  SmaliKind_VTABLE_INDEX = 199,
  SmaliKind_WHITE_SPACE = 200,
  SmaliKind_MIN = SmaliKind_INVALID,
  SmaliKind_MAX = SmaliKind_WHITE_SPACE
};

inline const char **EnumNamesSmaliKind() {
  static const char *names[] = {
    "INVALID",
    "EOR",
    "DOWN",
    "UP",
    "ACCESS_SPEC",
    "ANNOTATION_DIRECTIVE",
    "ANNOTATION_VISIBILITY",
    "ARRAY_DATA_DIRECTIVE",
    "ARRAY_TYPE_PREFIX",
    "ARROW",
    "BOOL_LITERAL",
    "BYTE_LITERAL",
    "CATCHALL_DIRECTIVE",
    "CATCH_DIRECTIVE",
    "CHAR_LITERAL",
    "CLASS_DESCRIPTOR",
    "CLASS_DIRECTIVE",
    "CLOSE_BRACE",
    "CLOSE_PAREN",
    "COLON",
    "COMMA",
    "DOTDOT",
    "DOUBLE_LITERAL",
    "DOUBLE_LITERAL_OR_ID",
    "END_ANNOTATION_DIRECTIVE",
    "END_ARRAY_DATA_DIRECTIVE",
    "END_FIELD_DIRECTIVE",
    "END_LOCAL_DIRECTIVE",
    "END_METHOD_DIRECTIVE",
    "END_PACKED_SWITCH_DIRECTIVE",
    "END_PARAMETER_DIRECTIVE",
    "END_SPARSE_SWITCH_DIRECTIVE",
    "END_SUBANNOTATION_DIRECTIVE",
    "ENUM_DIRECTIVE",
    "EPILOGUE_DIRECTIVE",
    "EQUAL",
    "FIELD_DIRECTIVE",
    "FIELD_OFFSET",
    "FLOAT_LITERAL",
    "FLOAT_LITERAL_OR_ID",
    "IMPLEMENTS_DIRECTIVE",
    "INLINE_INDEX",
    "INSTRUCTION_FORMAT10t",
    "INSTRUCTION_FORMAT10x",
    "INSTRUCTION_FORMAT10x_ODEX",
    "INSTRUCTION_FORMAT11n",
    "INSTRUCTION_FORMAT11x",
    "INSTRUCTION_FORMAT12x",
    "INSTRUCTION_FORMAT12x_OR_ID",
    "INSTRUCTION_FORMAT20bc",
    "INSTRUCTION_FORMAT20t",
    "INSTRUCTION_FORMAT21c_FIELD",
    "INSTRUCTION_FORMAT21c_FIELD_ODEX",
    "INSTRUCTION_FORMAT21c_STRING",
    "INSTRUCTION_FORMAT21c_TYPE",
    "INSTRUCTION_FORMAT21ih",
    "INSTRUCTION_FORMAT21lh",
    "INSTRUCTION_FORMAT21s",
    "INSTRUCTION_FORMAT21t",
    "INSTRUCTION_FORMAT22b",
    "INSTRUCTION_FORMAT22c_FIELD",
    "INSTRUCTION_FORMAT22c_FIELD_ODEX",
    "INSTRUCTION_FORMAT22c_TYPE",
    "INSTRUCTION_FORMAT22cs_FIELD",
    "INSTRUCTION_FORMAT22s",
    "INSTRUCTION_FORMAT22s_OR_ID",
    "INSTRUCTION_FORMAT22t",
    "INSTRUCTION_FORMAT22x",
    "INSTRUCTION_FORMAT23x",
    "INSTRUCTION_FORMAT30t",
    "INSTRUCTION_FORMAT31c",
    "INSTRUCTION_FORMAT31i",
    "INSTRUCTION_FORMAT31i_OR_ID",
    "INSTRUCTION_FORMAT31t",
    "INSTRUCTION_FORMAT32x",
    "INSTRUCTION_FORMAT35c_METHOD",
    "INSTRUCTION_FORMAT35c_METHOD_ODEX",
    "INSTRUCTION_FORMAT35c_TYPE",
    "INSTRUCTION_FORMAT35mi_METHOD",
    "INSTRUCTION_FORMAT35ms_METHOD",
    "INSTRUCTION_FORMAT3rc_METHOD",
    "INSTRUCTION_FORMAT3rc_METHOD_ODEX",
    "INSTRUCTION_FORMAT3rc_TYPE",
    "INSTRUCTION_FORMAT3rmi_METHOD",
    "INSTRUCTION_FORMAT3rms_METHOD",
    "INSTRUCTION_FORMAT45cc_METHOD",
    "INSTRUCTION_FORMAT4rcc_METHOD",
    "INSTRUCTION_FORMAT51l",
    "INTEGER_LITERAL",
    "INVALID_TOKEN",
    "I_ACCESS_LIST",
    "I_ANNOTATION",
    "I_ANNOTATIONS",
    "I_ANNOTATION_ELEMENT",
    "I_ARRAY_ELEMENTS",
    "I_ARRAY_ELEMENT_SIZE",
    "I_CATCH",
    "I_CATCHALL",
    "I_CATCHES",
    "I_CLASS_DEF",
    "I_ENCODED_ARRAY",
    "I_ENCODED_ENUM",
    "I_ENCODED_FIELD",
    "I_ENCODED_METHOD",
    "I_END_LOCAL",
    "I_EPILOGUE",
    "I_FIELD",
    "I_FIELDS",
    "I_FIELD_INITIAL_VALUE",
    "I_FIELD_TYPE",
    "I_IMPLEMENTS",
    "I_LABEL",
    "I_LINE",
    "I_LOCAL",
    "I_LOCALS",
    "I_METHOD",
    "I_METHODS",
    "I_METHOD_PROTOTYPE",
    "I_METHOD_RETURN_TYPE",
    "I_ORDERED_METHOD_ITEMS",
    "I_PACKED_SWITCH_ELEMENTS",
    "I_PACKED_SWITCH_START_KEY",
    "I_PARAMETER",
    "I_PARAMETERS",
    "I_PARAMETER_NOT_SPECIFIED",
    "I_PROLOGUE",
    "I_REGISTERS",
    "I_REGISTER_LIST",
    "I_REGISTER_RANGE",
    "I_RESTART_LOCAL",
    "I_SOURCE",
    "I_SPARSE_SWITCH_ELEMENTS",
    "I_STATEMENT_ARRAY_DATA",
    "I_STATEMENT_FORMAT10t",
    "I_STATEMENT_FORMAT10x",
    "I_STATEMENT_FORMAT11n",
    "I_STATEMENT_FORMAT11x",
    "I_STATEMENT_FORMAT12x",
    "I_STATEMENT_FORMAT20bc",
    "I_STATEMENT_FORMAT20t",
    "I_STATEMENT_FORMAT21c_FIELD",
    "I_STATEMENT_FORMAT21c_STRING",
    "I_STATEMENT_FORMAT21c_TYPE",
    "I_STATEMENT_FORMAT21ih",
    "I_STATEMENT_FORMAT21lh",
    "I_STATEMENT_FORMAT21s",
    "I_STATEMENT_FORMAT21t",
    "I_STATEMENT_FORMAT22b",
    "I_STATEMENT_FORMAT22c_FIELD",
    "I_STATEMENT_FORMAT22c_TYPE",
    "I_STATEMENT_FORMAT22s",
    "I_STATEMENT_FORMAT22t",
    "I_STATEMENT_FORMAT22x",
    "I_STATEMENT_FORMAT23x",
    "I_STATEMENT_FORMAT30t",
    "I_STATEMENT_FORMAT31c",
    "I_STATEMENT_FORMAT31i",
    "I_STATEMENT_FORMAT31t",
    "I_STATEMENT_FORMAT32x",
    "I_STATEMENT_FORMAT35c_METHOD",
    "I_STATEMENT_FORMAT35c_TYPE",
    "I_STATEMENT_FORMAT3rc_METHOD",
    "I_STATEMENT_FORMAT3rc_TYPE",
    "I_STATEMENT_FORMAT45cc_METHOD",
    "I_STATEMENT_FORMAT4rcc_METHOD",
    "I_STATEMENT_FORMAT51l",
    "I_STATEMENT_PACKED_SWITCH",
    "I_STATEMENT_SPARSE_SWITCH",
    "I_SUBANNOTATION",
    "I_SUPER",
    "LINE_COMMENT",
    "LINE_DIRECTIVE",
    "LOCALS_DIRECTIVE",
    "LOCAL_DIRECTIVE",
    "LONG_LITERAL",
    "MEMBER_NAME",
    "METHOD_DIRECTIVE",
    "NEGATIVE_INTEGER_LITERAL",
    "NULL_LITERAL",
    "OPEN_BRACE",
    "OPEN_PAREN",
    "PACKED_SWITCH_DIRECTIVE",
    "PARAMETER_DIRECTIVE",
    "PARAM_LIST_OR_ID_PRIMITIVE_TYPE",
    "POSITIVE_INTEGER_LITERAL",
    "PRIMITIVE_TYPE",
    "PROLOGUE_DIRECTIVE",
    "SMALI_REGISTER",
    "REGISTERS_DIRECTIVE",
    "RESTART_LOCAL_DIRECTIVE",
    "SHORT_LITERAL",
    "SIMPLE_NAME",
    "SOURCE_DIRECTIVE",
    "SPARSE_SWITCH_DIRECTIVE",
    "STRING_LITERAL",
    "SUBANNOTATION_DIRECTIVE",
    "SUPER_DIRECTIVE",
    "VERIFICATION_ERROR_TYPE",
    "VOID_TYPE",
    "VTABLE_INDEX",
    "WHITE_SPACE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSmaliKind(SmaliKind e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSmaliKind()[index];
}

namespace _Unit {

enum LanguageType {
  LanguageType_ALL = 0,
  LanguageType_OO = 1,
  LanguageType_CXX = 2,
  LanguageType_C = 3,
  LanguageType_C_FAMILY = 4,
  LanguageType_JAVA = 5,
  LanguageType_CSHARP = 6,
  LanguageType_OBJECTIVE_C = 7,
  LanguageType_MIN = LanguageType_ALL,
  LanguageType_MAX = LanguageType_OBJECTIVE_C
};

inline const char **EnumNamesLanguageType() {
  static const char *names[] = {
    "ALL",
    "OO",
    "CXX",
    "C",
    "C_FAMILY",
    "JAVA",
    "CSHARP",
    "OBJECTIVE_C",
    nullptr
  };
  return names;
}

inline const char *EnumNameLanguageType(LanguageType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLanguageType()[index];
}

}  // namespace _Unit

namespace _Literal {

enum LiteralType {
  LiteralType_number_type = 0,
  LiteralType_char_type = 1,
  LiteralType_string_type = 2,
  LiteralType_boolean_type = 3,
  LiteralType_null_type = 4,
  LiteralType_MIN = LiteralType_number_type,
  LiteralType_MAX = LiteralType_null_type
};

inline const char **EnumNamesLiteralType() {
  static const char *names[] = {
    "number_type",
    "char_type",
    "string_type",
    "boolean_type",
    "null_type",
    nullptr
  };
  return names;
}

inline const char *EnumNameLiteralType(LiteralType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLiteralType()[index];
}

}  // namespace _Literal
}  // namespace _Element

namespace _Delta {
namespace _Diff {

enum DeltaType {
  DeltaType_MATCH = 0,
  DeltaType_ADD = 1,
  DeltaType_DEL = 2,
  DeltaType_MOVE = 3,
  DeltaType_UPDATE = 4,
  DeltaType_MIN = DeltaType_MATCH,
  DeltaType_MAX = DeltaType_UPDATE
};

inline const char **EnumNamesDeltaType() {
  static const char *names[] = {
    "MATCH",
    "ADD",
    "DEL",
    "MOVE",
    "UPDATE",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeltaType(DeltaType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDeltaType()[index];
}

}  // namespace _Diff
}  // namespace _Delta

namespace _Pairs {
namespace _Pair {

enum CloneType {
  CloneType_MAYBE = 0,
  CloneType_YES = 1,
  CloneType_NO = 2,
  CloneType_MIN = CloneType_MAYBE,
  CloneType_MAX = CloneType_NO
};

inline const char **EnumNamesCloneType() {
  static const char *names[] = {
    "MAYBE",
    "YES",
    "NO",
    nullptr
  };
  return names;
}

inline const char *EnumNameCloneType(CloneType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCloneType()[index];
}

}  // namespace _Pair
}  // namespace _Pairs

struct Element FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KIND = 4,
    VT_TEXT = 6,
    VT_TAIL = 8,
    VT_POS = 10,
    VT_LENGTH = 12,
    VT_CHILD = 14,
    VT_EXTRA = 16,
    VT_LINE = 18,
    VT_COLUMN = 20
  };
  int32_t kind() const {
    return GetField<int32_t>(VT_KIND, 0);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  const flatbuffers::String *tail() const {
    return GetPointer<const flatbuffers::String *>(VT_TAIL);
  }
  int32_t pos() const {
    return GetField<int32_t>(VT_POS, 0);
  }
  int32_t length() const {
    return GetField<int32_t>(VT_LENGTH, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Element>> *child() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Element>> *>(VT_CHILD);
  }
  const _fast::_Element::Anonymous0 *extra() const {
    return GetPointer<const _fast::_Element::Anonymous0 *>(VT_EXTRA);
  }
  int32_t line() const {
    return GetField<int32_t>(VT_LINE, 0);
  }
  int32_t column() const {
    return GetField<int32_t>(VT_COLUMN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KIND) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TAIL) &&
           verifier.Verify(tail()) &&
           VerifyField<int32_t>(verifier, VT_POS) &&
           VerifyField<int32_t>(verifier, VT_LENGTH) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CHILD) &&
           verifier.Verify(child()) &&
           verifier.VerifyVectorOfTables(child()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EXTRA) &&
           verifier.VerifyTable(extra()) &&
           VerifyField<int32_t>(verifier, VT_LINE) &&
           VerifyField<int32_t>(verifier, VT_COLUMN) &&
           verifier.EndTable();
  }
};

struct ElementBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kind(int32_t kind) {
    fbb_.AddElement<int32_t>(Element::VT_KIND, kind, 0);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(Element::VT_TEXT, text);
  }
  void add_tail(flatbuffers::Offset<flatbuffers::String> tail) {
    fbb_.AddOffset(Element::VT_TAIL, tail);
  }
  void add_pos(int32_t pos) {
    fbb_.AddElement<int32_t>(Element::VT_POS, pos, 0);
  }
  void add_length(int32_t length) {
    fbb_.AddElement<int32_t>(Element::VT_LENGTH, length, 0);
  }
  void add_child(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Element>>> child) {
    fbb_.AddOffset(Element::VT_CHILD, child);
  }
  void add_extra(flatbuffers::Offset<_fast::_Element::Anonymous0> extra) {
    fbb_.AddOffset(Element::VT_EXTRA, extra);
  }
  void add_line(int32_t line) {
    fbb_.AddElement<int32_t>(Element::VT_LINE, line, 0);
  }
  void add_column(int32_t column) {
    fbb_.AddElement<int32_t>(Element::VT_COLUMN, column, 0);
  }
  ElementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ElementBuilder &operator=(const ElementBuilder &);
  flatbuffers::Offset<Element> Finish() {
    const auto end = fbb_.EndTable(start_, 9);
    auto o = flatbuffers::Offset<Element>(end);
    return o;
  }
};

inline flatbuffers::Offset<Element> CreateElement(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kind = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    flatbuffers::Offset<flatbuffers::String> tail = 0,
    int32_t pos = 0,
    int32_t length = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Element>>> child = 0,
    flatbuffers::Offset<_fast::_Element::Anonymous0> extra = 0,
    int32_t line = 0,
    int32_t column = 0) {
  ElementBuilder builder_(_fbb);
  builder_.add_column(column);
  builder_.add_line(line);
  builder_.add_extra(extra);
  builder_.add_child(child);
  builder_.add_length(length);
  builder_.add_pos(pos);
  builder_.add_tail(tail);
  builder_.add_text(text);
  builder_.add_kind(kind);
  return builder_.Finish();
}

inline flatbuffers::Offset<Element> CreateElementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kind = 0,
    const char *text = nullptr,
    const char *tail = nullptr,
    int32_t pos = 0,
    int32_t length = 0,
    const std::vector<flatbuffers::Offset<Element>> *child = nullptr,
    flatbuffers::Offset<_fast::_Element::Anonymous0> extra = 0,
    int32_t line = 0,
    int32_t column = 0) {
  return _fast::CreateElement(
      _fbb,
      kind,
      text ? _fbb.CreateString(text) : 0,
      tail ? _fbb.CreateString(tail) : 0,
      pos,
      length,
      child ? _fbb.CreateVector<flatbuffers::Offset<Element>>(*child) : 0,
      extra,
      line,
      column);
}

namespace _Element {

struct Anonymous0 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UNIT = 4,
    VT_LITERAL = 6
  };
  const Unit *unit() const {
    return GetPointer<const Unit *>(VT_UNIT);
  }
  const Literal *literal() const {
    return GetPointer<const Literal *>(VT_LITERAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UNIT) &&
           verifier.VerifyTable(unit()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LITERAL) &&
           verifier.VerifyTable(literal()) &&
           verifier.EndTable();
  }
};

struct Anonymous0Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_unit(flatbuffers::Offset<Unit> unit) {
    fbb_.AddOffset(Anonymous0::VT_UNIT, unit);
  }
  void add_literal(flatbuffers::Offset<Literal> literal) {
    fbb_.AddOffset(Anonymous0::VT_LITERAL, literal);
  }
  Anonymous0Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Anonymous0Builder &operator=(const Anonymous0Builder &);
  flatbuffers::Offset<Anonymous0> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Anonymous0>(end);
    return o;
  }
};

inline flatbuffers::Offset<Anonymous0> CreateAnonymous0(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Unit> unit = 0,
    flatbuffers::Offset<Literal> literal = 0) {
  Anonymous0Builder builder_(_fbb);
  builder_.add_literal(literal);
  builder_.add_unit(unit);
  return builder_.Finish();
}

struct Unit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FILENAME = 4,
    VT_REVISION = 6,
    VT_LANGUAGE = 8,
    VT_ITEM = 10
  };
  const flatbuffers::String *filename() const {
    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
  }
  const flatbuffers::String *revision() const {
    return GetPointer<const flatbuffers::String *>(VT_REVISION);
  }
  int32_t language() const {
    return GetField<int32_t>(VT_LANGUAGE, 0);
  }
  int32_t item() const {
    return GetField<int32_t>(VT_ITEM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FILENAME) &&
           verifier.Verify(filename()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_REVISION) &&
           verifier.Verify(revision()) &&
           VerifyField<int32_t>(verifier, VT_LANGUAGE) &&
           VerifyField<int32_t>(verifier, VT_ITEM) &&
           verifier.EndTable();
  }
};

struct UnitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) {
    fbb_.AddOffset(Unit::VT_FILENAME, filename);
  }
  void add_revision(flatbuffers::Offset<flatbuffers::String> revision) {
    fbb_.AddOffset(Unit::VT_REVISION, revision);
  }
  void add_language(int32_t language) {
    fbb_.AddElement<int32_t>(Unit::VT_LANGUAGE, language, 0);
  }
  void add_item(int32_t item) {
    fbb_.AddElement<int32_t>(Unit::VT_ITEM, item, 0);
  }
  UnitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnitBuilder &operator=(const UnitBuilder &);
  flatbuffers::Offset<Unit> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Unit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unit> CreateUnit(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> filename = 0,
    flatbuffers::Offset<flatbuffers::String> revision = 0,
    int32_t language = 0,
    int32_t item = 0) {
  UnitBuilder builder_(_fbb);
  builder_.add_item(item);
  builder_.add_language(language);
  builder_.add_revision(revision);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline flatbuffers::Offset<Unit> CreateUnitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr,
    const char *revision = nullptr,
    int32_t language = 0,
    int32_t item = 0) {
  return _fast::_Element::CreateUnit(
      _fbb,
      filename ? _fbb.CreateString(filename) : 0,
      revision ? _fbb.CreateString(revision) : 0,
      language,
      item);
}

struct Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct LiteralBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Literal::VT_TYPE, type, 0);
  }
  LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiteralBuilder &operator=(const LiteralBuilder &);
  flatbuffers::Offset<Literal> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Literal> CreateLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0) {
  LiteralBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

}  // namespace _Element

struct Delta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_DST = 6,
    VT_DIFF = 8
  };
  const flatbuffers::String *src() const {
    return GetPointer<const flatbuffers::String *>(VT_SRC);
  }
  const flatbuffers::String *dst() const {
    return GetPointer<const flatbuffers::String *>(VT_DST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Delta::Diff>> *diff() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Delta::Diff>> *>(VT_DIFF);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SRC) &&
           verifier.Verify(src()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DST) &&
           verifier.Verify(dst()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DIFF) &&
           verifier.Verify(diff()) &&
           verifier.VerifyVectorOfTables(diff()) &&
           verifier.EndTable();
  }
};

struct DeltaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(flatbuffers::Offset<flatbuffers::String> src) {
    fbb_.AddOffset(Delta::VT_SRC, src);
  }
  void add_dst(flatbuffers::Offset<flatbuffers::String> dst) {
    fbb_.AddOffset(Delta::VT_DST, dst);
  }
  void add_diff(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Delta::Diff>>> diff) {
    fbb_.AddOffset(Delta::VT_DIFF, diff);
  }
  DeltaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeltaBuilder &operator=(const DeltaBuilder &);
  flatbuffers::Offset<Delta> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Delta>(end);
    return o;
  }
};

inline flatbuffers::Offset<Delta> CreateDelta(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> src = 0,
    flatbuffers::Offset<flatbuffers::String> dst = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Delta::Diff>>> diff = 0) {
  DeltaBuilder builder_(_fbb);
  builder_.add_diff(diff);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

inline flatbuffers::Offset<Delta> CreateDeltaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *src = nullptr,
    const char *dst = nullptr,
    const std::vector<flatbuffers::Offset<_fast::_Delta::Diff>> *diff = nullptr) {
  return _fast::CreateDelta(
      _fbb,
      src ? _fbb.CreateString(src) : 0,
      dst ? _fbb.CreateString(dst) : 0,
      diff ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Delta::Diff>>(*diff) : 0);
}

namespace _Delta {

struct Diff FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_DELTA = 6
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const _fast::_Delta::_Diff::Anonymous1 *delta() const {
    return GetPointer<const _fast::_Delta::_Diff::Anonymous1 *>(VT_DELTA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DELTA) &&
           verifier.VerifyTable(delta()) &&
           verifier.EndTable();
  }
};

struct DiffBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Diff::VT_TYPE, type, 0);
  }
  void add_delta(flatbuffers::Offset<_fast::_Delta::_Diff::Anonymous1> delta) {
    fbb_.AddOffset(Diff::VT_DELTA, delta);
  }
  DiffBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiffBuilder &operator=(const DiffBuilder &);
  flatbuffers::Offset<Diff> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Diff>(end);
    return o;
  }
};

inline flatbuffers::Offset<Diff> CreateDiff(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    flatbuffers::Offset<_fast::_Delta::_Diff::Anonymous1> delta = 0) {
  DiffBuilder builder_(_fbb);
  builder_.add_delta(delta);
  builder_.add_type(type);
  return builder_.Finish();
}

namespace _Diff {

struct Anonymous1 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MATCH = 4,
    VT_ADD = 6,
    VT_DEL = 8,
    VT_MOVE = 10,
    VT_UPDATE = 12
  };
  const Match *match() const {
    return GetPointer<const Match *>(VT_MATCH);
  }
  const Add *add() const {
    return GetPointer<const Add *>(VT_ADD);
  }
  const Del *del() const {
    return GetPointer<const Del *>(VT_DEL);
  }
  const Move *move() const {
    return GetPointer<const Move *>(VT_MOVE);
  }
  const Update *update() const {
    return GetPointer<const Update *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MATCH) &&
           verifier.VerifyTable(match()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADD) &&
           verifier.VerifyTable(add()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DEL) &&
           verifier.VerifyTable(del()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MOVE) &&
           verifier.VerifyTable(move()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
};

struct Anonymous1Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_match(flatbuffers::Offset<Match> match) {
    fbb_.AddOffset(Anonymous1::VT_MATCH, match);
  }
  void add_add(flatbuffers::Offset<Add> add) {
    fbb_.AddOffset(Anonymous1::VT_ADD, add);
  }
  void add_del(flatbuffers::Offset<Del> del) {
    fbb_.AddOffset(Anonymous1::VT_DEL, del);
  }
  void add_move(flatbuffers::Offset<Move> move) {
    fbb_.AddOffset(Anonymous1::VT_MOVE, move);
  }
  void add_update(flatbuffers::Offset<Update> update) {
    fbb_.AddOffset(Anonymous1::VT_UPDATE, update);
  }
  Anonymous1Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Anonymous1Builder &operator=(const Anonymous1Builder &);
  flatbuffers::Offset<Anonymous1> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<Anonymous1>(end);
    return o;
  }
};

inline flatbuffers::Offset<Anonymous1> CreateAnonymous1(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Match> match = 0,
    flatbuffers::Offset<Add> add = 0,
    flatbuffers::Offset<Del> del = 0,
    flatbuffers::Offset<Move> move = 0,
    flatbuffers::Offset<Update> update = 0) {
  Anonymous1Builder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_move(move);
  builder_.add_del(del);
  builder_.add_add(add);
  builder_.add_match(match);
  return builder_.Finish();
}

struct Match FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_DST = 6
  };
  int32_t src() const {
    return GetField<int32_t>(VT_SRC, 0);
  }
  int32_t dst() const {
    return GetField<int32_t>(VT_DST, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRC) &&
           VerifyField<int32_t>(verifier, VT_DST) &&
           verifier.EndTable();
  }
};

struct MatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(int32_t src) {
    fbb_.AddElement<int32_t>(Match::VT_SRC, src, 0);
  }
  void add_dst(int32_t dst) {
    fbb_.AddElement<int32_t>(Match::VT_DST, dst, 0);
  }
  MatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatchBuilder &operator=(const MatchBuilder &);
  flatbuffers::Offset<Match> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Match>(end);
    return o;
  }
};

inline flatbuffers::Offset<Match> CreateMatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0,
    int32_t dst = 0) {
  MatchBuilder builder_(_fbb);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

struct Add FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_DST = 6,
    VT_POSITION = 8
  };
  int32_t src() const {
    return GetField<int32_t>(VT_SRC, 0);
  }
  int32_t dst() const {
    return GetField<int32_t>(VT_DST, 0);
  }
  int32_t position() const {
    return GetField<int32_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRC) &&
           VerifyField<int32_t>(verifier, VT_DST) &&
           VerifyField<int32_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct AddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(int32_t src) {
    fbb_.AddElement<int32_t>(Add::VT_SRC, src, 0);
  }
  void add_dst(int32_t dst) {
    fbb_.AddElement<int32_t>(Add::VT_DST, dst, 0);
  }
  void add_position(int32_t position) {
    fbb_.AddElement<int32_t>(Add::VT_POSITION, position, 0);
  }
  AddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddBuilder &operator=(const AddBuilder &);
  flatbuffers::Offset<Add> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Add>(end);
    return o;
  }
};

inline flatbuffers::Offset<Add> CreateAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0,
    int32_t dst = 0,
    int32_t position = 0) {
  AddBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

struct Del FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4
  };
  int32_t src() const {
    return GetField<int32_t>(VT_SRC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRC) &&
           verifier.EndTable();
  }
};

struct DelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(int32_t src) {
    fbb_.AddElement<int32_t>(Del::VT_SRC, src, 0);
  }
  DelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DelBuilder &operator=(const DelBuilder &);
  flatbuffers::Offset<Del> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Del>(end);
    return o;
  }
};

inline flatbuffers::Offset<Del> CreateDel(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0) {
  DelBuilder builder_(_fbb);
  builder_.add_src(src);
  return builder_.Finish();
}

struct Move FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_DST = 6,
    VT_POSITION = 8
  };
  int32_t src() const {
    return GetField<int32_t>(VT_SRC, 0);
  }
  int32_t dst() const {
    return GetField<int32_t>(VT_DST, 0);
  }
  int32_t position() const {
    return GetField<int32_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRC) &&
           VerifyField<int32_t>(verifier, VT_DST) &&
           VerifyField<int32_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct MoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(int32_t src) {
    fbb_.AddElement<int32_t>(Move::VT_SRC, src, 0);
  }
  void add_dst(int32_t dst) {
    fbb_.AddElement<int32_t>(Move::VT_DST, dst, 0);
  }
  void add_position(int32_t position) {
    fbb_.AddElement<int32_t>(Move::VT_POSITION, position, 0);
  }
  MoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveBuilder &operator=(const MoveBuilder &);
  flatbuffers::Offset<Move> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Move>(end);
    return o;
  }
};

inline flatbuffers::Offset<Move> CreateMove(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0,
    int32_t dst = 0,
    int32_t position = 0) {
  MoveBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

struct Update FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_LABEL = 6
  };
  int32_t src() const {
    return GetField<int32_t>(VT_SRC, 0);
  }
  const flatbuffers::String *label() const {
    return GetPointer<const flatbuffers::String *>(VT_LABEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRC) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LABEL) &&
           verifier.Verify(label()) &&
           verifier.EndTable();
  }
};

struct UpdateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(int32_t src) {
    fbb_.AddElement<int32_t>(Update::VT_SRC, src, 0);
  }
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(Update::VT_LABEL, label);
  }
  UpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdateBuilder &operator=(const UpdateBuilder &);
  flatbuffers::Offset<Update> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Update>(end);
    return o;
  }
};

inline flatbuffers::Offset<Update> CreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0,
    flatbuffers::Offset<flatbuffers::String> label = 0) {
  UpdateBuilder builder_(_fbb);
  builder_.add_label(label);
  builder_.add_src(src);
  return builder_.Finish();
}

inline flatbuffers::Offset<Update> CreateUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0,
    const char *label = nullptr) {
  return _fast::_Delta::_Diff::CreateUpdate(
      _fbb,
      src,
      label ? _fbb.CreateString(label) : 0);
}

}  // namespace _Diff
}  // namespace _Delta

struct Pairs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PAIR = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Pairs::Pair>> *pair() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Pairs::Pair>> *>(VT_PAIR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PAIR) &&
           verifier.Verify(pair()) &&
           verifier.VerifyVectorOfTables(pair()) &&
           verifier.EndTable();
  }
};

struct PairsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pair(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Pairs::Pair>>> pair) {
    fbb_.AddOffset(Pairs::VT_PAIR, pair);
  }
  PairsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PairsBuilder &operator=(const PairsBuilder &);
  flatbuffers::Offset<Pairs> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Pairs>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pairs> CreatePairs(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Pairs::Pair>>> pair = 0) {
  PairsBuilder builder_(_fbb);
  builder_.add_pair(pair);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pairs> CreatePairsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<_fast::_Pairs::Pair>> *pair = nullptr) {
  return _fast::CreatePairs(
      _fbb,
      pair ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Pairs::Pair>>(*pair) : 0);
}

namespace _Pairs {

struct Pair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PROJECT = 4,
    VT_LEFT = 6,
    VT_RIGHT = 8,
    VT_TYPE = 10
  };
  const flatbuffers::String *project() const {
    return GetPointer<const flatbuffers::String *>(VT_PROJECT);
  }
  const _fast::_Pairs::_Pair::Diff *left() const {
    return GetPointer<const _fast::_Pairs::_Pair::Diff *>(VT_LEFT);
  }
  const _fast::_Pairs::_Pair::Diff *right() const {
    return GetPointer<const _fast::_Pairs::_Pair::Diff *>(VT_RIGHT);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PROJECT) &&
           verifier.Verify(project()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LEFT) &&
           verifier.VerifyTable(left()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RIGHT) &&
           verifier.VerifyTable(right()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct PairBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_project(flatbuffers::Offset<flatbuffers::String> project) {
    fbb_.AddOffset(Pair::VT_PROJECT, project);
  }
  void add_left(flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> left) {
    fbb_.AddOffset(Pair::VT_LEFT, left);
  }
  void add_right(flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> right) {
    fbb_.AddOffset(Pair::VT_RIGHT, right);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Pair::VT_TYPE, type, 0);
  }
  PairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PairBuilder &operator=(const PairBuilder &);
  flatbuffers::Offset<Pair> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Pair>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pair> CreatePair(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> project = 0,
    flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> left = 0,
    flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> right = 0,
    int32_t type = 0) {
  PairBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_right(right);
  builder_.add_left(left);
  builder_.add_project(project);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pair> CreatePairDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *project = nullptr,
    flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> left = 0,
    flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> right = 0,
    int32_t type = 0) {
  return _fast::_Pairs::CreatePair(
      _fbb,
      project ? _fbb.CreateString(project) : 0,
      left,
      right,
      type);
}

namespace _Pair {

struct Diff FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LEFT_LINE = 4,
    VT_LEFT_COLUMN = 6,
    VT_RIGHT_LINE = 8,
    VT_RIGHT_COLUMN = 10,
    VT_OLD_CODE = 12,
    VT_NEW_CODE = 14
  };
  int32_t left_line() const {
    return GetField<int32_t>(VT_LEFT_LINE, 0);
  }
  int32_t left_column() const {
    return GetField<int32_t>(VT_LEFT_COLUMN, 0);
  }
  int32_t right_line() const {
    return GetField<int32_t>(VT_RIGHT_LINE, 0);
  }
  int32_t right_column() const {
    return GetField<int32_t>(VT_RIGHT_COLUMN, 0);
  }
  const _fast::Element *old_code() const {
    return GetPointer<const _fast::Element *>(VT_OLD_CODE);
  }
  const _fast::Element *new_code() const {
    return GetPointer<const _fast::Element *>(VT_NEW_CODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LEFT_LINE) &&
           VerifyField<int32_t>(verifier, VT_LEFT_COLUMN) &&
           VerifyField<int32_t>(verifier, VT_RIGHT_LINE) &&
           VerifyField<int32_t>(verifier, VT_RIGHT_COLUMN) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OLD_CODE) &&
           verifier.VerifyTable(old_code()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NEW_CODE) &&
           verifier.VerifyTable(new_code()) &&
           verifier.EndTable();
  }
};

struct DiffBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_left_line(int32_t left_line) {
    fbb_.AddElement<int32_t>(Diff::VT_LEFT_LINE, left_line, 0);
  }
  void add_left_column(int32_t left_column) {
    fbb_.AddElement<int32_t>(Diff::VT_LEFT_COLUMN, left_column, 0);
  }
  void add_right_line(int32_t right_line) {
    fbb_.AddElement<int32_t>(Diff::VT_RIGHT_LINE, right_line, 0);
  }
  void add_right_column(int32_t right_column) {
    fbb_.AddElement<int32_t>(Diff::VT_RIGHT_COLUMN, right_column, 0);
  }
  void add_old_code(flatbuffers::Offset<_fast::Element> old_code) {
    fbb_.AddOffset(Diff::VT_OLD_CODE, old_code);
  }
  void add_new_code(flatbuffers::Offset<_fast::Element> new_code) {
    fbb_.AddOffset(Diff::VT_NEW_CODE, new_code);
  }
  DiffBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiffBuilder &operator=(const DiffBuilder &);
  flatbuffers::Offset<Diff> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<Diff>(end);
    return o;
  }
};

inline flatbuffers::Offset<Diff> CreateDiff(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t left_line = 0,
    int32_t left_column = 0,
    int32_t right_line = 0,
    int32_t right_column = 0,
    flatbuffers::Offset<_fast::Element> old_code = 0,
    flatbuffers::Offset<_fast::Element> new_code = 0) {
  DiffBuilder builder_(_fbb);
  builder_.add_new_code(new_code);
  builder_.add_old_code(old_code);
  builder_.add_right_column(right_column);
  builder_.add_right_line(right_line);
  builder_.add_left_column(left_column);
  builder_.add_left_line(left_line);
  return builder_.Finish();
}

}  // namespace _Pair
}  // namespace _Pairs

namespace _Element {

}  // namespace _Element

namespace _Delta {

namespace _Diff {

}  // namespace _Diff
}  // namespace _Delta

namespace _Pairs {

namespace _Pair {

}  // namespace _Pair
}  // namespace _Pairs
}  // namespace _fast

#endif  // FLATBUFFERS_GENERATED_FAST__FAST__PAIRS__PAIR_H_
