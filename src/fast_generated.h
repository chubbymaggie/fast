// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FAST__FAST__DATA_H_
#define FLATBUFFERS_GENERATED_FAST__FAST__DATA_H_

#include "flatbuffers/flatbuffers.h"

namespace _fast {

struct Element;

namespace _Element {

struct Anonymous0;

struct Unit;

struct Literal;

}  // namespace _Element

struct Delta;

namespace _Delta {

struct Diff;

namespace _Diff {

struct Anonymous1;

struct Match;

struct Add;

struct Del;

struct Move;

struct Update;

}  // namespace _Diff
}  // namespace _Delta

struct Pairs;

namespace _Pairs {

struct Pair;

namespace _Pair {

struct Diff;

}  // namespace _Pair
}  // namespace _Pairs

struct Log;

namespace _Log {

struct Commit;

namespace _Commit {

struct Anonymous2;

struct Committer;

struct Diff;

namespace _Diff {

struct Hunk;

namespace _Hunk {

struct ModLine;

}  // namespace _Hunk
}  // namespace _Diff
}  // namespace _Commit

struct Author;

}  // namespace _Log

struct Slices;

namespace _Slices {

struct Slice;

namespace _Slice {

struct SourceFile;

namespace _SourceFile {

struct Function;

namespace _Function {

struct Variable;

namespace _Variable {

struct Position;

struct FunctionDecl;

}  // namespace _Variable
}  // namespace _Function
}  // namespace _SourceFile
}  // namespace _Slice
}  // namespace _Slices

struct Data;

namespace _Data {

struct Anonymous3;

}  // namespace _Data

namespace _Element {

enum Kind {
  Kind_UNIT_KIND = 0,
  Kind_DECL = 1,
  Kind_DECL_STMT = 2,
  Kind_INIT = 3,
  Kind_EXPR = 4,
  Kind_EXPR_STMT = 5,
  Kind_COMMENT = 6,
  Kind_CALL = 7,
  Kind_CONTROL = 8,
  Kind_INCR = 9,
  Kind_NONE = 10,
  Kind_VARIABLE = 11,
  Kind_FUNCTION = 12,
  Kind_FUNCTION_DECL = 13,
  Kind_CONSTRUCTOR = 14,
  Kind_CONSTRUCTOR_DECL = 15,
  Kind_DESTRUCTOR = 16,
  Kind_DESTRUCTOR_DECL = 17,
  Kind_MACRO = 18,
  Kind_SINGLE_MACRO = 19,
  Kind_NULLOPERATOR = 20,
  Kind_ENUM_DEFN = 21,
  Kind_ENUM_DECL = 22,
  Kind_GLOBAL_ATTRIBUTE = 23,
  Kind_PROPERTY_ACCESSOR = 24,
  Kind_PROPERTY_ACCESSOR_DECL = 25,
  Kind_EXPRESSION = 26,
  Kind_CLASS_DEFN = 27,
  Kind_CLASS_DECL = 28,
  Kind_UNION_DEFN = 29,
  Kind_UNION_DECL = 30,
  Kind_STRUCT_DEFN = 31,
  Kind_STRUCT_DECL = 32,
  Kind_INTERFACE_DEFN = 33,
  Kind_INTERFACE_DECL = 34,
  Kind_ACCESS_REGION = 35,
  Kind_USING = 36,
  Kind_OPERATOR_FUNCTION = 37,
  Kind_OPERATOR_FUNCTION_DECL = 38,
  Kind_EVENT = 39,
  Kind_PROPERTY = 40,
  Kind_ANNOTATION_DEFN = 41,
  Kind_GLOBAL_TEMPLATE = 42,
  Kind_UNIT = 43,
  Kind_TART_ELEMENT_TOKEN = 44,
  Kind_NOP = 45,
  Kind_STRING = 46,
  Kind_CHAR = 47,
  Kind_LITERAL = 48,
  Kind_BOOLEAN = 49,
  Kind_NULL = 50,
  Kind_COMPLEX = 51,
  Kind_OPERATOR = 52,
  Kind_MODIFIER = 53,
  Kind_NAME = 54,
  Kind_ONAME = 55,
  Kind_CNAME = 56,
  Kind_TYPE = 57,
  Kind_TYPEPREV = 58,
  Kind_CONDITION = 59,
  Kind_BLOCK = 60,
  Kind_PSEUDO_BLOCK = 61,
  Kind_INDEX = 62,
  Kind_ENUM = 63,
  Kind_ENUM_DECLARATION = 64,
  Kind_IF_STATEMENT = 65,
  Kind_TERNARY = 66,
  Kind_THEN = 67,
  Kind_ELSE = 68,
  Kind_ELSEIF = 69,
  Kind_WHILE_STATEMENT = 70,
  Kind_DO_STATEMENT = 71,
  Kind_FOR_STATEMENT = 72,
  Kind_FOREACH_STATEMENT = 73,
  Kind_FOR_CONTROL = 74,
  Kind_FOR_INITIALIZATION = 75,
  Kind_FOR_CONDITION = 76,
  Kind_FOR_INCREMENT = 77,
  Kind_FOR_LIKE_CONTROL = 78,
  Kind_EXPRESSION_STATEMENT = 79,
  Kind_FUNCTION_CALL = 81,
  Kind_DECLARATION_STATEMENT = 82,
  Kind_DECLARATION = 83,
  Kind_DECLARATION_INITIALIZATION = 84,
  Kind_DECLARATION_RANGE = 85,
  Kind_RANGE = 86,
  Kind_GOTO_STATEMENT = 87,
  Kind_CONTINUE_STATEMENT = 88,
  Kind_BREAK_STATEMENT = 89,
  Kind_LABEL_STATEMENT = 90,
  Kind_LABEL = 91,
  Kind_SWITCH = 92,
  Kind_CASE = 93,
  Kind_DEFAULT = 94,
  Kind_FUNCTION_DEFINITION = 95,
  Kind_FUNCTION_DECLARATION = 96,
  Kind_LAMBDA = 97,
  Kind_FUNCTION_LAMBDA = 98,
  Kind_FUNCTION_SPECIFIER = 99,
  Kind_RETURN_STATEMENT = 100,
  Kind_PARAMETER_LIST = 101,
  Kind_PARAMETER = 102,
  Kind_KRPARAMETER_LIST = 103,
  Kind_KRPARAMETER = 104,
  Kind_ARGUMENT_LIST = 105,
  Kind_ARGUMENT = 106,
  Kind_PSEUDO_PARAMETER_LIST = 107,
  Kind_INDEXER_PARAMETER_LIST = 108,
  Kind_CLASS = 109,
  Kind_CLASS_DECLARATION = 110,
  Kind_STRUCT = 111,
  Kind_STRUCT_DECLARATION = 112,
  Kind_UNION = 113,
  Kind_UNION_DECLARATION = 114,
  Kind_DERIVATION_LIST = 115,
  Kind_PUBLIC_ACCESS = 116,
  Kind_PUBLIC_ACCESS_DEFAULT = 117,
  Kind_PRIVATE_ACCESS = 118,
  Kind_PRIVATE_ACCESS_DEFAULT = 119,
  Kind_PROTECTED_ACCESS = 120,
  Kind_PROTECTED_ACCESS_DEFAULT = 121,
  Kind_MEMBER_INIT_LIST = 122,
  Kind_MEMBER_INITIALIZATION_LIST = 123,
  Kind_MEMBER_INITIALIZATION = 124,
  Kind_CONSTRUCTOR_DEFINITION = 125,
  Kind_CONSTRUCTOR_DECLARATION = 126,
  Kind_DESTRUCTOR_DEFINITION = 127,
  Kind_DESTRUCTOR_DECLARATION = 128,
  Kind_FRIEND = 129,
  Kind_CLASS_SPECIFIER = 130,
  Kind_TRY_BLOCK = 131,
  Kind_CATCH_BLOCK = 132,
  Kind_FINALLY_BLOCK = 133,
  Kind_THROW_STATEMENT = 134,
  Kind_THROW_SPECIFIER = 135,
  Kind_THROW_SPECIFIER_JAVA = 136,
  Kind_TEMPLATE = 137,
  Kind_GENERIC_ARGUMENT = 138,
  Kind_GENERIC_ARGUMENT_LIST = 139,
  Kind_TEMPLATE_PARAMETER = 140,
  Kind_TEMPLATE_PARAMETER_LIST = 141,
  Kind_GENERIC_PARAMETER = 142,
  Kind_GENERIC_PARAMETER_LIST = 143,
  Kind_TYPEDEF = 144,
  Kind_ASM = 145,
  Kind_MACRO_CALL = 146,
  Kind_SIZEOF_CALL = 147,
  Kind_EXTERN = 148,
  Kind_NAMESPACE = 149,
  Kind_USING_DIRECTIVE = 150,
  Kind_DIRECTIVE = 151,
  Kind_ATOMIC = 152,
  Kind_STATIC_ASSERT_STATEMENT = 153,
  Kind_GENERIC_SELECTION = 154,
  Kind_GENERIC_SELECTOR = 155,
  Kind_GENERIC_ASSOCIATION_LIST = 156,
  Kind_GENERIC_ASSOCIATION = 157,
  Kind_ALIGNAS = 158,
  Kind_DECLTYPE = 159,
  Kind_CAPTURE = 160,
  Kind_LAMBDA_CAPTURE = 161,
  Kind_NOEXCEPT = 162,
  Kind_TYPENAME = 163,
  Kind_ALIGNOF = 164,
  Kind_TYPEID = 165,
  Kind_SIZEOF_PACK = 166,
  Kind_ENUM_CLASS = 167,
  Kind_ENUM_CLASS_DECLARATION = 168,
  Kind_REF_QUALIFIER = 171,
  Kind_SIGNAL_ACCESS = 172,
  Kind_FOREVER_STATEMENT = 173,
  Kind_EMIT_STATEMENT = 174,
  Kind_CPP_DIRECTIVE = 175,
  Kind_CPP_FILENAME = 176,
  Kind_FILE = 177,
  Kind_NUMBER = 178,
  Kind_CPP_NUMBER = 179,
  Kind_CPP_LITERAL = 180,
  Kind_CPP_MACRO_DEFN = 181,
  Kind_CPP_MACRO_VALUE = 182,
  Kind_ERROR = 183,
  Kind_CPP_ERROR = 184,
  Kind_CPP_WARNING = 185,
  Kind_CPP_PRAGMA = 186,
  Kind_CPP_INCLUDE = 187,
  Kind_CPP_DEFINE = 188,
  Kind_CPP_UNDEF = 189,
  Kind_CPP_LINE = 190,
  Kind_CPP_IF = 191,
  Kind_CPP_IFDEF = 192,
  Kind_CPP_IFNDEF = 193,
  Kind_CPP_THEN = 194,
  Kind_CPP_ELSE = 195,
  Kind_CPP_ELIF = 196,
  Kind_CPP_EMPTY = 197,
  Kind_CPP_REGION = 198,
  Kind_CPP_ENDREGION = 199,
  Kind_USING_STMT = 200,
  Kind_ESCAPE = 201,
  Kind_VALUE = 202,
  Kind_CPP_IMPORT = 203,
  Kind_CPP_ENDIF = 204,
  Kind_MARKER = 205,
  Kind_ERROR_PARSE = 206,
  Kind_ERROR_MODE = 207,
  Kind_IMPLEMENTS = 208,
  Kind_EXTENDS = 209,
  Kind_IMPORT = 210,
  Kind_PACKAGE = 211,
  Kind_ASSERT_STATEMENT = 212,
  Kind_INTERFACE = 213,
  Kind_INTERFACE_DECLARATION = 214,
  Kind_SYNCHRONIZED_STATEMENT = 215,
  Kind_ANNOTATION = 216,
  Kind_STATIC_BLOCK = 218,
  Kind_CHECKED_STATEMENT = 219,
  Kind_UNCHECKED_STATEMENT = 220,
  Kind_ATTRIBUTE = 221,
  Kind_TARGET = 222,
  Kind_UNSAFE_STATEMENT = 223,
  Kind_LOCK_STATEMENT = 224,
  Kind_FIXED_STATEMENT = 225,
  Kind_TYPEOF = 226,
  Kind_USING_STATEMENT = 227,
  Kind_FUNCTION_DELEGATE = 228,
  Kind_CONSTRAINT = 230,
  Kind_LINQ = 231,
  Kind_FROM = 232,
  Kind_WHERE = 233,
  Kind_SELECT = 234,
  Kind_LET = 235,
  Kind_ORDERBY = 236,
  Kind_JOIN = 237,
  Kind_GROUP = 238,
  Kind_IN = 239,
  Kind_ON = 240,
  Kind_EQUALS = 241,
  Kind_BY = 242,
  Kind_INTO = 243,
  Kind_EMPTY = 244,
  Kind_EMPTY_STMT = 245,
  Kind_RECEIVER = 246,
  Kind_MESSAGE = 247,
  Kind_SELECTOR = 248,
  Kind_PROTOCOL_LIST = 249,
  Kind_CATEGORY = 250,
  Kind_PROTOCOL = 251,
  Kind_REQUIRED_DEFAULT = 252,
  Kind_REQUIRED = 253,
  Kind_OPTIONAL = 254,
  Kind_ATTRIBUTE_LIST = 256,
  Kind_SYNTHESIZE = 257,
  Kind_DYNAMIC = 258,
  Kind_ENCODE = 259,
  Kind_AUTORELEASEPOOL = 260,
  Kind_COMPATIBILITY_ALIAS = 261,
  Kind_NIL = 262,
  Kind_CLASS_INTERFACE = 263,
  Kind_CLASS_IMPLEMENTATION = 264,
  Kind_PROTOCOL_DECLARATION = 265,
  Kind_CAST = 266,
  Kind_CONST_CAST = 267,
  Kind_DYNAMIC_CAST = 268,
  Kind_REINTERPRET_CAST = 269,
  Kind_STATIC_CAST = 270,
  Kind_POSITION = 271,
  Kind_CUDA_ARGUMENT_LIST = 272,
  Kind_OMP_DIRECTIVE = 273,
  Kind_OMP_NAME = 274,
  Kind_OMP_CLAUSE = 275,
  Kind_OMP_ARGUMENT_LIST = 276,
  Kind_OMP_ARGUMENT = 277,
  Kind_OMP_EXPRESSION = 278,
  Kind_END_ELEMENT_TOKEN = 279,
  Kind_MAIN = 280,
  Kind_BREAK = 281,
  Kind_CONTINUE = 282,
  Kind_WHILE = 283,
  Kind_DO = 284,
  Kind_FOR = 285,
  Kind_IF = 286,
  Kind_GOTO = 293,
  Kind_VISUAL_CXX_ASM = 295,
  Kind_SIZEOF = 296,
  Kind_AUTO = 298,
  Kind_REGISTER = 299,
  Kind_RESTRICT = 300,
  Kind_IMAGINARY = 304,
  Kind_NORETURN = 305,
  Kind_STATIC_ASSERT = 306,
  Kind_CRESTRICT = 307,
  Kind_CXX_TRY = 308,
  Kind_CXX_CATCH = 309,
  Kind_CXX_CLASS = 310,
  Kind_CONSTEXPR = 311,
  Kind_THREAD_LOCAL = 313,
  Kind_NULLPTR = 314,
  Kind_VOID = 326,
  Kind_RETURN = 327,
  Kind_INCLUDE = 328,
  Kind_DEFINE = 329,
  Kind_ELIF = 330,
  Kind_ENDIF = 331,
  Kind_ERRORPREC = 332,
  Kind_WARNING = 333,
  Kind_IFDEF = 334,
  Kind_IFNDEF = 335,
  Kind_LINE = 336,
  Kind_PRAGMA = 337,
  Kind_UNDEF = 338,
  Kind_INLINE = 339,
  Kind_MACRO_TYPE_NAME = 340,
  Kind_MACRO_CASE = 341,
  Kind_MACRO_LABEL = 342,
  Kind_SPECIFIER = 344,
  Kind_TRY = 345,
  Kind_CATCH = 346,
  Kind_THROW = 347,
  Kind_THROWS = 348,
  Kind_PUBLIC = 350,
  Kind_PRIVATE = 351,
  Kind_PROTECTED = 352,
  Kind_VIRTUAL = 353,
  Kind_EXPLICIT = 356,
  Kind_FOREVER = 357,
  Kind_SIGNAL = 358,
  Kind_EMIT = 359,
  Kind_NEW = 363,
  Kind_DELETE = 364,
  Kind_STATIC = 365,
  Kind_CONST = 366,
  Kind_MUTABLE = 367,
  Kind_VOLATILE = 368,
  Kind_TRANSIENT = 369,
  Kind_FINALLY = 372,
  Kind_FINAL = 376,
  Kind_ABSTRACT = 377,
  Kind_SUPER = 378,
  Kind_SYNCHRONIZED = 379,
  Kind_NATIVE = 380,
  Kind_STRICTFP = 381,
  Kind_NULLLITERAL = 382,
  Kind_ASSERT = 383,
  Kind_FOREACH = 384,
  Kind_REF = 385,
  Kind_OUT = 386,
  Kind_LOCK = 388,
  Kind_IS = 389,
  Kind_INTERNAL = 390,
  Kind_SEALED = 391,
  Kind_OVERRIDE = 392,
  Kind_IMPLICIT = 393,
  Kind_STACKALLOC = 394,
  Kind_AS = 395,
  Kind_DELEGATE = 396,
  Kind_FIXED = 397,
  Kind_CHECKED = 398,
  Kind_UNCHECKED = 399,
  Kind_REGION = 400,
  Kind_ENDREGION = 401,
  Kind_UNSAFE = 402,
  Kind_READONLY = 403,
  Kind_GET = 404,
  Kind_SET = 405,
  Kind_ADD = 406,
  Kind_REMOVE = 407,
  Kind_YIELD = 408,
  Kind_PARTIAL = 409,
  Kind_AWAIT = 410,
  Kind_ASYNC = 412,
  Kind_THIS = 413,
  Kind_PARAMS = 414,
  Kind_ALIAS = 416,
  Kind_ASCENDING = 422,
  Kind_DESCENDING = 423,
  Kind_ATINTERFACE = 430,
  Kind_ATIMPLEMENTATION = 431,
  Kind_ATEND = 432,
  Kind_ATPROTOCOL = 433,
  Kind_ATREQUIRED = 434,
  Kind_ATOPTIONAL = 435,
  Kind_ATCLASS = 441,
  Kind_WEAK = 443,
  Kind_STRONG = 444,
  Kind_OMP_OMP = 448,
  Kind_SPECIAL_CHARS = 449,
  Kind_MIN = Kind_UNIT_KIND,
  Kind_MAX = Kind_SPECIAL_CHARS
};

inline const char **EnumNamesKind() {
  static const char *names[] = {
    "UNIT_KIND",
    "DECL",
    "DECL_STMT",
    "INIT",
    "EXPR",
    "EXPR_STMT",
    "COMMENT",
    "CALL",
    "CONTROL",
    "INCR",
    "NONE",
    "VARIABLE",
    "FUNCTION",
    "FUNCTION_DECL",
    "CONSTRUCTOR",
    "CONSTRUCTOR_DECL",
    "DESTRUCTOR",
    "DESTRUCTOR_DECL",
    "MACRO",
    "SINGLE_MACRO",
    "NULLOPERATOR",
    "ENUM_DEFN",
    "ENUM_DECL",
    "GLOBAL_ATTRIBUTE",
    "PROPERTY_ACCESSOR",
    "PROPERTY_ACCESSOR_DECL",
    "EXPRESSION",
    "CLASS_DEFN",
    "CLASS_DECL",
    "UNION_DEFN",
    "UNION_DECL",
    "STRUCT_DEFN",
    "STRUCT_DECL",
    "INTERFACE_DEFN",
    "INTERFACE_DECL",
    "ACCESS_REGION",
    "USING",
    "OPERATOR_FUNCTION",
    "OPERATOR_FUNCTION_DECL",
    "EVENT",
    "PROPERTY",
    "ANNOTATION_DEFN",
    "GLOBAL_TEMPLATE",
    "UNIT",
    "TART_ELEMENT_TOKEN",
    "NOP",
    "STRING",
    "CHAR",
    "LITERAL",
    "BOOLEAN",
    "NULL",
    "COMPLEX",
    "OPERATOR",
    "MODIFIER",
    "NAME",
    "ONAME",
    "CNAME",
    "TYPE",
    "TYPEPREV",
    "CONDITION",
    "BLOCK",
    "PSEUDO_BLOCK",
    "INDEX",
    "ENUM",
    "ENUM_DECLARATION",
    "IF_STATEMENT",
    "TERNARY",
    "THEN",
    "ELSE",
    "ELSEIF",
    "WHILE_STATEMENT",
    "DO_STATEMENT",
    "FOR_STATEMENT",
    "FOREACH_STATEMENT",
    "FOR_CONTROL",
    "FOR_INITIALIZATION",
    "FOR_CONDITION",
    "FOR_INCREMENT",
    "FOR_LIKE_CONTROL",
    "EXPRESSION_STATEMENT",
    "",
    "FUNCTION_CALL",
    "DECLARATION_STATEMENT",
    "DECLARATION",
    "DECLARATION_INITIALIZATION",
    "DECLARATION_RANGE",
    "RANGE",
    "GOTO_STATEMENT",
    "CONTINUE_STATEMENT",
    "BREAK_STATEMENT",
    "LABEL_STATEMENT",
    "LABEL",
    "SWITCH",
    "CASE",
    "DEFAULT",
    "FUNCTION_DEFINITION",
    "FUNCTION_DECLARATION",
    "LAMBDA",
    "FUNCTION_LAMBDA",
    "FUNCTION_SPECIFIER",
    "RETURN_STATEMENT",
    "PARAMETER_LIST",
    "PARAMETER",
    "KRPARAMETER_LIST",
    "KRPARAMETER",
    "ARGUMENT_LIST",
    "ARGUMENT",
    "PSEUDO_PARAMETER_LIST",
    "INDEXER_PARAMETER_LIST",
    "CLASS",
    "CLASS_DECLARATION",
    "STRUCT",
    "STRUCT_DECLARATION",
    "UNION",
    "UNION_DECLARATION",
    "DERIVATION_LIST",
    "PUBLIC_ACCESS",
    "PUBLIC_ACCESS_DEFAULT",
    "PRIVATE_ACCESS",
    "PRIVATE_ACCESS_DEFAULT",
    "PROTECTED_ACCESS",
    "PROTECTED_ACCESS_DEFAULT",
    "MEMBER_INIT_LIST",
    "MEMBER_INITIALIZATION_LIST",
    "MEMBER_INITIALIZATION",
    "CONSTRUCTOR_DEFINITION",
    "CONSTRUCTOR_DECLARATION",
    "DESTRUCTOR_DEFINITION",
    "DESTRUCTOR_DECLARATION",
    "FRIEND",
    "CLASS_SPECIFIER",
    "TRY_BLOCK",
    "CATCH_BLOCK",
    "FINALLY_BLOCK",
    "THROW_STATEMENT",
    "THROW_SPECIFIER",
    "THROW_SPECIFIER_JAVA",
    "TEMPLATE",
    "GENERIC_ARGUMENT",
    "GENERIC_ARGUMENT_LIST",
    "TEMPLATE_PARAMETER",
    "TEMPLATE_PARAMETER_LIST",
    "GENERIC_PARAMETER",
    "GENERIC_PARAMETER_LIST",
    "TYPEDEF",
    "ASM",
    "MACRO_CALL",
    "SIZEOF_CALL",
    "EXTERN",
    "NAMESPACE",
    "USING_DIRECTIVE",
    "DIRECTIVE",
    "ATOMIC",
    "STATIC_ASSERT_STATEMENT",
    "GENERIC_SELECTION",
    "GENERIC_SELECTOR",
    "GENERIC_ASSOCIATION_LIST",
    "GENERIC_ASSOCIATION",
    "ALIGNAS",
    "DECLTYPE",
    "CAPTURE",
    "LAMBDA_CAPTURE",
    "NOEXCEPT",
    "TYPENAME",
    "ALIGNOF",
    "TYPEID",
    "SIZEOF_PACK",
    "ENUM_CLASS",
    "ENUM_CLASS_DECLARATION",
    "",
    "",
    "REF_QUALIFIER",
    "SIGNAL_ACCESS",
    "FOREVER_STATEMENT",
    "EMIT_STATEMENT",
    "CPP_DIRECTIVE",
    "CPP_FILENAME",
    "FILE",
    "NUMBER",
    "CPP_NUMBER",
    "CPP_LITERAL",
    "CPP_MACRO_DEFN",
    "CPP_MACRO_VALUE",
    "ERROR",
    "CPP_ERROR",
    "CPP_WARNING",
    "CPP_PRAGMA",
    "CPP_INCLUDE",
    "CPP_DEFINE",
    "CPP_UNDEF",
    "CPP_LINE",
    "CPP_IF",
    "CPP_IFDEF",
    "CPP_IFNDEF",
    "CPP_THEN",
    "CPP_ELSE",
    "CPP_ELIF",
    "CPP_EMPTY",
    "CPP_REGION",
    "CPP_ENDREGION",
    "USING_STMT",
    "ESCAPE",
    "VALUE",
    "CPP_IMPORT",
    "CPP_ENDIF",
    "MARKER",
    "ERROR_PARSE",
    "ERROR_MODE",
    "IMPLEMENTS",
    "EXTENDS",
    "IMPORT",
    "PACKAGE",
    "ASSERT_STATEMENT",
    "INTERFACE",
    "INTERFACE_DECLARATION",
    "SYNCHRONIZED_STATEMENT",
    "ANNOTATION",
    "",
    "STATIC_BLOCK",
    "CHECKED_STATEMENT",
    "UNCHECKED_STATEMENT",
    "ATTRIBUTE",
    "TARGET",
    "UNSAFE_STATEMENT",
    "LOCK_STATEMENT",
    "FIXED_STATEMENT",
    "TYPEOF",
    "USING_STATEMENT",
    "FUNCTION_DELEGATE",
    "",
    "CONSTRAINT",
    "LINQ",
    "FROM",
    "WHERE",
    "SELECT",
    "LET",
    "ORDERBY",
    "JOIN",
    "GROUP",
    "IN",
    "ON",
    "EQUALS",
    "BY",
    "INTO",
    "EMPTY",
    "EMPTY_STMT",
    "RECEIVER",
    "MESSAGE",
    "SELECTOR",
    "PROTOCOL_LIST",
    "CATEGORY",
    "PROTOCOL",
    "REQUIRED_DEFAULT",
    "REQUIRED",
    "OPTIONAL",
    "",
    "ATTRIBUTE_LIST",
    "SYNTHESIZE",
    "DYNAMIC",
    "ENCODE",
    "AUTORELEASEPOOL",
    "COMPATIBILITY_ALIAS",
    "NIL",
    "CLASS_INTERFACE",
    "CLASS_IMPLEMENTATION",
    "PROTOCOL_DECLARATION",
    "CAST",
    "CONST_CAST",
    "DYNAMIC_CAST",
    "REINTERPRET_CAST",
    "STATIC_CAST",
    "POSITION",
    "CUDA_ARGUMENT_LIST",
    "OMP_DIRECTIVE",
    "OMP_NAME",
    "OMP_CLAUSE",
    "OMP_ARGUMENT_LIST",
    "OMP_ARGUMENT",
    "OMP_EXPRESSION",
    "END_ELEMENT_TOKEN",
    "MAIN",
    "BREAK",
    "CONTINUE",
    "WHILE",
    "DO",
    "FOR",
    "IF",
    "",
    "",
    "",
    "",
    "",
    "",
    "GOTO",
    "",
    "VISUAL_CXX_ASM",
    "SIZEOF",
    "",
    "AUTO",
    "REGISTER",
    "RESTRICT",
    "",
    "",
    "",
    "IMAGINARY",
    "NORETURN",
    "STATIC_ASSERT",
    "CRESTRICT",
    "CXX_TRY",
    "CXX_CATCH",
    "CXX_CLASS",
    "CONSTEXPR",
    "",
    "THREAD_LOCAL",
    "NULLPTR",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "VOID",
    "RETURN",
    "INCLUDE",
    "DEFINE",
    "ELIF",
    "ENDIF",
    "ERRORPREC",
    "WARNING",
    "IFDEF",
    "IFNDEF",
    "LINE",
    "PRAGMA",
    "UNDEF",
    "INLINE",
    "MACRO_TYPE_NAME",
    "MACRO_CASE",
    "MACRO_LABEL",
    "",
    "SPECIFIER",
    "TRY",
    "CATCH",
    "THROW",
    "THROWS",
    "",
    "PUBLIC",
    "PRIVATE",
    "PROTECTED",
    "VIRTUAL",
    "",
    "",
    "EXPLICIT",
    "FOREVER",
    "SIGNAL",
    "EMIT",
    "",
    "",
    "",
    "NEW",
    "DELETE",
    "STATIC",
    "CONST",
    "MUTABLE",
    "VOLATILE",
    "TRANSIENT",
    "",
    "",
    "FINALLY",
    "",
    "",
    "",
    "FINAL",
    "ABSTRACT",
    "SUPER",
    "SYNCHRONIZED",
    "NATIVE",
    "STRICTFP",
    "NULLLITERAL",
    "ASSERT",
    "FOREACH",
    "REF",
    "OUT",
    "",
    "LOCK",
    "IS",
    "INTERNAL",
    "SEALED",
    "OVERRIDE",
    "IMPLICIT",
    "STACKALLOC",
    "AS",
    "DELEGATE",
    "FIXED",
    "CHECKED",
    "UNCHECKED",
    "REGION",
    "ENDREGION",
    "UNSAFE",
    "READONLY",
    "GET",
    "SET",
    "ADD",
    "REMOVE",
    "YIELD",
    "PARTIAL",
    "AWAIT",
    "",
    "ASYNC",
    "THIS",
    "PARAMS",
    "",
    "ALIAS",
    "",
    "",
    "",
    "",
    "",
    "ASCENDING",
    "DESCENDING",
    "",
    "",
    "",
    "",
    "",
    "",
    "ATINTERFACE",
    "ATIMPLEMENTATION",
    "ATEND",
    "ATPROTOCOL",
    "ATREQUIRED",
    "ATOPTIONAL",
    "",
    "",
    "",
    "",
    "",
    "ATCLASS",
    "",
    "WEAK",
    "STRONG",
    "",
    "",
    "",
    "OMP_OMP",
    "SPECIAL_CHARS",
    nullptr
  };
  return names;
}

inline const char *EnumNameKind(Kind e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesKind()[index];
}

enum SmaliKind {
  SmaliKind_INVALID = 0,
  SmaliKind_EOR = 1,
  SmaliKind_DOWN = 2,
  SmaliKind_UP = 3,
  SmaliKind_ACCESS_SPEC = 4,
  SmaliKind_ANNOTATION_DIRECTIVE = 5,
  SmaliKind_ANNOTATION_VISIBILITY = 6,
  SmaliKind_ARRAY_DATA_DIRECTIVE = 7,
  SmaliKind_ARRAY_TYPE_PREFIX = 8,
  SmaliKind_ARROW = 9,
  SmaliKind_BOOL_LITERAL = 10,
  SmaliKind_BYTE_LITERAL = 11,
  SmaliKind_CATCHALL_DIRECTIVE = 12,
  SmaliKind_CATCH_DIRECTIVE = 13,
  SmaliKind_CHAR_LITERAL = 14,
  SmaliKind_CLASS_DESCRIPTOR = 15,
  SmaliKind_CLASS_DIRECTIVE = 16,
  SmaliKind_CLOSE_BRACE = 17,
  SmaliKind_CLOSE_PAREN = 18,
  SmaliKind_COLON = 19,
  SmaliKind_COMMA = 20,
  SmaliKind_DOTDOT = 21,
  SmaliKind_DOUBLE_LITERAL = 22,
  SmaliKind_DOUBLE_LITERAL_OR_ID = 23,
  SmaliKind_END_ANNOTATION_DIRECTIVE = 24,
  SmaliKind_END_ARRAY_DATA_DIRECTIVE = 25,
  SmaliKind_END_FIELD_DIRECTIVE = 26,
  SmaliKind_END_LOCAL_DIRECTIVE = 27,
  SmaliKind_END_METHOD_DIRECTIVE = 28,
  SmaliKind_END_PACKED_SWITCH_DIRECTIVE = 29,
  SmaliKind_END_PARAMETER_DIRECTIVE = 30,
  SmaliKind_END_SPARSE_SWITCH_DIRECTIVE = 31,
  SmaliKind_END_SUBANNOTATION_DIRECTIVE = 32,
  SmaliKind_ENUM_DIRECTIVE = 33,
  SmaliKind_EPILOGUE_DIRECTIVE = 34,
  SmaliKind_EQUAL = 35,
  SmaliKind_FIELD_DIRECTIVE = 36,
  SmaliKind_FIELD_OFFSET = 37,
  SmaliKind_FLOAT_LITERAL = 38,
  SmaliKind_FLOAT_LITERAL_OR_ID = 39,
  SmaliKind_IMPLEMENTS_DIRECTIVE = 40,
  SmaliKind_INLINE_INDEX = 41,
  SmaliKind_INSTRUCTION_FORMAT10t = 42,
  SmaliKind_INSTRUCTION_FORMAT10x = 43,
  SmaliKind_INSTRUCTION_FORMAT10x_ODEX = 44,
  SmaliKind_INSTRUCTION_FORMAT11n = 45,
  SmaliKind_INSTRUCTION_FORMAT11x = 46,
  SmaliKind_INSTRUCTION_FORMAT12x = 47,
  SmaliKind_INSTRUCTION_FORMAT12x_OR_ID = 48,
  SmaliKind_INSTRUCTION_FORMAT20bc = 49,
  SmaliKind_INSTRUCTION_FORMAT20t = 50,
  SmaliKind_INSTRUCTION_FORMAT21c_FIELD = 51,
  SmaliKind_INSTRUCTION_FORMAT21c_FIELD_ODEX = 52,
  SmaliKind_INSTRUCTION_FORMAT21c_STRING = 53,
  SmaliKind_INSTRUCTION_FORMAT21c_TYPE = 54,
  SmaliKind_INSTRUCTION_FORMAT21ih = 55,
  SmaliKind_INSTRUCTION_FORMAT21lh = 56,
  SmaliKind_INSTRUCTION_FORMAT21s = 57,
  SmaliKind_INSTRUCTION_FORMAT21t = 58,
  SmaliKind_INSTRUCTION_FORMAT22b = 59,
  SmaliKind_INSTRUCTION_FORMAT22c_FIELD = 60,
  SmaliKind_INSTRUCTION_FORMAT22c_FIELD_ODEX = 61,
  SmaliKind_INSTRUCTION_FORMAT22c_TYPE = 62,
  SmaliKind_INSTRUCTION_FORMAT22cs_FIELD = 63,
  SmaliKind_INSTRUCTION_FORMAT22s = 64,
  SmaliKind_INSTRUCTION_FORMAT22s_OR_ID = 65,
  SmaliKind_INSTRUCTION_FORMAT22t = 66,
  SmaliKind_INSTRUCTION_FORMAT22x = 67,
  SmaliKind_INSTRUCTION_FORMAT23x = 68,
  SmaliKind_INSTRUCTION_FORMAT30t = 69,
  SmaliKind_INSTRUCTION_FORMAT31c = 70,
  SmaliKind_INSTRUCTION_FORMAT31i = 71,
  SmaliKind_INSTRUCTION_FORMAT31i_OR_ID = 72,
  SmaliKind_INSTRUCTION_FORMAT31t = 73,
  SmaliKind_INSTRUCTION_FORMAT32x = 74,
  SmaliKind_INSTRUCTION_FORMAT35c_METHOD = 75,
  SmaliKind_INSTRUCTION_FORMAT35c_METHOD_ODEX = 76,
  SmaliKind_INSTRUCTION_FORMAT35c_TYPE = 77,
  SmaliKind_INSTRUCTION_FORMAT35mi_METHOD = 78,
  SmaliKind_INSTRUCTION_FORMAT35ms_METHOD = 79,
  SmaliKind_INSTRUCTION_FORMAT3rc_METHOD = 80,
  SmaliKind_INSTRUCTION_FORMAT3rc_METHOD_ODEX = 81,
  SmaliKind_INSTRUCTION_FORMAT3rc_TYPE = 82,
  SmaliKind_INSTRUCTION_FORMAT3rmi_METHOD = 83,
  SmaliKind_INSTRUCTION_FORMAT3rms_METHOD = 84,
  SmaliKind_INSTRUCTION_FORMAT45cc_METHOD = 85,
  SmaliKind_INSTRUCTION_FORMAT4rcc_METHOD = 86,
  SmaliKind_INSTRUCTION_FORMAT51l = 87,
  SmaliKind_INTEGER_LITERAL = 88,
  SmaliKind_INVALID_TOKEN = 89,
  SmaliKind_I_ACCESS_LIST = 90,
  SmaliKind_I_ANNOTATION = 91,
  SmaliKind_I_ANNOTATIONS = 92,
  SmaliKind_I_ANNOTATION_ELEMENT = 93,
  SmaliKind_I_ARRAY_ELEMENTS = 94,
  SmaliKind_I_ARRAY_ELEMENT_SIZE = 95,
  SmaliKind_I_CATCH = 96,
  SmaliKind_I_CATCHALL = 97,
  SmaliKind_I_CATCHES = 98,
  SmaliKind_I_CLASS_DEF = 99,
  SmaliKind_I_ENCODED_ARRAY = 100,
  SmaliKind_I_ENCODED_ENUM = 101,
  SmaliKind_I_ENCODED_FIELD = 102,
  SmaliKind_I_ENCODED_METHOD = 103,
  SmaliKind_I_END_LOCAL = 104,
  SmaliKind_I_EPILOGUE = 105,
  SmaliKind_I_FIELD = 106,
  SmaliKind_I_FIELDS = 107,
  SmaliKind_I_FIELD_INITIAL_VALUE = 108,
  SmaliKind_I_FIELD_TYPE = 109,
  SmaliKind_I_IMPLEMENTS = 110,
  SmaliKind_I_LABEL = 111,
  SmaliKind_I_LINE = 112,
  SmaliKind_I_LOCAL = 113,
  SmaliKind_I_LOCALS = 114,
  SmaliKind_I_METHOD = 115,
  SmaliKind_I_METHODS = 116,
  SmaliKind_I_METHOD_PROTOTYPE = 117,
  SmaliKind_I_METHOD_RETURN_TYPE = 118,
  SmaliKind_I_ORDERED_METHOD_ITEMS = 119,
  SmaliKind_I_PACKED_SWITCH_ELEMENTS = 120,
  SmaliKind_I_PACKED_SWITCH_START_KEY = 121,
  SmaliKind_I_PARAMETER = 122,
  SmaliKind_I_PARAMETERS = 123,
  SmaliKind_I_PARAMETER_NOT_SPECIFIED = 124,
  SmaliKind_I_PROLOGUE = 125,
  SmaliKind_I_REGISTERS = 126,
  SmaliKind_I_REGISTER_LIST = 127,
  SmaliKind_I_REGISTER_RANGE = 128,
  SmaliKind_I_RESTART_LOCAL = 129,
  SmaliKind_I_SOURCE = 130,
  SmaliKind_I_SPARSE_SWITCH_ELEMENTS = 131,
  SmaliKind_I_STATEMENT_ARRAY_DATA = 132,
  SmaliKind_I_STATEMENT_FORMAT10t = 133,
  SmaliKind_I_STATEMENT_FORMAT10x = 134,
  SmaliKind_I_STATEMENT_FORMAT11n = 135,
  SmaliKind_I_STATEMENT_FORMAT11x = 136,
  SmaliKind_I_STATEMENT_FORMAT12x = 137,
  SmaliKind_I_STATEMENT_FORMAT20bc = 138,
  SmaliKind_I_STATEMENT_FORMAT20t = 139,
  SmaliKind_I_STATEMENT_FORMAT21c_FIELD = 140,
  SmaliKind_I_STATEMENT_FORMAT21c_STRING = 141,
  SmaliKind_I_STATEMENT_FORMAT21c_TYPE = 142,
  SmaliKind_I_STATEMENT_FORMAT21ih = 143,
  SmaliKind_I_STATEMENT_FORMAT21lh = 144,
  SmaliKind_I_STATEMENT_FORMAT21s = 145,
  SmaliKind_I_STATEMENT_FORMAT21t = 146,
  SmaliKind_I_STATEMENT_FORMAT22b = 147,
  SmaliKind_I_STATEMENT_FORMAT22c_FIELD = 148,
  SmaliKind_I_STATEMENT_FORMAT22c_TYPE = 149,
  SmaliKind_I_STATEMENT_FORMAT22s = 150,
  SmaliKind_I_STATEMENT_FORMAT22t = 151,
  SmaliKind_I_STATEMENT_FORMAT22x = 152,
  SmaliKind_I_STATEMENT_FORMAT23x = 153,
  SmaliKind_I_STATEMENT_FORMAT30t = 154,
  SmaliKind_I_STATEMENT_FORMAT31c = 155,
  SmaliKind_I_STATEMENT_FORMAT31i = 156,
  SmaliKind_I_STATEMENT_FORMAT31t = 157,
  SmaliKind_I_STATEMENT_FORMAT32x = 158,
  SmaliKind_I_STATEMENT_FORMAT35c_METHOD = 159,
  SmaliKind_I_STATEMENT_FORMAT35c_TYPE = 160,
  SmaliKind_I_STATEMENT_FORMAT3rc_METHOD = 161,
  SmaliKind_I_STATEMENT_FORMAT3rc_TYPE = 162,
  SmaliKind_I_STATEMENT_FORMAT45cc_METHOD = 163,
  SmaliKind_I_STATEMENT_FORMAT4rcc_METHOD = 164,
  SmaliKind_I_STATEMENT_FORMAT51l = 165,
  SmaliKind_I_STATEMENT_PACKED_SWITCH = 166,
  SmaliKind_I_STATEMENT_SPARSE_SWITCH = 167,
  SmaliKind_I_SUBANNOTATION = 168,
  SmaliKind_I_SUPER = 169,
  SmaliKind_LINE_COMMENT = 170,
  SmaliKind_LINE_DIRECTIVE = 171,
  SmaliKind_LOCALS_DIRECTIVE = 172,
  SmaliKind_LOCAL_DIRECTIVE = 173,
  SmaliKind_LONG_LITERAL = 174,
  SmaliKind_MEMBER_NAME = 175,
  SmaliKind_METHOD_DIRECTIVE = 176,
  SmaliKind_NEGATIVE_INTEGER_LITERAL = 177,
  SmaliKind_NULL_LITERAL = 178,
  SmaliKind_OPEN_BRACE = 179,
  SmaliKind_OPEN_PAREN = 180,
  SmaliKind_PACKED_SWITCH_DIRECTIVE = 181,
  SmaliKind_PARAMETER_DIRECTIVE = 182,
  SmaliKind_PARAM_LIST_OR_ID_PRIMITIVE_TYPE = 183,
  SmaliKind_POSITIVE_INTEGER_LITERAL = 184,
  SmaliKind_PRIMITIVE_TYPE = 185,
  SmaliKind_PROLOGUE_DIRECTIVE = 186,
  SmaliKind_SMALI_REGISTER = 187,
  SmaliKind_REGISTERS_DIRECTIVE = 188,
  SmaliKind_RESTART_LOCAL_DIRECTIVE = 189,
  SmaliKind_SHORT_LITERAL = 190,
  SmaliKind_SIMPLE_NAME = 191,
  SmaliKind_SOURCE_DIRECTIVE = 192,
  SmaliKind_SPARSE_SWITCH_DIRECTIVE = 193,
  SmaliKind_STRING_LITERAL = 194,
  SmaliKind_SUBANNOTATION_DIRECTIVE = 195,
  SmaliKind_SUPER_DIRECTIVE = 196,
  SmaliKind_VERIFICATION_ERROR_TYPE = 197,
  SmaliKind_VOID_TYPE = 198,
  SmaliKind_VTABLE_INDEX = 199,
  SmaliKind_WHITE_SPACE = 200,
  SmaliKind_MIN = SmaliKind_INVALID,
  SmaliKind_MAX = SmaliKind_WHITE_SPACE
};

inline const char **EnumNamesSmaliKind() {
  static const char *names[] = {
    "INVALID",
    "EOR",
    "DOWN",
    "UP",
    "ACCESS_SPEC",
    "ANNOTATION_DIRECTIVE",
    "ANNOTATION_VISIBILITY",
    "ARRAY_DATA_DIRECTIVE",
    "ARRAY_TYPE_PREFIX",
    "ARROW",
    "BOOL_LITERAL",
    "BYTE_LITERAL",
    "CATCHALL_DIRECTIVE",
    "CATCH_DIRECTIVE",
    "CHAR_LITERAL",
    "CLASS_DESCRIPTOR",
    "CLASS_DIRECTIVE",
    "CLOSE_BRACE",
    "CLOSE_PAREN",
    "COLON",
    "COMMA",
    "DOTDOT",
    "DOUBLE_LITERAL",
    "DOUBLE_LITERAL_OR_ID",
    "END_ANNOTATION_DIRECTIVE",
    "END_ARRAY_DATA_DIRECTIVE",
    "END_FIELD_DIRECTIVE",
    "END_LOCAL_DIRECTIVE",
    "END_METHOD_DIRECTIVE",
    "END_PACKED_SWITCH_DIRECTIVE",
    "END_PARAMETER_DIRECTIVE",
    "END_SPARSE_SWITCH_DIRECTIVE",
    "END_SUBANNOTATION_DIRECTIVE",
    "ENUM_DIRECTIVE",
    "EPILOGUE_DIRECTIVE",
    "EQUAL",
    "FIELD_DIRECTIVE",
    "FIELD_OFFSET",
    "FLOAT_LITERAL",
    "FLOAT_LITERAL_OR_ID",
    "IMPLEMENTS_DIRECTIVE",
    "INLINE_INDEX",
    "INSTRUCTION_FORMAT10t",
    "INSTRUCTION_FORMAT10x",
    "INSTRUCTION_FORMAT10x_ODEX",
    "INSTRUCTION_FORMAT11n",
    "INSTRUCTION_FORMAT11x",
    "INSTRUCTION_FORMAT12x",
    "INSTRUCTION_FORMAT12x_OR_ID",
    "INSTRUCTION_FORMAT20bc",
    "INSTRUCTION_FORMAT20t",
    "INSTRUCTION_FORMAT21c_FIELD",
    "INSTRUCTION_FORMAT21c_FIELD_ODEX",
    "INSTRUCTION_FORMAT21c_STRING",
    "INSTRUCTION_FORMAT21c_TYPE",
    "INSTRUCTION_FORMAT21ih",
    "INSTRUCTION_FORMAT21lh",
    "INSTRUCTION_FORMAT21s",
    "INSTRUCTION_FORMAT21t",
    "INSTRUCTION_FORMAT22b",
    "INSTRUCTION_FORMAT22c_FIELD",
    "INSTRUCTION_FORMAT22c_FIELD_ODEX",
    "INSTRUCTION_FORMAT22c_TYPE",
    "INSTRUCTION_FORMAT22cs_FIELD",
    "INSTRUCTION_FORMAT22s",
    "INSTRUCTION_FORMAT22s_OR_ID",
    "INSTRUCTION_FORMAT22t",
    "INSTRUCTION_FORMAT22x",
    "INSTRUCTION_FORMAT23x",
    "INSTRUCTION_FORMAT30t",
    "INSTRUCTION_FORMAT31c",
    "INSTRUCTION_FORMAT31i",
    "INSTRUCTION_FORMAT31i_OR_ID",
    "INSTRUCTION_FORMAT31t",
    "INSTRUCTION_FORMAT32x",
    "INSTRUCTION_FORMAT35c_METHOD",
    "INSTRUCTION_FORMAT35c_METHOD_ODEX",
    "INSTRUCTION_FORMAT35c_TYPE",
    "INSTRUCTION_FORMAT35mi_METHOD",
    "INSTRUCTION_FORMAT35ms_METHOD",
    "INSTRUCTION_FORMAT3rc_METHOD",
    "INSTRUCTION_FORMAT3rc_METHOD_ODEX",
    "INSTRUCTION_FORMAT3rc_TYPE",
    "INSTRUCTION_FORMAT3rmi_METHOD",
    "INSTRUCTION_FORMAT3rms_METHOD",
    "INSTRUCTION_FORMAT45cc_METHOD",
    "INSTRUCTION_FORMAT4rcc_METHOD",
    "INSTRUCTION_FORMAT51l",
    "INTEGER_LITERAL",
    "INVALID_TOKEN",
    "I_ACCESS_LIST",
    "I_ANNOTATION",
    "I_ANNOTATIONS",
    "I_ANNOTATION_ELEMENT",
    "I_ARRAY_ELEMENTS",
    "I_ARRAY_ELEMENT_SIZE",
    "I_CATCH",
    "I_CATCHALL",
    "I_CATCHES",
    "I_CLASS_DEF",
    "I_ENCODED_ARRAY",
    "I_ENCODED_ENUM",
    "I_ENCODED_FIELD",
    "I_ENCODED_METHOD",
    "I_END_LOCAL",
    "I_EPILOGUE",
    "I_FIELD",
    "I_FIELDS",
    "I_FIELD_INITIAL_VALUE",
    "I_FIELD_TYPE",
    "I_IMPLEMENTS",
    "I_LABEL",
    "I_LINE",
    "I_LOCAL",
    "I_LOCALS",
    "I_METHOD",
    "I_METHODS",
    "I_METHOD_PROTOTYPE",
    "I_METHOD_RETURN_TYPE",
    "I_ORDERED_METHOD_ITEMS",
    "I_PACKED_SWITCH_ELEMENTS",
    "I_PACKED_SWITCH_START_KEY",
    "I_PARAMETER",
    "I_PARAMETERS",
    "I_PARAMETER_NOT_SPECIFIED",
    "I_PROLOGUE",
    "I_REGISTERS",
    "I_REGISTER_LIST",
    "I_REGISTER_RANGE",
    "I_RESTART_LOCAL",
    "I_SOURCE",
    "I_SPARSE_SWITCH_ELEMENTS",
    "I_STATEMENT_ARRAY_DATA",
    "I_STATEMENT_FORMAT10t",
    "I_STATEMENT_FORMAT10x",
    "I_STATEMENT_FORMAT11n",
    "I_STATEMENT_FORMAT11x",
    "I_STATEMENT_FORMAT12x",
    "I_STATEMENT_FORMAT20bc",
    "I_STATEMENT_FORMAT20t",
    "I_STATEMENT_FORMAT21c_FIELD",
    "I_STATEMENT_FORMAT21c_STRING",
    "I_STATEMENT_FORMAT21c_TYPE",
    "I_STATEMENT_FORMAT21ih",
    "I_STATEMENT_FORMAT21lh",
    "I_STATEMENT_FORMAT21s",
    "I_STATEMENT_FORMAT21t",
    "I_STATEMENT_FORMAT22b",
    "I_STATEMENT_FORMAT22c_FIELD",
    "I_STATEMENT_FORMAT22c_TYPE",
    "I_STATEMENT_FORMAT22s",
    "I_STATEMENT_FORMAT22t",
    "I_STATEMENT_FORMAT22x",
    "I_STATEMENT_FORMAT23x",
    "I_STATEMENT_FORMAT30t",
    "I_STATEMENT_FORMAT31c",
    "I_STATEMENT_FORMAT31i",
    "I_STATEMENT_FORMAT31t",
    "I_STATEMENT_FORMAT32x",
    "I_STATEMENT_FORMAT35c_METHOD",
    "I_STATEMENT_FORMAT35c_TYPE",
    "I_STATEMENT_FORMAT3rc_METHOD",
    "I_STATEMENT_FORMAT3rc_TYPE",
    "I_STATEMENT_FORMAT45cc_METHOD",
    "I_STATEMENT_FORMAT4rcc_METHOD",
    "I_STATEMENT_FORMAT51l",
    "I_STATEMENT_PACKED_SWITCH",
    "I_STATEMENT_SPARSE_SWITCH",
    "I_SUBANNOTATION",
    "I_SUPER",
    "LINE_COMMENT",
    "LINE_DIRECTIVE",
    "LOCALS_DIRECTIVE",
    "LOCAL_DIRECTIVE",
    "LONG_LITERAL",
    "MEMBER_NAME",
    "METHOD_DIRECTIVE",
    "NEGATIVE_INTEGER_LITERAL",
    "NULL_LITERAL",
    "OPEN_BRACE",
    "OPEN_PAREN",
    "PACKED_SWITCH_DIRECTIVE",
    "PARAMETER_DIRECTIVE",
    "PARAM_LIST_OR_ID_PRIMITIVE_TYPE",
    "POSITIVE_INTEGER_LITERAL",
    "PRIMITIVE_TYPE",
    "PROLOGUE_DIRECTIVE",
    "SMALI_REGISTER",
    "REGISTERS_DIRECTIVE",
    "RESTART_LOCAL_DIRECTIVE",
    "SHORT_LITERAL",
    "SIMPLE_NAME",
    "SOURCE_DIRECTIVE",
    "SPARSE_SWITCH_DIRECTIVE",
    "STRING_LITERAL",
    "SUBANNOTATION_DIRECTIVE",
    "SUPER_DIRECTIVE",
    "VERIFICATION_ERROR_TYPE",
    "VOID_TYPE",
    "VTABLE_INDEX",
    "WHITE_SPACE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSmaliKind(SmaliKind e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSmaliKind()[index];
}

namespace _Unit {

enum LanguageType {
  LanguageType_ALL = 0,
  LanguageType_OO = 1,
  LanguageType_CXX = 2,
  LanguageType_C = 3,
  LanguageType_C_FAMILY = 4,
  LanguageType_JAVA = 5,
  LanguageType_CSHARP = 6,
  LanguageType_OBJECTIVE_C = 7,
  LanguageType_MIN = LanguageType_ALL,
  LanguageType_MAX = LanguageType_OBJECTIVE_C
};

inline const char **EnumNamesLanguageType() {
  static const char *names[] = {
    "ALL",
    "OO",
    "CXX",
    "C",
    "C_FAMILY",
    "JAVA",
    "CSHARP",
    "OBJECTIVE_C",
    nullptr
  };
  return names;
}

inline const char *EnumNameLanguageType(LanguageType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLanguageType()[index];
}

}  // namespace _Unit

namespace _Literal {

enum LiteralType {
  LiteralType_number_type = 0,
  LiteralType_char_type = 1,
  LiteralType_string_type = 2,
  LiteralType_boolean_type = 3,
  LiteralType_null_type = 4,
  LiteralType_MIN = LiteralType_number_type,
  LiteralType_MAX = LiteralType_null_type
};

inline const char **EnumNamesLiteralType() {
  static const char *names[] = {
    "number_type",
    "char_type",
    "string_type",
    "boolean_type",
    "null_type",
    nullptr
  };
  return names;
}

inline const char *EnumNameLiteralType(LiteralType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLiteralType()[index];
}

}  // namespace _Literal
}  // namespace _Element

namespace _Delta {
namespace _Diff {

enum DeltaType {
  DeltaType_MATCH = 0,
  DeltaType_ADD = 1,
  DeltaType_DEL = 2,
  DeltaType_MOVE = 3,
  DeltaType_UPDATE = 4,
  DeltaType_MIN = DeltaType_MATCH,
  DeltaType_MAX = DeltaType_UPDATE
};

inline const char **EnumNamesDeltaType() {
  static const char *names[] = {
    "MATCH",
    "ADD",
    "DEL",
    "MOVE",
    "UPDATE",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeltaType(DeltaType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDeltaType()[index];
}

}  // namespace _Diff
}  // namespace _Delta

namespace _Pairs {
namespace _Pair {

enum CloneType {
  CloneType_MAYBE = 0,
  CloneType_YES = 1,
  CloneType_NO = 2,
  CloneType_MIN = CloneType_MAYBE,
  CloneType_MAX = CloneType_NO
};

inline const char **EnumNamesCloneType() {
  static const char *names[] = {
    "MAYBE",
    "YES",
    "NO",
    nullptr
  };
  return names;
}

inline const char *EnumNameCloneType(CloneType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCloneType()[index];
}

}  // namespace _Pair
}  // namespace _Pairs

namespace _Slices {
namespace _Slice {

enum ChangeType {
  ChangeType_UNCHANGED = 0,
  ChangeType_ADD = 1,
  ChangeType_DEL = 2,
  ChangeType_MIN = ChangeType_UNCHANGED,
  ChangeType_MAX = ChangeType_DEL
};

inline const char **EnumNamesChangeType() {
  static const char *names[] = {
    "UNCHANGED",
    "ADD",
    "DEL",
    nullptr
  };
  return names;
}

inline const char *EnumNameChangeType(ChangeType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesChangeType()[index];
}

}  // namespace _Slice
}  // namespace _Slices

struct Element FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KIND = 4,
    VT_TEXT = 6,
    VT_TAIL = 8,
    VT_POS = 10,
    VT_LENGTH = 12,
    VT_CHILD = 14,
    VT_EXTRA = 16,
    VT_LINE = 18,
    VT_COLUMN = 20
  };
  int32_t kind() const {
    return GetField<int32_t>(VT_KIND, 0);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  const flatbuffers::String *tail() const {
    return GetPointer<const flatbuffers::String *>(VT_TAIL);
  }
  int32_t pos() const {
    return GetField<int32_t>(VT_POS, 0);
  }
  int32_t length() const {
    return GetField<int32_t>(VT_LENGTH, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Element>> *child() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Element>> *>(VT_CHILD);
  }
  const _fast::_Element::Anonymous0 *extra() const {
    return GetPointer<const _fast::_Element::Anonymous0 *>(VT_EXTRA);
  }
  int32_t line() const {
    return GetField<int32_t>(VT_LINE, 0);
  }
  int32_t column() const {
    return GetField<int32_t>(VT_COLUMN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KIND) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TAIL) &&
           verifier.Verify(tail()) &&
           VerifyField<int32_t>(verifier, VT_POS) &&
           VerifyField<int32_t>(verifier, VT_LENGTH) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CHILD) &&
           verifier.Verify(child()) &&
           verifier.VerifyVectorOfTables(child()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EXTRA) &&
           verifier.VerifyTable(extra()) &&
           VerifyField<int32_t>(verifier, VT_LINE) &&
           VerifyField<int32_t>(verifier, VT_COLUMN) &&
           verifier.EndTable();
  }
};

struct ElementBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kind(int32_t kind) {
    fbb_.AddElement<int32_t>(Element::VT_KIND, kind, 0);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(Element::VT_TEXT, text);
  }
  void add_tail(flatbuffers::Offset<flatbuffers::String> tail) {
    fbb_.AddOffset(Element::VT_TAIL, tail);
  }
  void add_pos(int32_t pos) {
    fbb_.AddElement<int32_t>(Element::VT_POS, pos, 0);
  }
  void add_length(int32_t length) {
    fbb_.AddElement<int32_t>(Element::VT_LENGTH, length, 0);
  }
  void add_child(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Element>>> child) {
    fbb_.AddOffset(Element::VT_CHILD, child);
  }
  void add_extra(flatbuffers::Offset<_fast::_Element::Anonymous0> extra) {
    fbb_.AddOffset(Element::VT_EXTRA, extra);
  }
  void add_line(int32_t line) {
    fbb_.AddElement<int32_t>(Element::VT_LINE, line, 0);
  }
  void add_column(int32_t column) {
    fbb_.AddElement<int32_t>(Element::VT_COLUMN, column, 0);
  }
  ElementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ElementBuilder &operator=(const ElementBuilder &);
  flatbuffers::Offset<Element> Finish() {
    const auto end = fbb_.EndTable(start_, 9);
    auto o = flatbuffers::Offset<Element>(end);
    return o;
  }
};

inline flatbuffers::Offset<Element> CreateElement(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kind = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    flatbuffers::Offset<flatbuffers::String> tail = 0,
    int32_t pos = 0,
    int32_t length = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Element>>> child = 0,
    flatbuffers::Offset<_fast::_Element::Anonymous0> extra = 0,
    int32_t line = 0,
    int32_t column = 0) {
  ElementBuilder builder_(_fbb);
  builder_.add_column(column);
  builder_.add_line(line);
  builder_.add_extra(extra);
  builder_.add_child(child);
  builder_.add_length(length);
  builder_.add_pos(pos);
  builder_.add_tail(tail);
  builder_.add_text(text);
  builder_.add_kind(kind);
  return builder_.Finish();
}

inline flatbuffers::Offset<Element> CreateElementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kind = 0,
    const char *text = nullptr,
    const char *tail = nullptr,
    int32_t pos = 0,
    int32_t length = 0,
    const std::vector<flatbuffers::Offset<Element>> *child = nullptr,
    flatbuffers::Offset<_fast::_Element::Anonymous0> extra = 0,
    int32_t line = 0,
    int32_t column = 0) {
  return _fast::CreateElement(
      _fbb,
      kind,
      text ? _fbb.CreateString(text) : 0,
      tail ? _fbb.CreateString(tail) : 0,
      pos,
      length,
      child ? _fbb.CreateVector<flatbuffers::Offset<Element>>(*child) : 0,
      extra,
      line,
      column);
}

namespace _Element {

struct Anonymous0 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UNIT = 4,
    VT_LITERAL = 6
  };
  const Unit *unit() const {
    return GetPointer<const Unit *>(VT_UNIT);
  }
  const Literal *literal() const {
    return GetPointer<const Literal *>(VT_LITERAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UNIT) &&
           verifier.VerifyTable(unit()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LITERAL) &&
           verifier.VerifyTable(literal()) &&
           verifier.EndTable();
  }
};

struct Anonymous0Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_unit(flatbuffers::Offset<Unit> unit) {
    fbb_.AddOffset(Anonymous0::VT_UNIT, unit);
  }
  void add_literal(flatbuffers::Offset<Literal> literal) {
    fbb_.AddOffset(Anonymous0::VT_LITERAL, literal);
  }
  Anonymous0Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Anonymous0Builder &operator=(const Anonymous0Builder &);
  flatbuffers::Offset<Anonymous0> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Anonymous0>(end);
    return o;
  }
};

inline flatbuffers::Offset<Anonymous0> CreateAnonymous0(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Unit> unit = 0,
    flatbuffers::Offset<Literal> literal = 0) {
  Anonymous0Builder builder_(_fbb);
  builder_.add_literal(literal);
  builder_.add_unit(unit);
  return builder_.Finish();
}

struct Unit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FILENAME = 4,
    VT_REVISION = 6,
    VT_LANGUAGE = 8,
    VT_ITEM = 10
  };
  const flatbuffers::String *filename() const {
    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
  }
  const flatbuffers::String *revision() const {
    return GetPointer<const flatbuffers::String *>(VT_REVISION);
  }
  int32_t language() const {
    return GetField<int32_t>(VT_LANGUAGE, 0);
  }
  int32_t item() const {
    return GetField<int32_t>(VT_ITEM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FILENAME) &&
           verifier.Verify(filename()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_REVISION) &&
           verifier.Verify(revision()) &&
           VerifyField<int32_t>(verifier, VT_LANGUAGE) &&
           VerifyField<int32_t>(verifier, VT_ITEM) &&
           verifier.EndTable();
  }
};

struct UnitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) {
    fbb_.AddOffset(Unit::VT_FILENAME, filename);
  }
  void add_revision(flatbuffers::Offset<flatbuffers::String> revision) {
    fbb_.AddOffset(Unit::VT_REVISION, revision);
  }
  void add_language(int32_t language) {
    fbb_.AddElement<int32_t>(Unit::VT_LANGUAGE, language, 0);
  }
  void add_item(int32_t item) {
    fbb_.AddElement<int32_t>(Unit::VT_ITEM, item, 0);
  }
  UnitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnitBuilder &operator=(const UnitBuilder &);
  flatbuffers::Offset<Unit> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Unit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unit> CreateUnit(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> filename = 0,
    flatbuffers::Offset<flatbuffers::String> revision = 0,
    int32_t language = 0,
    int32_t item = 0) {
  UnitBuilder builder_(_fbb);
  builder_.add_item(item);
  builder_.add_language(language);
  builder_.add_revision(revision);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline flatbuffers::Offset<Unit> CreateUnitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr,
    const char *revision = nullptr,
    int32_t language = 0,
    int32_t item = 0) {
  return _fast::_Element::CreateUnit(
      _fbb,
      filename ? _fbb.CreateString(filename) : 0,
      revision ? _fbb.CreateString(revision) : 0,
      language,
      item);
}

struct Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct LiteralBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Literal::VT_TYPE, type, 0);
  }
  LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiteralBuilder &operator=(const LiteralBuilder &);
  flatbuffers::Offset<Literal> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Literal> CreateLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0) {
  LiteralBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

}  // namespace _Element

struct Delta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_DST = 6,
    VT_DIFF = 8
  };
  const flatbuffers::String *src() const {
    return GetPointer<const flatbuffers::String *>(VT_SRC);
  }
  const flatbuffers::String *dst() const {
    return GetPointer<const flatbuffers::String *>(VT_DST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Delta::Diff>> *diff() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Delta::Diff>> *>(VT_DIFF);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SRC) &&
           verifier.Verify(src()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DST) &&
           verifier.Verify(dst()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DIFF) &&
           verifier.Verify(diff()) &&
           verifier.VerifyVectorOfTables(diff()) &&
           verifier.EndTable();
  }
};

struct DeltaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(flatbuffers::Offset<flatbuffers::String> src) {
    fbb_.AddOffset(Delta::VT_SRC, src);
  }
  void add_dst(flatbuffers::Offset<flatbuffers::String> dst) {
    fbb_.AddOffset(Delta::VT_DST, dst);
  }
  void add_diff(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Delta::Diff>>> diff) {
    fbb_.AddOffset(Delta::VT_DIFF, diff);
  }
  DeltaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeltaBuilder &operator=(const DeltaBuilder &);
  flatbuffers::Offset<Delta> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Delta>(end);
    return o;
  }
};

inline flatbuffers::Offset<Delta> CreateDelta(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> src = 0,
    flatbuffers::Offset<flatbuffers::String> dst = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Delta::Diff>>> diff = 0) {
  DeltaBuilder builder_(_fbb);
  builder_.add_diff(diff);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

inline flatbuffers::Offset<Delta> CreateDeltaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *src = nullptr,
    const char *dst = nullptr,
    const std::vector<flatbuffers::Offset<_fast::_Delta::Diff>> *diff = nullptr) {
  return _fast::CreateDelta(
      _fbb,
      src ? _fbb.CreateString(src) : 0,
      dst ? _fbb.CreateString(dst) : 0,
      diff ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Delta::Diff>>(*diff) : 0);
}

namespace _Delta {

struct Diff FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_DELTA = 6
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const _fast::_Delta::_Diff::Anonymous1 *delta() const {
    return GetPointer<const _fast::_Delta::_Diff::Anonymous1 *>(VT_DELTA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DELTA) &&
           verifier.VerifyTable(delta()) &&
           verifier.EndTable();
  }
};

struct DiffBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Diff::VT_TYPE, type, 0);
  }
  void add_delta(flatbuffers::Offset<_fast::_Delta::_Diff::Anonymous1> delta) {
    fbb_.AddOffset(Diff::VT_DELTA, delta);
  }
  DiffBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiffBuilder &operator=(const DiffBuilder &);
  flatbuffers::Offset<Diff> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Diff>(end);
    return o;
  }
};

inline flatbuffers::Offset<Diff> CreateDiff(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    flatbuffers::Offset<_fast::_Delta::_Diff::Anonymous1> delta = 0) {
  DiffBuilder builder_(_fbb);
  builder_.add_delta(delta);
  builder_.add_type(type);
  return builder_.Finish();
}

namespace _Diff {

struct Anonymous1 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MATCH = 4,
    VT_ADD = 6,
    VT_DEL = 8,
    VT_MOVE = 10,
    VT_UPDATE = 12
  };
  const Match *match() const {
    return GetPointer<const Match *>(VT_MATCH);
  }
  const Add *add() const {
    return GetPointer<const Add *>(VT_ADD);
  }
  const Del *del() const {
    return GetPointer<const Del *>(VT_DEL);
  }
  const Move *move() const {
    return GetPointer<const Move *>(VT_MOVE);
  }
  const Update *update() const {
    return GetPointer<const Update *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MATCH) &&
           verifier.VerifyTable(match()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADD) &&
           verifier.VerifyTable(add()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DEL) &&
           verifier.VerifyTable(del()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MOVE) &&
           verifier.VerifyTable(move()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
};

struct Anonymous1Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_match(flatbuffers::Offset<Match> match) {
    fbb_.AddOffset(Anonymous1::VT_MATCH, match);
  }
  void add_add(flatbuffers::Offset<Add> add) {
    fbb_.AddOffset(Anonymous1::VT_ADD, add);
  }
  void add_del(flatbuffers::Offset<Del> del) {
    fbb_.AddOffset(Anonymous1::VT_DEL, del);
  }
  void add_move(flatbuffers::Offset<Move> move) {
    fbb_.AddOffset(Anonymous1::VT_MOVE, move);
  }
  void add_update(flatbuffers::Offset<Update> update) {
    fbb_.AddOffset(Anonymous1::VT_UPDATE, update);
  }
  Anonymous1Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Anonymous1Builder &operator=(const Anonymous1Builder &);
  flatbuffers::Offset<Anonymous1> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<Anonymous1>(end);
    return o;
  }
};

inline flatbuffers::Offset<Anonymous1> CreateAnonymous1(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Match> match = 0,
    flatbuffers::Offset<Add> add = 0,
    flatbuffers::Offset<Del> del = 0,
    flatbuffers::Offset<Move> move = 0,
    flatbuffers::Offset<Update> update = 0) {
  Anonymous1Builder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_move(move);
  builder_.add_del(del);
  builder_.add_add(add);
  builder_.add_match(match);
  return builder_.Finish();
}

struct Match FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_DST = 6
  };
  int32_t src() const {
    return GetField<int32_t>(VT_SRC, 0);
  }
  int32_t dst() const {
    return GetField<int32_t>(VT_DST, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRC) &&
           VerifyField<int32_t>(verifier, VT_DST) &&
           verifier.EndTable();
  }
};

struct MatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(int32_t src) {
    fbb_.AddElement<int32_t>(Match::VT_SRC, src, 0);
  }
  void add_dst(int32_t dst) {
    fbb_.AddElement<int32_t>(Match::VT_DST, dst, 0);
  }
  MatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatchBuilder &operator=(const MatchBuilder &);
  flatbuffers::Offset<Match> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Match>(end);
    return o;
  }
};

inline flatbuffers::Offset<Match> CreateMatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0,
    int32_t dst = 0) {
  MatchBuilder builder_(_fbb);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

struct Add FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_DST = 6,
    VT_POSITION = 8
  };
  int32_t src() const {
    return GetField<int32_t>(VT_SRC, 0);
  }
  int32_t dst() const {
    return GetField<int32_t>(VT_DST, 0);
  }
  int32_t position() const {
    return GetField<int32_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRC) &&
           VerifyField<int32_t>(verifier, VT_DST) &&
           VerifyField<int32_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct AddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(int32_t src) {
    fbb_.AddElement<int32_t>(Add::VT_SRC, src, 0);
  }
  void add_dst(int32_t dst) {
    fbb_.AddElement<int32_t>(Add::VT_DST, dst, 0);
  }
  void add_position(int32_t position) {
    fbb_.AddElement<int32_t>(Add::VT_POSITION, position, 0);
  }
  AddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddBuilder &operator=(const AddBuilder &);
  flatbuffers::Offset<Add> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Add>(end);
    return o;
  }
};

inline flatbuffers::Offset<Add> CreateAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0,
    int32_t dst = 0,
    int32_t position = 0) {
  AddBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

struct Del FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4
  };
  int32_t src() const {
    return GetField<int32_t>(VT_SRC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRC) &&
           verifier.EndTable();
  }
};

struct DelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(int32_t src) {
    fbb_.AddElement<int32_t>(Del::VT_SRC, src, 0);
  }
  DelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DelBuilder &operator=(const DelBuilder &);
  flatbuffers::Offset<Del> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Del>(end);
    return o;
  }
};

inline flatbuffers::Offset<Del> CreateDel(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0) {
  DelBuilder builder_(_fbb);
  builder_.add_src(src);
  return builder_.Finish();
}

struct Move FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_DST = 6,
    VT_POSITION = 8
  };
  int32_t src() const {
    return GetField<int32_t>(VT_SRC, 0);
  }
  int32_t dst() const {
    return GetField<int32_t>(VT_DST, 0);
  }
  int32_t position() const {
    return GetField<int32_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRC) &&
           VerifyField<int32_t>(verifier, VT_DST) &&
           VerifyField<int32_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct MoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(int32_t src) {
    fbb_.AddElement<int32_t>(Move::VT_SRC, src, 0);
  }
  void add_dst(int32_t dst) {
    fbb_.AddElement<int32_t>(Move::VT_DST, dst, 0);
  }
  void add_position(int32_t position) {
    fbb_.AddElement<int32_t>(Move::VT_POSITION, position, 0);
  }
  MoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveBuilder &operator=(const MoveBuilder &);
  flatbuffers::Offset<Move> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Move>(end);
    return o;
  }
};

inline flatbuffers::Offset<Move> CreateMove(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0,
    int32_t dst = 0,
    int32_t position = 0) {
  MoveBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

struct Update FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_LABEL = 6
  };
  int32_t src() const {
    return GetField<int32_t>(VT_SRC, 0);
  }
  const flatbuffers::String *label() const {
    return GetPointer<const flatbuffers::String *>(VT_LABEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRC) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LABEL) &&
           verifier.Verify(label()) &&
           verifier.EndTable();
  }
};

struct UpdateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(int32_t src) {
    fbb_.AddElement<int32_t>(Update::VT_SRC, src, 0);
  }
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(Update::VT_LABEL, label);
  }
  UpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdateBuilder &operator=(const UpdateBuilder &);
  flatbuffers::Offset<Update> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Update>(end);
    return o;
  }
};

inline flatbuffers::Offset<Update> CreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0,
    flatbuffers::Offset<flatbuffers::String> label = 0) {
  UpdateBuilder builder_(_fbb);
  builder_.add_label(label);
  builder_.add_src(src);
  return builder_.Finish();
}

inline flatbuffers::Offset<Update> CreateUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t src = 0,
    const char *label = nullptr) {
  return _fast::_Delta::_Diff::CreateUpdate(
      _fbb,
      src,
      label ? _fbb.CreateString(label) : 0);
}

}  // namespace _Diff
}  // namespace _Delta

struct Pairs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PAIR = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Pairs::Pair>> *pair() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Pairs::Pair>> *>(VT_PAIR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PAIR) &&
           verifier.Verify(pair()) &&
           verifier.VerifyVectorOfTables(pair()) &&
           verifier.EndTable();
  }
};

struct PairsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pair(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Pairs::Pair>>> pair) {
    fbb_.AddOffset(Pairs::VT_PAIR, pair);
  }
  PairsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PairsBuilder &operator=(const PairsBuilder &);
  flatbuffers::Offset<Pairs> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Pairs>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pairs> CreatePairs(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Pairs::Pair>>> pair = 0) {
  PairsBuilder builder_(_fbb);
  builder_.add_pair(pair);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pairs> CreatePairsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<_fast::_Pairs::Pair>> *pair = nullptr) {
  return _fast::CreatePairs(
      _fbb,
      pair ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Pairs::Pair>>(*pair) : 0);
}

namespace _Pairs {

struct Pair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PROJECT = 4,
    VT_LEFT = 6,
    VT_RIGHT = 8,
    VT_TYPE = 10
  };
  const flatbuffers::String *project() const {
    return GetPointer<const flatbuffers::String *>(VT_PROJECT);
  }
  const _fast::_Pairs::_Pair::Diff *left() const {
    return GetPointer<const _fast::_Pairs::_Pair::Diff *>(VT_LEFT);
  }
  const _fast::_Pairs::_Pair::Diff *right() const {
    return GetPointer<const _fast::_Pairs::_Pair::Diff *>(VT_RIGHT);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PROJECT) &&
           verifier.Verify(project()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LEFT) &&
           verifier.VerifyTable(left()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RIGHT) &&
           verifier.VerifyTable(right()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct PairBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_project(flatbuffers::Offset<flatbuffers::String> project) {
    fbb_.AddOffset(Pair::VT_PROJECT, project);
  }
  void add_left(flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> left) {
    fbb_.AddOffset(Pair::VT_LEFT, left);
  }
  void add_right(flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> right) {
    fbb_.AddOffset(Pair::VT_RIGHT, right);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Pair::VT_TYPE, type, 0);
  }
  PairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PairBuilder &operator=(const PairBuilder &);
  flatbuffers::Offset<Pair> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Pair>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pair> CreatePair(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> project = 0,
    flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> left = 0,
    flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> right = 0,
    int32_t type = 0) {
  PairBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_right(right);
  builder_.add_left(left);
  builder_.add_project(project);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pair> CreatePairDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *project = nullptr,
    flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> left = 0,
    flatbuffers::Offset<_fast::_Pairs::_Pair::Diff> right = 0,
    int32_t type = 0) {
  return _fast::_Pairs::CreatePair(
      _fbb,
      project ? _fbb.CreateString(project) : 0,
      left,
      right,
      type);
}

namespace _Pair {

struct Diff FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LEFT_LINE = 4,
    VT_LEFT_COLUMN = 6,
    VT_RIGHT_LINE = 8,
    VT_RIGHT_COLUMN = 10,
    VT_OLD_CODE = 12,
    VT_NEW_CODE = 14
  };
  int32_t left_line() const {
    return GetField<int32_t>(VT_LEFT_LINE, 0);
  }
  int32_t left_column() const {
    return GetField<int32_t>(VT_LEFT_COLUMN, 0);
  }
  int32_t right_line() const {
    return GetField<int32_t>(VT_RIGHT_LINE, 0);
  }
  int32_t right_column() const {
    return GetField<int32_t>(VT_RIGHT_COLUMN, 0);
  }
  const _fast::Element *old_code() const {
    return GetPointer<const _fast::Element *>(VT_OLD_CODE);
  }
  const _fast::Element *new_code() const {
    return GetPointer<const _fast::Element *>(VT_NEW_CODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LEFT_LINE) &&
           VerifyField<int32_t>(verifier, VT_LEFT_COLUMN) &&
           VerifyField<int32_t>(verifier, VT_RIGHT_LINE) &&
           VerifyField<int32_t>(verifier, VT_RIGHT_COLUMN) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OLD_CODE) &&
           verifier.VerifyTable(old_code()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NEW_CODE) &&
           verifier.VerifyTable(new_code()) &&
           verifier.EndTable();
  }
};

struct DiffBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_left_line(int32_t left_line) {
    fbb_.AddElement<int32_t>(Diff::VT_LEFT_LINE, left_line, 0);
  }
  void add_left_column(int32_t left_column) {
    fbb_.AddElement<int32_t>(Diff::VT_LEFT_COLUMN, left_column, 0);
  }
  void add_right_line(int32_t right_line) {
    fbb_.AddElement<int32_t>(Diff::VT_RIGHT_LINE, right_line, 0);
  }
  void add_right_column(int32_t right_column) {
    fbb_.AddElement<int32_t>(Diff::VT_RIGHT_COLUMN, right_column, 0);
  }
  void add_old_code(flatbuffers::Offset<_fast::Element> old_code) {
    fbb_.AddOffset(Diff::VT_OLD_CODE, old_code);
  }
  void add_new_code(flatbuffers::Offset<_fast::Element> new_code) {
    fbb_.AddOffset(Diff::VT_NEW_CODE, new_code);
  }
  DiffBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiffBuilder &operator=(const DiffBuilder &);
  flatbuffers::Offset<Diff> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<Diff>(end);
    return o;
  }
};

inline flatbuffers::Offset<Diff> CreateDiff(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t left_line = 0,
    int32_t left_column = 0,
    int32_t right_line = 0,
    int32_t right_column = 0,
    flatbuffers::Offset<_fast::Element> old_code = 0,
    flatbuffers::Offset<_fast::Element> new_code = 0) {
  DiffBuilder builder_(_fbb);
  builder_.add_new_code(new_code);
  builder_.add_old_code(old_code);
  builder_.add_right_column(right_column);
  builder_.add_right_line(right_line);
  builder_.add_left_column(left_column);
  builder_.add_left_line(left_line);
  return builder_.Finish();
}

}  // namespace _Pair
}  // namespace _Pairs

struct Log FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COMMIT = 4,
    VT_AUTHOR = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::Commit>> *commit() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::Commit>> *>(VT_COMMIT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::Author>> *author() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::Author>> *>(VT_AUTHOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COMMIT) &&
           verifier.Verify(commit()) &&
           verifier.VerifyVectorOfTables(commit()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_AUTHOR) &&
           verifier.Verify(author()) &&
           verifier.VerifyVectorOfTables(author()) &&
           verifier.EndTable();
  }
};

struct LogBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_commit(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::Commit>>> commit) {
    fbb_.AddOffset(Log::VT_COMMIT, commit);
  }
  void add_author(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::Author>>> author) {
    fbb_.AddOffset(Log::VT_AUTHOR, author);
  }
  LogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogBuilder &operator=(const LogBuilder &);
  flatbuffers::Offset<Log> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Log>(end);
    return o;
  }
};

inline flatbuffers::Offset<Log> CreateLog(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::Commit>>> commit = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::Author>>> author = 0) {
  LogBuilder builder_(_fbb);
  builder_.add_author(author);
  builder_.add_commit(commit);
  return builder_.Finish();
}

inline flatbuffers::Offset<Log> CreateLogDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<_fast::_Log::Commit>> *commit = nullptr,
    const std::vector<flatbuffers::Offset<_fast::_Log::Author>> *author = nullptr) {
  return _fast::CreateLog(
      _fbb,
      commit ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Log::Commit>>(*commit) : 0,
      author ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Log::Author>>(*author) : 0);
}

namespace _Log {

struct Commit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_TEXT = 6,
    VT_AUTHOR_ID = 8,
    VT_AUTHOR_DATE = 10,
    VT_EXTRA = 12,
    VT_DIFF = 14
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  int32_t author_id() const {
    return GetField<int32_t>(VT_AUTHOR_ID, 0);
  }
  const flatbuffers::String *author_date() const {
    return GetPointer<const flatbuffers::String *>(VT_AUTHOR_DATE);
  }
  const _fast::_Log::_Commit::Anonymous2 *extra() const {
    return GetPointer<const _fast::_Log::_Commit::Anonymous2 *>(VT_EXTRA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::Diff>> *diff() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::Diff>> *>(VT_DIFF);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ID) &&
           verifier.Verify(id()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           VerifyField<int32_t>(verifier, VT_AUTHOR_ID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_AUTHOR_DATE) &&
           verifier.Verify(author_date()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EXTRA) &&
           verifier.VerifyTable(extra()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DIFF) &&
           verifier.Verify(diff()) &&
           verifier.VerifyVectorOfTables(diff()) &&
           verifier.EndTable();
  }
};

struct CommitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Commit::VT_ID, id);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(Commit::VT_TEXT, text);
  }
  void add_author_id(int32_t author_id) {
    fbb_.AddElement<int32_t>(Commit::VT_AUTHOR_ID, author_id, 0);
  }
  void add_author_date(flatbuffers::Offset<flatbuffers::String> author_date) {
    fbb_.AddOffset(Commit::VT_AUTHOR_DATE, author_date);
  }
  void add_extra(flatbuffers::Offset<_fast::_Log::_Commit::Anonymous2> extra) {
    fbb_.AddOffset(Commit::VT_EXTRA, extra);
  }
  void add_diff(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::Diff>>> diff) {
    fbb_.AddOffset(Commit::VT_DIFF, diff);
  }
  CommitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommitBuilder &operator=(const CommitBuilder &);
  flatbuffers::Offset<Commit> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<Commit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Commit> CreateCommit(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    int32_t author_id = 0,
    flatbuffers::Offset<flatbuffers::String> author_date = 0,
    flatbuffers::Offset<_fast::_Log::_Commit::Anonymous2> extra = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::Diff>>> diff = 0) {
  CommitBuilder builder_(_fbb);
  builder_.add_diff(diff);
  builder_.add_extra(extra);
  builder_.add_author_date(author_date);
  builder_.add_author_id(author_id);
  builder_.add_text(text);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Commit> CreateCommitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *text = nullptr,
    int32_t author_id = 0,
    const char *author_date = nullptr,
    flatbuffers::Offset<_fast::_Log::_Commit::Anonymous2> extra = 0,
    const std::vector<flatbuffers::Offset<_fast::_Log::_Commit::Diff>> *diff = nullptr) {
  return _fast::_Log::CreateCommit(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      text ? _fbb.CreateString(text) : 0,
      author_id,
      author_date ? _fbb.CreateString(author_date) : 0,
      extra,
      diff ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Log::_Commit::Diff>>(*diff) : 0);
}

namespace _Commit {

struct Anonymous2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COMMITTER = 4
  };
  const Committer *committer() const {
    return GetPointer<const Committer *>(VT_COMMITTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COMMITTER) &&
           verifier.VerifyTable(committer()) &&
           verifier.EndTable();
  }
};

struct Anonymous2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_committer(flatbuffers::Offset<Committer> committer) {
    fbb_.AddOffset(Anonymous2::VT_COMMITTER, committer);
  }
  Anonymous2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Anonymous2Builder &operator=(const Anonymous2Builder &);
  flatbuffers::Offset<Anonymous2> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Anonymous2>(end);
    return o;
  }
};

inline flatbuffers::Offset<Anonymous2> CreateAnonymous2(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Committer> committer = 0) {
  Anonymous2Builder builder_(_fbb);
  builder_.add_committer(committer);
  return builder_.Finish();
}

struct Committer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COMMITTER_ID = 4,
    VT_COMMIT_DATE = 6
  };
  int32_t committer_id() const {
    return GetField<int32_t>(VT_COMMITTER_ID, 0);
  }
  const flatbuffers::String *commit_date() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMIT_DATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COMMITTER_ID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COMMIT_DATE) &&
           verifier.Verify(commit_date()) &&
           verifier.EndTable();
  }
};

struct CommitterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_committer_id(int32_t committer_id) {
    fbb_.AddElement<int32_t>(Committer::VT_COMMITTER_ID, committer_id, 0);
  }
  void add_commit_date(flatbuffers::Offset<flatbuffers::String> commit_date) {
    fbb_.AddOffset(Committer::VT_COMMIT_DATE, commit_date);
  }
  CommitterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommitterBuilder &operator=(const CommitterBuilder &);
  flatbuffers::Offset<Committer> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Committer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Committer> CreateCommitter(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t committer_id = 0,
    flatbuffers::Offset<flatbuffers::String> commit_date = 0) {
  CommitterBuilder builder_(_fbb);
  builder_.add_commit_date(commit_date);
  builder_.add_committer_id(committer_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Committer> CreateCommitterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t committer_id = 0,
    const char *commit_date = nullptr) {
  return _fast::_Log::_Commit::CreateCommitter(
      _fbb,
      committer_id,
      commit_date ? _fbb.CreateString(commit_date) : 0);
}

struct Diff FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_A = 4,
    VT_B = 6,
    VT_IS_NEW = 8,
    VT_IS_CODE = 10,
    VT_INDEX_FROM = 12,
    VT_INDEX_TO = 14,
    VT_MODE = 16,
    VT_HUNK = 18
  };
  const flatbuffers::String *a() const {
    return GetPointer<const flatbuffers::String *>(VT_A);
  }
  const flatbuffers::String *b() const {
    return GetPointer<const flatbuffers::String *>(VT_B);
  }
  bool is_new() const {
    return GetField<uint8_t>(VT_IS_NEW, 0) != 0;
  }
  const flatbuffers::String *is_code() const {
    return GetPointer<const flatbuffers::String *>(VT_IS_CODE);
  }
  const flatbuffers::String *index_from() const {
    return GetPointer<const flatbuffers::String *>(VT_INDEX_FROM);
  }
  const flatbuffers::String *index_to() const {
    return GetPointer<const flatbuffers::String *>(VT_INDEX_TO);
  }
  const flatbuffers::String *mode() const {
    return GetPointer<const flatbuffers::String *>(VT_MODE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::Hunk>> *hunk() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::Hunk>> *>(VT_HUNK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_A) &&
           verifier.Verify(a()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_B) &&
           verifier.Verify(b()) &&
           VerifyField<uint8_t>(verifier, VT_IS_NEW) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_IS_CODE) &&
           verifier.Verify(is_code()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_INDEX_FROM) &&
           verifier.Verify(index_from()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_INDEX_TO) &&
           verifier.Verify(index_to()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MODE) &&
           verifier.Verify(mode()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HUNK) &&
           verifier.Verify(hunk()) &&
           verifier.VerifyVectorOfTables(hunk()) &&
           verifier.EndTable();
  }
};

struct DiffBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_a(flatbuffers::Offset<flatbuffers::String> a) {
    fbb_.AddOffset(Diff::VT_A, a);
  }
  void add_b(flatbuffers::Offset<flatbuffers::String> b) {
    fbb_.AddOffset(Diff::VT_B, b);
  }
  void add_is_new(bool is_new) {
    fbb_.AddElement<uint8_t>(Diff::VT_IS_NEW, static_cast<uint8_t>(is_new), 0);
  }
  void add_is_code(flatbuffers::Offset<flatbuffers::String> is_code) {
    fbb_.AddOffset(Diff::VT_IS_CODE, is_code);
  }
  void add_index_from(flatbuffers::Offset<flatbuffers::String> index_from) {
    fbb_.AddOffset(Diff::VT_INDEX_FROM, index_from);
  }
  void add_index_to(flatbuffers::Offset<flatbuffers::String> index_to) {
    fbb_.AddOffset(Diff::VT_INDEX_TO, index_to);
  }
  void add_mode(flatbuffers::Offset<flatbuffers::String> mode) {
    fbb_.AddOffset(Diff::VT_MODE, mode);
  }
  void add_hunk(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::Hunk>>> hunk) {
    fbb_.AddOffset(Diff::VT_HUNK, hunk);
  }
  DiffBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiffBuilder &operator=(const DiffBuilder &);
  flatbuffers::Offset<Diff> Finish() {
    const auto end = fbb_.EndTable(start_, 8);
    auto o = flatbuffers::Offset<Diff>(end);
    return o;
  }
};

inline flatbuffers::Offset<Diff> CreateDiff(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> a = 0,
    flatbuffers::Offset<flatbuffers::String> b = 0,
    bool is_new = false,
    flatbuffers::Offset<flatbuffers::String> is_code = 0,
    flatbuffers::Offset<flatbuffers::String> index_from = 0,
    flatbuffers::Offset<flatbuffers::String> index_to = 0,
    flatbuffers::Offset<flatbuffers::String> mode = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::Hunk>>> hunk = 0) {
  DiffBuilder builder_(_fbb);
  builder_.add_hunk(hunk);
  builder_.add_mode(mode);
  builder_.add_index_to(index_to);
  builder_.add_index_from(index_from);
  builder_.add_is_code(is_code);
  builder_.add_b(b);
  builder_.add_a(a);
  builder_.add_is_new(is_new);
  return builder_.Finish();
}

inline flatbuffers::Offset<Diff> CreateDiffDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *a = nullptr,
    const char *b = nullptr,
    bool is_new = false,
    const char *is_code = nullptr,
    const char *index_from = nullptr,
    const char *index_to = nullptr,
    const char *mode = nullptr,
    const std::vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::Hunk>> *hunk = nullptr) {
  return _fast::_Log::_Commit::CreateDiff(
      _fbb,
      a ? _fbb.CreateString(a) : 0,
      b ? _fbb.CreateString(b) : 0,
      is_new,
      is_code ? _fbb.CreateString(is_code) : 0,
      index_from ? _fbb.CreateString(index_from) : 0,
      index_to ? _fbb.CreateString(index_to) : 0,
      mode ? _fbb.CreateString(mode) : 0,
      hunk ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::Hunk>>(*hunk) : 0);
}

namespace _Diff {

struct Hunk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FROM_LINENO = 4,
    VT_FROM_COLUMN = 6,
    VT_TO_LINENO = 8,
    VT_TO_COLUMN = 10,
    VT_CONTEXT = 12,
    VT_ELEMENT = 14,
    VT_MOD = 16
  };
  int32_t from_lineno() const {
    return GetField<int32_t>(VT_FROM_LINENO, 0);
  }
  int32_t from_column() const {
    return GetField<int32_t>(VT_FROM_COLUMN, 0);
  }
  int32_t to_lineno() const {
    return GetField<int32_t>(VT_TO_LINENO, 0);
  }
  int32_t to_column() const {
    return GetField<int32_t>(VT_TO_COLUMN, 0);
  }
  const flatbuffers::String *context() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTEXT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::Element>> *element() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::Element>> *>(VT_ELEMENT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::_Hunk::ModLine>> *mod() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::_Hunk::ModLine>> *>(VT_MOD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FROM_LINENO) &&
           VerifyField<int32_t>(verifier, VT_FROM_COLUMN) &&
           VerifyField<int32_t>(verifier, VT_TO_LINENO) &&
           VerifyField<int32_t>(verifier, VT_TO_COLUMN) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CONTEXT) &&
           verifier.Verify(context()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ELEMENT) &&
           verifier.Verify(element()) &&
           verifier.VerifyVectorOfTables(element()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MOD) &&
           verifier.Verify(mod()) &&
           verifier.VerifyVectorOfTables(mod()) &&
           verifier.EndTable();
  }
};

struct HunkBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_from_lineno(int32_t from_lineno) {
    fbb_.AddElement<int32_t>(Hunk::VT_FROM_LINENO, from_lineno, 0);
  }
  void add_from_column(int32_t from_column) {
    fbb_.AddElement<int32_t>(Hunk::VT_FROM_COLUMN, from_column, 0);
  }
  void add_to_lineno(int32_t to_lineno) {
    fbb_.AddElement<int32_t>(Hunk::VT_TO_LINENO, to_lineno, 0);
  }
  void add_to_column(int32_t to_column) {
    fbb_.AddElement<int32_t>(Hunk::VT_TO_COLUMN, to_column, 0);
  }
  void add_context(flatbuffers::Offset<flatbuffers::String> context) {
    fbb_.AddOffset(Hunk::VT_CONTEXT, context);
  }
  void add_element(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::Element>>> element) {
    fbb_.AddOffset(Hunk::VT_ELEMENT, element);
  }
  void add_mod(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::_Hunk::ModLine>>> mod) {
    fbb_.AddOffset(Hunk::VT_MOD, mod);
  }
  HunkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HunkBuilder &operator=(const HunkBuilder &);
  flatbuffers::Offset<Hunk> Finish() {
    const auto end = fbb_.EndTable(start_, 7);
    auto o = flatbuffers::Offset<Hunk>(end);
    return o;
  }
};

inline flatbuffers::Offset<Hunk> CreateHunk(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t from_lineno = 0,
    int32_t from_column = 0,
    int32_t to_lineno = 0,
    int32_t to_column = 0,
    flatbuffers::Offset<flatbuffers::String> context = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::Element>>> element = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::_Hunk::ModLine>>> mod = 0) {
  HunkBuilder builder_(_fbb);
  builder_.add_mod(mod);
  builder_.add_element(element);
  builder_.add_context(context);
  builder_.add_to_column(to_column);
  builder_.add_to_lineno(to_lineno);
  builder_.add_from_column(from_column);
  builder_.add_from_lineno(from_lineno);
  return builder_.Finish();
}

inline flatbuffers::Offset<Hunk> CreateHunkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t from_lineno = 0,
    int32_t from_column = 0,
    int32_t to_lineno = 0,
    int32_t to_column = 0,
    const char *context = nullptr,
    const std::vector<flatbuffers::Offset<_fast::Element>> *element = nullptr,
    const std::vector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::_Hunk::ModLine>> *mod = nullptr) {
  return _fast::_Log::_Commit::_Diff::CreateHunk(
      _fbb,
      from_lineno,
      from_column,
      to_lineno,
      to_column,
      context ? _fbb.CreateString(context) : 0,
      element ? _fbb.CreateVector<flatbuffers::Offset<_fast::Element>>(*element) : 0,
      mod ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Log::_Commit::_Diff::_Hunk::ModLine>>(*mod) : 0);
}

namespace _Hunk {

struct ModLine FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LINE = 4,
    VT_IS_ADD = 6,
    VT_IS_DEL = 8
  };
  const flatbuffers::String *line() const {
    return GetPointer<const flatbuffers::String *>(VT_LINE);
  }
  bool is_add() const {
    return GetField<uint8_t>(VT_IS_ADD, 0) != 0;
  }
  bool is_del() const {
    return GetField<uint8_t>(VT_IS_DEL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LINE) &&
           verifier.Verify(line()) &&
           VerifyField<uint8_t>(verifier, VT_IS_ADD) &&
           VerifyField<uint8_t>(verifier, VT_IS_DEL) &&
           verifier.EndTable();
  }
};

struct ModLineBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_line(flatbuffers::Offset<flatbuffers::String> line) {
    fbb_.AddOffset(ModLine::VT_LINE, line);
  }
  void add_is_add(bool is_add) {
    fbb_.AddElement<uint8_t>(ModLine::VT_IS_ADD, static_cast<uint8_t>(is_add), 0);
  }
  void add_is_del(bool is_del) {
    fbb_.AddElement<uint8_t>(ModLine::VT_IS_DEL, static_cast<uint8_t>(is_del), 0);
  }
  ModLineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModLineBuilder &operator=(const ModLineBuilder &);
  flatbuffers::Offset<ModLine> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<ModLine>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModLine> CreateModLine(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> line = 0,
    bool is_add = false,
    bool is_del = false) {
  ModLineBuilder builder_(_fbb);
  builder_.add_line(line);
  builder_.add_is_del(is_del);
  builder_.add_is_add(is_add);
  return builder_.Finish();
}

inline flatbuffers::Offset<ModLine> CreateModLineDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *line = nullptr,
    bool is_add = false,
    bool is_del = false) {
  return _fast::_Log::_Commit::_Diff::_Hunk::CreateModLine(
      _fbb,
      line ? _fbb.CreateString(line) : 0,
      is_add,
      is_del);
}

}  // namespace _Hunk
}  // namespace _Diff
}  // namespace _Commit

struct Author FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_NAME = 6,
    VT_EMAIL = 8
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *email() const {
    return GetPointer<const flatbuffers::String *>(VT_EMAIL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EMAIL) &&
           verifier.Verify(email()) &&
           verifier.EndTable();
  }
};

struct AuthorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Author::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Author::VT_NAME, name);
  }
  void add_email(flatbuffers::Offset<flatbuffers::String> email) {
    fbb_.AddOffset(Author::VT_EMAIL, email);
  }
  AuthorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthorBuilder &operator=(const AuthorBuilder &);
  flatbuffers::Offset<Author> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Author>(end);
    return o;
  }
};

inline flatbuffers::Offset<Author> CreateAuthor(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> email = 0) {
  AuthorBuilder builder_(_fbb);
  builder_.add_email(email);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Author> CreateAuthorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *name = nullptr,
    const char *email = nullptr) {
  return _fast::_Log::CreateAuthor(
      _fbb,
      id,
      name ? _fbb.CreateString(name) : 0,
      email ? _fbb.CreateString(email) : 0);
}

}  // namespace _Log

struct Slices FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SLICE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::Slice>> *slice() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::Slice>> *>(VT_SLICE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SLICE) &&
           verifier.Verify(slice()) &&
           verifier.VerifyVectorOfTables(slice()) &&
           verifier.EndTable();
  }
};

struct SlicesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slice(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::Slice>>> slice) {
    fbb_.AddOffset(Slices::VT_SLICE, slice);
  }
  SlicesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SlicesBuilder &operator=(const SlicesBuilder &);
  flatbuffers::Offset<Slices> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Slices>(end);
    return o;
  }
};

inline flatbuffers::Offset<Slices> CreateSlices(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::Slice>>> slice = 0) {
  SlicesBuilder builder_(_fbb);
  builder_.add_slice(slice);
  return builder_.Finish();
}

inline flatbuffers::Offset<Slices> CreateSlicesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<_fast::_Slices::Slice>> *slice = nullptr) {
  return _fast::CreateSlices(
      _fbb,
      slice ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Slices::Slice>>(*slice) : 0);
}

namespace _Slices {

struct Slice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FILE = 4,
    VT_HASH = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::SourceFile>> *file() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::SourceFile>> *>(VT_FILE);
  }
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FILE) &&
           verifier.Verify(file()) &&
           verifier.VerifyVectorOfTables(file()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HASH) &&
           verifier.Verify(hash()) &&
           verifier.EndTable();
  }
};

struct SliceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::SourceFile>>> file) {
    fbb_.AddOffset(Slice::VT_FILE, file);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(Slice::VT_HASH, hash);
  }
  SliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SliceBuilder &operator=(const SliceBuilder &);
  flatbuffers::Offset<Slice> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Slice>(end);
    return o;
  }
};

inline flatbuffers::Offset<Slice> CreateSlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::SourceFile>>> file = 0,
    flatbuffers::Offset<flatbuffers::String> hash = 0) {
  SliceBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_file(file);
  return builder_.Finish();
}

inline flatbuffers::Offset<Slice> CreateSliceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<_fast::_Slices::_Slice::SourceFile>> *file = nullptr,
    const char *hash = nullptr) {
  return _fast::_Slices::CreateSlice(
      _fbb,
      file ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Slices::_Slice::SourceFile>>(*file) : 0,
      hash ? _fbb.CreateString(hash) : 0);
}

namespace _Slice {

struct SourceFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FUNCTION = 4,
    VT_NAME = 6,
    VT_TYPE = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::Function>> *function() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::Function>> *>(VT_FUNCTION);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FUNCTION) &&
           verifier.Verify(function()) &&
           verifier.VerifyVectorOfTables(function()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct SourceFileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_function(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::Function>>> function) {
    fbb_.AddOffset(SourceFile::VT_FUNCTION, function);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SourceFile::VT_NAME, name);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SourceFile::VT_TYPE, type, 0);
  }
  SourceFileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SourceFileBuilder &operator=(const SourceFileBuilder &);
  flatbuffers::Offset<SourceFile> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<SourceFile>(end);
    return o;
  }
};

inline flatbuffers::Offset<SourceFile> CreateSourceFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::Function>>> function = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t type = 0) {
  SourceFileBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_function(function);
  return builder_.Finish();
}

inline flatbuffers::Offset<SourceFile> CreateSourceFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::Function>> *function = nullptr,
    const char *name = nullptr,
    int32_t type = 0) {
  return _fast::_Slices::_Slice::CreateSourceFile(
      _fbb,
      function ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::Function>>(*function) : 0,
      name ? _fbb.CreateString(name) : 0,
      type);
}

namespace _SourceFile {

struct Function FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VARIABLE = 4,
    VT_NAME = 6,
    VT_TYPE = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::Variable>> *variable() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::Variable>> *>(VT_VARIABLE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VARIABLE) &&
           verifier.Verify(variable()) &&
           verifier.VerifyVectorOfTables(variable()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct FunctionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_variable(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::Variable>>> variable) {
    fbb_.AddOffset(Function::VT_VARIABLE, variable);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Function::VT_NAME, name);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Function::VT_TYPE, type, 0);
  }
  FunctionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FunctionBuilder &operator=(const FunctionBuilder &);
  flatbuffers::Offset<Function> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Function>(end);
    return o;
  }
};

inline flatbuffers::Offset<Function> CreateFunction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::Variable>>> variable = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t type = 0) {
  FunctionBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_variable(variable);
  return builder_.Finish();
}

inline flatbuffers::Offset<Function> CreateFunctionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::Variable>> *variable = nullptr,
    const char *name = nullptr,
    int32_t type = 0) {
  return _fast::_Slices::_Slice::_SourceFile::CreateFunction(
      _fbb,
      variable ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::Variable>>(*variable) : 0,
      name ? _fbb.CreateString(name) : 0,
      type);
}

namespace _Function {

struct Variable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_POS = 6,
    VT_TYPE = 8,
    VT_DEFN = 10,
    VT_USE = 12,
    VT_DVAR = 14,
    VT_ALIAS = 16,
    VT_CFUNC = 18
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const _fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position *pos() const {
    return GetPointer<const _fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position *>(VT_POS);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>> *defn() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>> *>(VT_DEFN);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>> *use() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>> *>(VT_USE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *dvar() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DVAR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *alias() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ALIAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::FunctionDecl>> *cfunc() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::FunctionDecl>> *>(VT_CFUNC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DEFN) &&
           verifier.Verify(defn()) &&
           verifier.VerifyVectorOfTables(defn()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_USE) &&
           verifier.Verify(use()) &&
           verifier.VerifyVectorOfTables(use()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DVAR) &&
           verifier.Verify(dvar()) &&
           verifier.VerifyVectorOfStrings(dvar()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ALIAS) &&
           verifier.Verify(alias()) &&
           verifier.VerifyVectorOfStrings(alias()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CFUNC) &&
           verifier.Verify(cfunc()) &&
           verifier.VerifyVectorOfTables(cfunc()) &&
           verifier.EndTable();
  }
};

struct VariableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Variable::VT_NAME, name);
  }
  void add_pos(flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position> pos) {
    fbb_.AddOffset(Variable::VT_POS, pos);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Variable::VT_TYPE, type, 0);
  }
  void add_defn(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>>> defn) {
    fbb_.AddOffset(Variable::VT_DEFN, defn);
  }
  void add_use(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>>> use) {
    fbb_.AddOffset(Variable::VT_USE, use);
  }
  void add_dvar(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> dvar) {
    fbb_.AddOffset(Variable::VT_DVAR, dvar);
  }
  void add_alias(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> alias) {
    fbb_.AddOffset(Variable::VT_ALIAS, alias);
  }
  void add_cfunc(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::FunctionDecl>>> cfunc) {
    fbb_.AddOffset(Variable::VT_CFUNC, cfunc);
  }
  VariableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VariableBuilder &operator=(const VariableBuilder &);
  flatbuffers::Offset<Variable> Finish() {
    const auto end = fbb_.EndTable(start_, 8);
    auto o = flatbuffers::Offset<Variable>(end);
    return o;
  }
};

inline flatbuffers::Offset<Variable> CreateVariable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position> pos = 0,
    int32_t type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>>> defn = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>>> use = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> dvar = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> alias = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::FunctionDecl>>> cfunc = 0) {
  VariableBuilder builder_(_fbb);
  builder_.add_cfunc(cfunc);
  builder_.add_alias(alias);
  builder_.add_dvar(dvar);
  builder_.add_use(use);
  builder_.add_defn(defn);
  builder_.add_type(type);
  builder_.add_pos(pos);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Variable> CreateVariableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position> pos = 0,
    int32_t type = 0,
    const std::vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>> *defn = nullptr,
    const std::vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>> *use = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *dvar = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *alias = nullptr,
    const std::vector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::FunctionDecl>> *cfunc = nullptr) {
  return _fast::_Slices::_Slice::_SourceFile::_Function::CreateVariable(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      pos,
      type,
      defn ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>>(*defn) : 0,
      use ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::Position>>(*use) : 0,
      dvar ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*dvar) : 0,
      alias ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*alias) : 0,
      cfunc ? _fbb.CreateVector<flatbuffers::Offset<_fast::_Slices::_Slice::_SourceFile::_Function::_Variable::FunctionDecl>>(*cfunc) : 0);
}

namespace _Variable {

struct Position FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LINENO = 4,
    VT_TYPE = 6,
    VT_DELTA_LINENO = 8
  };
  int32_t lineno() const {
    return GetField<int32_t>(VT_LINENO, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t delta_lineno() const {
    return GetField<int32_t>(VT_DELTA_LINENO, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LINENO) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_DELTA_LINENO) &&
           verifier.EndTable();
  }
};

struct PositionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lineno(int32_t lineno) {
    fbb_.AddElement<int32_t>(Position::VT_LINENO, lineno, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Position::VT_TYPE, type, 0);
  }
  void add_delta_lineno(int32_t delta_lineno) {
    fbb_.AddElement<int32_t>(Position::VT_DELTA_LINENO, delta_lineno, 0);
  }
  PositionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PositionBuilder &operator=(const PositionBuilder &);
  flatbuffers::Offset<Position> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Position>(end);
    return o;
  }
};

inline flatbuffers::Offset<Position> CreatePosition(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t lineno = 0,
    int32_t type = 0,
    int32_t delta_lineno = 0) {
  PositionBuilder builder_(_fbb);
  builder_.add_delta_lineno(delta_lineno);
  builder_.add_type(type);
  builder_.add_lineno(lineno);
  return builder_.Finish();
}

struct FunctionDecl FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_LINENO = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t lineno() const {
    return GetField<int32_t>(VT_LINENO, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_LINENO) &&
           verifier.EndTable();
  }
};

struct FunctionDeclBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FunctionDecl::VT_NAME, name);
  }
  void add_lineno(int32_t lineno) {
    fbb_.AddElement<int32_t>(FunctionDecl::VT_LINENO, lineno, 0);
  }
  FunctionDeclBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FunctionDeclBuilder &operator=(const FunctionDeclBuilder &);
  flatbuffers::Offset<FunctionDecl> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<FunctionDecl>(end);
    return o;
  }
};

inline flatbuffers::Offset<FunctionDecl> CreateFunctionDecl(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t lineno = 0) {
  FunctionDeclBuilder builder_(_fbb);
  builder_.add_lineno(lineno);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<FunctionDecl> CreateFunctionDeclDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t lineno = 0) {
  return _fast::_Slices::_Slice::_SourceFile::_Function::_Variable::CreateFunctionDecl(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      lineno);
}

}  // namespace _Variable
}  // namespace _Function
}  // namespace _SourceFile
}  // namespace _Slice
}  // namespace _Slices

struct Data FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECORDTYPE = 4
  };
  const _fast::_Data::Anonymous3 *RecordType() const {
    return GetPointer<const _fast::_Data::Anonymous3 *>(VT_RECORDTYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RECORDTYPE) &&
           verifier.VerifyTable(RecordType()) &&
           verifier.EndTable();
  }
};

struct DataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_RecordType(flatbuffers::Offset<_fast::_Data::Anonymous3> RecordType) {
    fbb_.AddOffset(Data::VT_RECORDTYPE, RecordType);
  }
  DataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataBuilder &operator=(const DataBuilder &);
  flatbuffers::Offset<Data> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Data>(end);
    return o;
  }
};

inline flatbuffers::Offset<Data> CreateData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<_fast::_Data::Anonymous3> RecordType = 0) {
  DataBuilder builder_(_fbb);
  builder_.add_RecordType(RecordType);
  return builder_.Finish();
}

namespace _Data {

struct Anonymous3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ELEMENT = 4,
    VT_LOG = 6,
    VT_DELTA = 8,
    VT_PAIRS = 10,
    VT_SLICES = 12
  };
  const _fast::Element *element() const {
    return GetPointer<const _fast::Element *>(VT_ELEMENT);
  }
  const _fast::Log *log() const {
    return GetPointer<const _fast::Log *>(VT_LOG);
  }
  const _fast::Delta *delta() const {
    return GetPointer<const _fast::Delta *>(VT_DELTA);
  }
  const _fast::Pairs *pairs() const {
    return GetPointer<const _fast::Pairs *>(VT_PAIRS);
  }
  const _fast::Slices *slices() const {
    return GetPointer<const _fast::Slices *>(VT_SLICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ELEMENT) &&
           verifier.VerifyTable(element()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LOG) &&
           verifier.VerifyTable(log()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DELTA) &&
           verifier.VerifyTable(delta()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PAIRS) &&
           verifier.VerifyTable(pairs()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SLICES) &&
           verifier.VerifyTable(slices()) &&
           verifier.EndTable();
  }
};

struct Anonymous3Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_element(flatbuffers::Offset<_fast::Element> element) {
    fbb_.AddOffset(Anonymous3::VT_ELEMENT, element);
  }
  void add_log(flatbuffers::Offset<_fast::Log> log) {
    fbb_.AddOffset(Anonymous3::VT_LOG, log);
  }
  void add_delta(flatbuffers::Offset<_fast::Delta> delta) {
    fbb_.AddOffset(Anonymous3::VT_DELTA, delta);
  }
  void add_pairs(flatbuffers::Offset<_fast::Pairs> pairs) {
    fbb_.AddOffset(Anonymous3::VT_PAIRS, pairs);
  }
  void add_slices(flatbuffers::Offset<_fast::Slices> slices) {
    fbb_.AddOffset(Anonymous3::VT_SLICES, slices);
  }
  Anonymous3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Anonymous3Builder &operator=(const Anonymous3Builder &);
  flatbuffers::Offset<Anonymous3> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<Anonymous3>(end);
    return o;
  }
};

inline flatbuffers::Offset<Anonymous3> CreateAnonymous3(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<_fast::Element> element = 0,
    flatbuffers::Offset<_fast::Log> log = 0,
    flatbuffers::Offset<_fast::Delta> delta = 0,
    flatbuffers::Offset<_fast::Pairs> pairs = 0,
    flatbuffers::Offset<_fast::Slices> slices = 0) {
  Anonymous3Builder builder_(_fbb);
  builder_.add_slices(slices);
  builder_.add_pairs(pairs);
  builder_.add_delta(delta);
  builder_.add_log(log);
  builder_.add_element(element);
  return builder_.Finish();
}

}  // namespace _Data

namespace _Element {

}  // namespace _Element

namespace _Delta {

namespace _Diff {

}  // namespace _Diff
}  // namespace _Delta

namespace _Pairs {

namespace _Pair {

}  // namespace _Pair
}  // namespace _Pairs

namespace _Log {

namespace _Commit {

namespace _Diff {

namespace _Hunk {

}  // namespace _Hunk
}  // namespace _Diff
}  // namespace _Commit

}  // namespace _Log

namespace _Slices {

namespace _Slice {

namespace _SourceFile {

namespace _Function {

namespace _Variable {

}  // namespace _Variable
}  // namespace _Function
}  // namespace _SourceFile
}  // namespace _Slice
}  // namespace _Slices

namespace _Data {

}  // namespace _Data
}  // namespace _fast

#endif  // FLATBUFFERS_GENERATED_FAST__FAST__DATA_H_
