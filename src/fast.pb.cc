// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fast.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "fast.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace fast {
class Element_UnitDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Element_Unit> {
} _Element_Unit_default_instance_;
class Element_LiteralDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Element_Literal> {
} _Element_Literal_default_instance_;
class ElementDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Element> {
  public:
  const ::fast::Element_Unit* unit_;
  const ::fast::Element_Literal* literal_;
} _Element_default_instance_;

namespace protobuf_fast_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[3];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[3];

}  // namespace

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Element_Unit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Element_Unit, filename_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Element_Unit, revision_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Element_Unit, language_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Element_Unit, item_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Element_Literal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Element_Literal, type_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Element, _internal_metadata_),
  ~0u,  // no _extensions_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Element, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Element, kind_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Element, text_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Element, tail_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Element, child_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_Element_default_instance_), unit_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_Element_default_instance_), literal_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Element, extra_),
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, -1, sizeof(Element_Unit)},
  { 9, -1, sizeof(Element_Literal)},
  { 15, -1, sizeof(Element)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_Element_Unit_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Element_Literal_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Element_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "fast.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 3);
}

}  // namespace

void TableStruct::Shutdown() {
  _Element_Unit_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _Element_Literal_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _Element_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  _Element_Unit_default_instance_.DefaultConstruct();
  _Element_Literal_default_instance_.DefaultConstruct();
  _Element_default_instance_.DefaultConstruct();
  _Element_default_instance_.unit_ = const_cast< ::fast::Element_Unit*>(
      ::fast::Element_Unit::internal_default_instance());
  _Element_default_instance_.literal_ = const_cast< ::fast::Element_Literal*>(
      ::fast::Element_Literal::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n\nfast.proto\022\004fast\"\3406\n\007Element\022 \n\004kind\030\001"
      " \001(\0162\022.fast.Element.Kind\022\014\n\004text\030\002 \001(\t\022\014"
      "\n\004tail\030\003 \001(\t\022\034\n\005child\030\004 \003(\0132\r.fast.Eleme"
      "nt\022\"\n\004unit\030\005 \001(\0132\022.fast.Element.UnitH\000\022("
      "\n\007literal\030\006 \001(\0132\025.fast.Element.LiteralH\000"
      "\032\321\001\n\004Unit\022\020\n\010filename\030\001 \001(\t\022\020\n\010revision\030"
      "\002 \001(\t\0221\n\010language\030\003 \001(\0162\037.fast.Element.U"
      "nit.LanguageType\022\014\n\004item\030\004 \001(\005\"d\n\014Langua"
      "geType\022\007\n\003ALL\020\000\022\006\n\002OO\020\001\022\007\n\003CXX\020\002\022\005\n\001C\020\003\022"
      "\014\n\010C_FAMILY\020\004\022\010\n\004JAVA\020\005\022\n\n\006CSHARP\020\006\022\017\n\013O"
      "BJECTIVE_C\020\007\032\233\001\n\007Literal\022/\n\004type\030\001 \001(\0162!"
      ".fast.Element.Literal.LiteralType\"_\n\013Lit"
      "eralType\022\017\n\013number_type\020\000\022\r\n\tchar_type\020\001"
      "\022\017\n\013string_type\020\002\022\020\n\014boolean_type\020\003\022\r\n\tn"
      "ull_type\020\004\"\2572\n\004Kind\022\r\n\tUNIT_KIND\020\000\022\010\n\004DE"
      "CL\020\001\022\r\n\tDECL_STMT\020\002\022\010\n\004INIT\020\003\022\010\n\004EXPR\020\004\022"
      "\r\n\tEXPR_STMT\020\005\022\013\n\007COMMENT\020\006\022\010\n\004CALL\020\007\022\013\n"
      "\007CONTROL\020\010\022\010\n\004INCR\020\t\022\010\n\004NONE\020\n\022\014\n\010VARIAB"
      "LE\020\013\022\014\n\010FUNCTION\020\014\022\021\n\rFUNCTION_DECL\020\r\022\017\n"
      "\013CONSTRUCTOR\020\016\022\024\n\020CONSTRUCTOR_DECL\020\017\022\016\n\n"
      "DESTRUCTOR\020\020\022\023\n\017DESTRUCTOR_DECL\020\021\022\t\n\005MAC"
      "RO\020\022\022\020\n\014SINGLE_MACRO\020\023\022\020\n\014NULLOPERATOR\020\024"
      "\022\r\n\tENUM_DEFN\020\025\022\r\n\tENUM_DECL\020\026\022\024\n\020GLOBAL"
      "_ATTRIBUTE\020\027\022\025\n\021PROPERTY_ACCESSOR\020\030\022\032\n\026P"
      "ROPERTY_ACCESSOR_DECL\020\031\022\016\n\nEXPRESSION\020\032\022"
      "\016\n\nCLASS_DEFN\020\033\022\016\n\nCLASS_DECL\020\034\022\016\n\nUNION"
      "_DEFN\020\035\022\016\n\nUNION_DECL\020\036\022\017\n\013STRUCT_DEFN\020\037"
      "\022\017\n\013STRUCT_DECL\020 \022\022\n\016INTERFACE_DEFN\020!\022\022\n"
      "\016INTERFACE_DECL\020\"\022\021\n\rACCESS_REGION\020#\022\t\n\005"
      "USING\020$\022\025\n\021OPERATOR_FUNCTION\020%\022\032\n\026OPERAT"
      "OR_FUNCTION_DECL\020&\022\t\n\005EVENT\020\'\022\014\n\010PROPERT"
      "Y\020(\022\023\n\017ANNOTATION_DEFN\020)\022\023\n\017GLOBAL_TEMPL"
      "ATE\020*\022\010\n\004UNIT\020+\022\026\n\022TART_ELEMENT_TOKEN\020,\022"
      "\007\n\003NOP\020-\022\n\n\006STRING\020.\022\010\n\004CHAR\020/\022\013\n\007LITERA"
      "L\0200\022\013\n\007BOOLEAN\0201\022\010\n\004NULL\0202\022\013\n\007COMPLEX\0203\022"
      "\014\n\010OPERATOR\0204\022\014\n\010MODIFIER\0205\022\010\n\004NAME\0206\022\t\n"
      "\005ONAME\0207\022\t\n\005CNAME\0208\022\010\n\004TYPE\0209\022\014\n\010TYPEPRE"
      "V\020:\022\r\n\tCONDITION\020;\022\t\n\005BLOCK\020<\022\020\n\014PSEUDO_"
      "BLOCK\020=\022\t\n\005INDEX\020>\022\010\n\004ENUM\020\?\022\024\n\020ENUM_DEC"
      "LARATION\020@\022\020\n\014IF_STATEMENT\020A\022\013\n\007TERNARY\020"
      "B\022\010\n\004THEN\020C\022\010\n\004ELSE\020D\022\n\n\006ELSEIF\020E\022\023\n\017WHI"
      "LE_STATEMENT\020F\022\020\n\014DO_STATEMENT\020G\022\021\n\rFOR_"
      "STATEMENT\020H\022\025\n\021FOREACH_STATEMENT\020I\022\017\n\013FO"
      "R_CONTROL\020J\022\026\n\022FOR_INITIALIZATION\020K\022\021\n\rF"
      "OR_CONDITION\020L\022\021\n\rFOR_INCREMENT\020M\022\024\n\020FOR"
      "_LIKE_CONTROL\020N\022\030\n\024EXPRESSION_STATEMENT\020"
      "O\022\021\n\rFUNCTION_CALL\020Q\022\031\n\025DECLARATION_STAT"
      "EMENT\020R\022\017\n\013DECLARATION\020S\022\036\n\032DECLARATION_"
      "INITIALIZATION\020T\022\025\n\021DECLARATION_RANGE\020U\022"
      "\t\n\005RANGE\020V\022\022\n\016GOTO_STATEMENT\020W\022\026\n\022CONTIN"
      "UE_STATEMENT\020X\022\023\n\017BREAK_STATEMENT\020Y\022\023\n\017L"
      "ABEL_STATEMENT\020Z\022\t\n\005LABEL\020[\022\n\n\006SWITCH\020\\\022"
      "\010\n\004CASE\020]\022\013\n\007DEFAULT\020^\022\027\n\023FUNCTION_DEFIN"
      "ITION\020_\022\030\n\024FUNCTION_DECLARATION\020`\022\n\n\006LAM"
      "BDA\020a\022\023\n\017FUNCTION_LAMBDA\020b\022\026\n\022FUNCTION_S"
      "PECIFIER\020c\022\024\n\020RETURN_STATEMENT\020d\022\022\n\016PARA"
      "METER_LIST\020e\022\r\n\tPARAMETER\020f\022\024\n\020KRPARAMET"
      "ER_LIST\020g\022\017\n\013KRPARAMETER\020h\022\021\n\rARGUMENT_L"
      "IST\020i\022\014\n\010ARGUMENT\020j\022\031\n\025PSEUDO_PARAMETER_"
      "LIST\020k\022\032\n\026INDEXER_PARAMETER_LIST\020l\022\t\n\005CL"
      "ASS\020m\022\025\n\021CLASS_DECLARATION\020n\022\n\n\006STRUCT\020o"
      "\022\026\n\022STRUCT_DECLARATION\020p\022\t\n\005UNION\020q\022\025\n\021U"
      "NION_DECLARATION\020r\022\023\n\017DERIVATION_LIST\020s\022"
      "\021\n\rPUBLIC_ACCESS\020t\022\031\n\025PUBLIC_ACCESS_DEFA"
      "ULT\020u\022\022\n\016PRIVATE_ACCESS\020v\022\032\n\026PRIVATE_ACC"
      "ESS_DEFAULT\020w\022\024\n\020PROTECTED_ACCESS\020x\022\034\n\030P"
      "ROTECTED_ACCESS_DEFAULT\020y\022\024\n\020MEMBER_INIT"
      "_LIST\020z\022\036\n\032MEMBER_INITIALIZATION_LIST\020{\022"
      "\031\n\025MEMBER_INITIALIZATION\020|\022\032\n\026CONSTRUCTO"
      "R_DEFINITION\020}\022\033\n\027CONSTRUCTOR_DECLARATIO"
      "N\020~\022\031\n\025DESTRUCTOR_DEFINITION\020\177\022\033\n\026DESTRU"
      "CTOR_DECLARATION\020\200\001\022\013\n\006FRIEND\020\201\001\022\024\n\017CLAS"
      "S_SPECIFIER\020\202\001\022\016\n\tTRY_BLOCK\020\203\001\022\020\n\013CATCH_"
      "BLOCK\020\204\001\022\022\n\rFINALLY_BLOCK\020\205\001\022\024\n\017THROW_ST"
      "ATEMENT\020\206\001\022\024\n\017THROW_SPECIFIER\020\207\001\022\031\n\024THRO"
      "W_SPECIFIER_JAVA\020\210\001\022\r\n\010TEMPLATE\020\211\001\022\025\n\020GE"
      "NERIC_ARGUMENT\020\212\001\022\032\n\025GENERIC_ARGUMENT_LI"
      "ST\020\213\001\022\027\n\022TEMPLATE_PARAMETER\020\214\001\022\034\n\027TEMPLA"
      "TE_PARAMETER_LIST\020\215\001\022\026\n\021GENERIC_PARAMETE"
      "R\020\216\001\022\033\n\026GENERIC_PARAMETER_LIST\020\217\001\022\014\n\007TYP"
      "EDEF\020\220\001\022\010\n\003ASM\020\221\001\022\017\n\nMACRO_CALL\020\222\001\022\020\n\013SI"
      "ZEOF_CALL\020\223\001\022\013\n\006EXTERN\020\224\001\022\016\n\tNAMESPACE\020\225"
      "\001\022\024\n\017USING_DIRECTIVE\020\226\001\022\016\n\tDIRECTIVE\020\227\001\022"
      "\013\n\006ATOMIC\020\230\001\022\034\n\027STATIC_ASSERT_STATEMENT\020"
      "\231\001\022\026\n\021GENERIC_SELECTION\020\232\001\022\025\n\020GENERIC_SE"
      "LECTOR\020\233\001\022\035\n\030GENERIC_ASSOCIATION_LIST\020\234\001"
      "\022\030\n\023GENERIC_ASSOCIATION\020\235\001\022\014\n\007ALIGNAS\020\236\001"
      "\022\r\n\010DECLTYPE\020\237\001\022\014\n\007CAPTURE\020\240\001\022\023\n\016LAMBDA_"
      "CAPTURE\020\241\001\022\r\n\010NOEXCEPT\020\242\001\022\r\n\010TYPENAME\020\243\001"
      "\022\014\n\007ALIGNOF\020\244\001\022\013\n\006TYPEID\020\245\001\022\020\n\013SIZEOF_PA"
      "CK\020\246\001\022\017\n\nENUM_CLASS\020\247\001\022\033\n\026ENUM_CLASS_DEC"
      "LARATION\020\250\001\022\022\n\rREF_QUALIFIER\020\253\001\022\022\n\rSIGNA"
      "L_ACCESS\020\254\001\022\026\n\021FOREVER_STATEMENT\020\255\001\022\023\n\016E"
      "MIT_STATEMENT\020\256\001\022\022\n\rCPP_DIRECTIVE\020\257\001\022\021\n\014"
      "CPP_FILENAME\020\260\001\022\t\n\004FILE\020\261\001\022\013\n\006NUMBER\020\262\001\022"
      "\017\n\nCPP_NUMBER\020\263\001\022\020\n\013CPP_LITERAL\020\264\001\022\023\n\016CP"
      "P_MACRO_DEFN\020\265\001\022\024\n\017CPP_MACRO_VALUE\020\266\001\022\n\n"
      "\005ERROR\020\267\001\022\016\n\tCPP_ERROR\020\270\001\022\020\n\013CPP_WARNING"
      "\020\271\001\022\017\n\nCPP_PRAGMA\020\272\001\022\020\n\013CPP_INCLUDE\020\273\001\022\017"
      "\n\nCPP_DEFINE\020\274\001\022\016\n\tCPP_UNDEF\020\275\001\022\r\n\010CPP_L"
      "INE\020\276\001\022\013\n\006CPP_IF\020\277\001\022\016\n\tCPP_IFDEF\020\300\001\022\017\n\nC"
      "PP_IFNDEF\020\301\001\022\r\n\010CPP_THEN\020\302\001\022\r\n\010CPP_ELSE\020"
      "\303\001\022\r\n\010CPP_ELIF\020\304\001\022\016\n\tCPP_EMPTY\020\305\001\022\017\n\nCPP"
      "_REGION\020\306\001\022\022\n\rCPP_ENDREGION\020\307\001\022\017\n\nUSING_"
      "STMT\020\310\001\022\013\n\006ESCAPE\020\311\001\022\n\n\005VALUE\020\312\001\022\017\n\nCPP_"
      "IMPORT\020\313\001\022\016\n\tCPP_ENDIF\020\314\001\022\013\n\006MARKER\020\315\001\022\020"
      "\n\013ERROR_PARSE\020\316\001\022\017\n\nERROR_MODE\020\317\001\022\017\n\nIMP"
      "LEMENTS\020\320\001\022\014\n\007EXTENDS\020\321\001\022\013\n\006IMPORT\020\322\001\022\014\n"
      "\007PACKAGE\020\323\001\022\025\n\020ASSERT_STATEMENT\020\324\001\022\016\n\tIN"
      "TERFACE\020\325\001\022\032\n\025INTERFACE_DECLARATION\020\326\001\022\033"
      "\n\026SYNCHRONIZED_STATEMENT\020\327\001\022\017\n\nANNOTATIO"
      "N\020\330\001\022\021\n\014STATIC_BLOCK\020\332\001\022\026\n\021CHECKED_STATE"
      "MENT\020\333\001\022\030\n\023UNCHECKED_STATEMENT\020\334\001\022\016\n\tATT"
      "RIBUTE\020\335\001\022\013\n\006TARGET\020\336\001\022\025\n\020UNSAFE_STATEME"
      "NT\020\337\001\022\023\n\016LOCK_STATEMENT\020\340\001\022\024\n\017FIXED_STAT"
      "EMENT\020\341\001\022\013\n\006TYPEOF\020\342\001\022\024\n\017USING_STATEMENT"
      "\020\343\001\022\026\n\021FUNCTION_DELEGATE\020\344\001\022\017\n\nCONSTRAIN"
      "T\020\346\001\022\t\n\004LINQ\020\347\001\022\t\n\004FROM\020\350\001\022\n\n\005WHERE\020\351\001\022\013"
      "\n\006SELECT\020\352\001\022\010\n\003LET\020\353\001\022\014\n\007ORDERBY\020\354\001\022\t\n\004J"
      "OIN\020\355\001\022\n\n\005GROUP\020\356\001\022\007\n\002IN\020\357\001\022\007\n\002ON\020\360\001\022\013\n\006"
      "EQUALS\020\361\001\022\007\n\002BY\020\362\001\022\t\n\004INTO\020\363\001\022\n\n\005EMPTY\020\364"
      "\001\022\017\n\nEMPTY_STMT\020\365\001\022\r\n\010RECEIVER\020\366\001\022\014\n\007MES"
      "SAGE\020\367\001\022\r\n\010SELECTOR\020\370\001\022\022\n\rPROTOCOL_LIST\020"
      "\371\001\022\r\n\010CATEGORY\020\372\001\022\r\n\010PROTOCOL\020\373\001\022\025\n\020REQU"
      "IRED_DEFAULT\020\374\001\022\r\n\010REQUIRED\020\375\001\022\r\n\010OPTION"
      "AL\020\376\001\022\023\n\016ATTRIBUTE_LIST\020\200\002\022\017\n\nSYNTHESIZE"
      "\020\201\002\022\014\n\007DYNAMIC\020\202\002\022\013\n\006ENCODE\020\203\002\022\024\n\017AUTORE"
      "LEASEPOOL\020\204\002\022\030\n\023COMPATIBILITY_ALIAS\020\205\002\022\010"
      "\n\003NIL\020\206\002\022\024\n\017CLASS_INTERFACE\020\207\002\022\031\n\024CLASS_"
      "IMPLEMENTATION\020\210\002\022\031\n\024PROTOCOL_DECLARATIO"
      "N\020\211\002\022\t\n\004CAST\020\212\002\022\017\n\nCONST_CAST\020\213\002\022\021\n\014DYNA"
      "MIC_CAST\020\214\002\022\025\n\020REINTERPRET_CAST\020\215\002\022\020\n\013ST"
      "ATIC_CAST\020\216\002\022\r\n\010POSITION\020\217\002\022\027\n\022CUDA_ARGU"
      "MENT_LIST\020\220\002\022\022\n\rOMP_DIRECTIVE\020\221\002\022\r\n\010OMP_"
      "NAME\020\222\002\022\017\n\nOMP_CLAUSE\020\223\002\022\026\n\021OMP_ARGUMENT"
      "_LIST\020\224\002\022\021\n\014OMP_ARGUMENT\020\225\002\022\023\n\016OMP_EXPRE"
      "SSION\020\226\002\022\026\n\021END_ELEMENT_TOKEN\020\227\002\022\t\n\004MAIN"
      "\020\230\002\022\n\n\005BREAK\020\231\002\022\r\n\010CONTINUE\020\232\002\022\n\n\005WHILE\020"
      "\233\002\022\007\n\002DO\020\234\002\022\010\n\003FOR\020\235\002\022\007\n\002IF\020\236\002\022\t\n\004GOTO\020\245"
      "\002\022\023\n\016VISUAL_CXX_ASM\020\247\002\022\013\n\006SIZEOF\020\250\002\022\t\n\004A"
      "UTO\020\252\002\022\r\n\010REGISTER\020\253\002\022\r\n\010RESTRICT\020\254\002\022\016\n\t"
      "IMAGINARY\020\260\002\022\r\n\010NORETURN\020\261\002\022\022\n\rSTATIC_AS"
      "SERT\020\262\002\022\016\n\tCRESTRICT\020\263\002\022\014\n\007CXX_TRY\020\264\002\022\016\n"
      "\tCXX_CATCH\020\265\002\022\016\n\tCXX_CLASS\020\266\002\022\016\n\tCONSTEX"
      "PR\020\267\002\022\021\n\014THREAD_LOCAL\020\271\002\022\014\n\007NULLPTR\020\272\002\022\t"
      "\n\004VOID\020\306\002\022\013\n\006RETURN\020\307\002\022\014\n\007INCLUDE\020\310\002\022\013\n\006"
      "DEFINE\020\311\002\022\t\n\004ELIF\020\312\002\022\n\n\005ENDIF\020\313\002\022\016\n\tERRO"
      "RPREC\020\314\002\022\014\n\007WARNING\020\315\002\022\n\n\005IFDEF\020\316\002\022\013\n\006IF"
      "NDEF\020\317\002\022\t\n\004LINE\020\320\002\022\013\n\006PRAGMA\020\321\002\022\n\n\005UNDEF"
      "\020\322\002\022\013\n\006INLINE\020\323\002\022\024\n\017MACRO_TYPE_NAME\020\324\002\022\017"
      "\n\nMACRO_CASE\020\325\002\022\020\n\013MACRO_LABEL\020\326\002\022\016\n\tSPE"
      "CIFIER\020\330\002\022\010\n\003TRY\020\331\002\022\n\n\005CATCH\020\332\002\022\n\n\005THROW"
      "\020\333\002\022\013\n\006THROWS\020\334\002\022\013\n\006PUBLIC\020\336\002\022\014\n\007PRIVATE"
      "\020\337\002\022\016\n\tPROTECTED\020\340\002\022\014\n\007VIRTUAL\020\341\002\022\r\n\010EXP"
      "LICIT\020\344\002\022\014\n\007FOREVER\020\345\002\022\013\n\006SIGNAL\020\346\002\022\t\n\004E"
      "MIT\020\347\002\022\010\n\003NEW\020\353\002\022\013\n\006DELETE\020\354\002\022\013\n\006STATIC\020"
      "\355\002\022\n\n\005CONST\020\356\002\022\014\n\007MUTABLE\020\357\002\022\r\n\010VOLATILE"
      "\020\360\002\022\016\n\tTRANSIENT\020\361\002\022\014\n\007FINALLY\020\364\002\022\n\n\005FIN"
      "AL\020\370\002\022\r\n\010ABSTRACT\020\371\002\022\n\n\005SUPER\020\372\002\022\021\n\014SYNC"
      "HRONIZED\020\373\002\022\013\n\006NATIVE\020\374\002\022\r\n\010STRICTFP\020\375\002\022"
      "\020\n\013NULLLITERAL\020\376\002\022\013\n\006ASSERT\020\377\002\022\014\n\007FOREAC"
      "H\020\200\003\022\010\n\003REF\020\201\003\022\010\n\003OUT\020\202\003\022\t\n\004LOCK\020\204\003\022\007\n\002I"
      "S\020\205\003\022\r\n\010INTERNAL\020\206\003\022\013\n\006SEALED\020\207\003\022\r\n\010OVER"
      "RIDE\020\210\003\022\r\n\010IMPLICIT\020\211\003\022\017\n\nSTACKALLOC\020\212\003\022"
      "\007\n\002AS\020\213\003\022\r\n\010DELEGATE\020\214\003\022\n\n\005FIXED\020\215\003\022\014\n\007C"
      "HECKED\020\216\003\022\016\n\tUNCHECKED\020\217\003\022\013\n\006REGION\020\220\003\022\016"
      "\n\tENDREGION\020\221\003\022\013\n\006UNSAFE\020\222\003\022\r\n\010READONLY\020"
      "\223\003\022\010\n\003GET\020\224\003\022\010\n\003SET\020\225\003\022\010\n\003ADD\020\226\003\022\013\n\006REMO"
      "VE\020\227\003\022\n\n\005YIELD\020\230\003\022\014\n\007PARTIAL\020\231\003\022\n\n\005AWAIT"
      "\020\232\003\022\n\n\005ASYNC\020\234\003\022\t\n\004THIS\020\235\003\022\013\n\006PARAMS\020\236\003\022"
      "\n\n\005ALIAS\020\240\003\022\016\n\tASCENDING\020\246\003\022\017\n\nDESCENDIN"
      "G\020\247\003\022\020\n\013ATINTERFACE\020\256\003\022\025\n\020ATIMPLEMENTATI"
      "ON\020\257\003\022\n\n\005ATEND\020\260\003\022\017\n\nATPROTOCOL\020\261\003\022\017\n\nAT"
      "REQUIRED\020\262\003\022\017\n\nATOPTIONAL\020\263\003\022\014\n\007ATCLASS\020"
      "\271\003\022\t\n\004WEAK\020\273\003\022\013\n\006STRONG\020\274\003\022\014\n\007OMP_OMP\020\300\003"
      "\022\022\n\rSPECIAL_CHARS\020\301\003B\007\n\005extrab\006proto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 7037);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "fast.proto", &protobuf_RegisterTypes);
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_fast_2eproto

const ::google::protobuf::EnumDescriptor* Element_Unit_LanguageType_descriptor() {
  protobuf_fast_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_fast_2eproto::file_level_enum_descriptors[0];
}
bool Element_Unit_LanguageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Element_Unit_LanguageType Element_Unit::ALL;
const Element_Unit_LanguageType Element_Unit::OO;
const Element_Unit_LanguageType Element_Unit::CXX;
const Element_Unit_LanguageType Element_Unit::C;
const Element_Unit_LanguageType Element_Unit::C_FAMILY;
const Element_Unit_LanguageType Element_Unit::JAVA;
const Element_Unit_LanguageType Element_Unit::CSHARP;
const Element_Unit_LanguageType Element_Unit::OBJECTIVE_C;
const Element_Unit_LanguageType Element_Unit::LanguageType_MIN;
const Element_Unit_LanguageType Element_Unit::LanguageType_MAX;
const int Element_Unit::LanguageType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Element_Literal_LiteralType_descriptor() {
  protobuf_fast_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_fast_2eproto::file_level_enum_descriptors[1];
}
bool Element_Literal_LiteralType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Element_Literal_LiteralType Element_Literal::number_type;
const Element_Literal_LiteralType Element_Literal::char_type;
const Element_Literal_LiteralType Element_Literal::string_type;
const Element_Literal_LiteralType Element_Literal::boolean_type;
const Element_Literal_LiteralType Element_Literal::null_type;
const Element_Literal_LiteralType Element_Literal::LiteralType_MIN;
const Element_Literal_LiteralType Element_Literal::LiteralType_MAX;
const int Element_Literal::LiteralType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Element_Kind_descriptor() {
  protobuf_fast_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_fast_2eproto::file_level_enum_descriptors[2];
}
bool Element_Kind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:
    case 160:
    case 161:
    case 162:
    case 163:
    case 164:
    case 165:
    case 166:
    case 167:
    case 168:
    case 171:
    case 172:
    case 173:
    case 174:
    case 175:
    case 176:
    case 177:
    case 178:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 184:
    case 185:
    case 186:
    case 187:
    case 188:
    case 189:
    case 190:
    case 191:
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
    case 197:
    case 198:
    case 199:
    case 200:
    case 201:
    case 202:
    case 203:
    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 209:
    case 210:
    case 211:
    case 212:
    case 213:
    case 214:
    case 215:
    case 216:
    case 218:
    case 219:
    case 220:
    case 221:
    case 222:
    case 223:
    case 224:
    case 225:
    case 226:
    case 227:
    case 228:
    case 230:
    case 231:
    case 232:
    case 233:
    case 234:
    case 235:
    case 236:
    case 237:
    case 238:
    case 239:
    case 240:
    case 241:
    case 242:
    case 243:
    case 244:
    case 245:
    case 246:
    case 247:
    case 248:
    case 249:
    case 250:
    case 251:
    case 252:
    case 253:
    case 254:
    case 256:
    case 257:
    case 258:
    case 259:
    case 260:
    case 261:
    case 262:
    case 263:
    case 264:
    case 265:
    case 266:
    case 267:
    case 268:
    case 269:
    case 270:
    case 271:
    case 272:
    case 273:
    case 274:
    case 275:
    case 276:
    case 277:
    case 278:
    case 279:
    case 280:
    case 281:
    case 282:
    case 283:
    case 284:
    case 285:
    case 286:
    case 293:
    case 295:
    case 296:
    case 298:
    case 299:
    case 300:
    case 304:
    case 305:
    case 306:
    case 307:
    case 308:
    case 309:
    case 310:
    case 311:
    case 313:
    case 314:
    case 326:
    case 327:
    case 328:
    case 329:
    case 330:
    case 331:
    case 332:
    case 333:
    case 334:
    case 335:
    case 336:
    case 337:
    case 338:
    case 339:
    case 340:
    case 341:
    case 342:
    case 344:
    case 345:
    case 346:
    case 347:
    case 348:
    case 350:
    case 351:
    case 352:
    case 353:
    case 356:
    case 357:
    case 358:
    case 359:
    case 363:
    case 364:
    case 365:
    case 366:
    case 367:
    case 368:
    case 369:
    case 372:
    case 376:
    case 377:
    case 378:
    case 379:
    case 380:
    case 381:
    case 382:
    case 383:
    case 384:
    case 385:
    case 386:
    case 388:
    case 389:
    case 390:
    case 391:
    case 392:
    case 393:
    case 394:
    case 395:
    case 396:
    case 397:
    case 398:
    case 399:
    case 400:
    case 401:
    case 402:
    case 403:
    case 404:
    case 405:
    case 406:
    case 407:
    case 408:
    case 409:
    case 410:
    case 412:
    case 413:
    case 414:
    case 416:
    case 422:
    case 423:
    case 430:
    case 431:
    case 432:
    case 433:
    case 434:
    case 435:
    case 441:
    case 443:
    case 444:
    case 448:
    case 449:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Element_Kind Element::UNIT_KIND;
const Element_Kind Element::DECL;
const Element_Kind Element::DECL_STMT;
const Element_Kind Element::INIT;
const Element_Kind Element::EXPR;
const Element_Kind Element::EXPR_STMT;
const Element_Kind Element::COMMENT;
const Element_Kind Element::CALL;
const Element_Kind Element::CONTROL;
const Element_Kind Element::INCR;
const Element_Kind Element::NONE;
const Element_Kind Element::VARIABLE;
const Element_Kind Element::FUNCTION;
const Element_Kind Element::FUNCTION_DECL;
const Element_Kind Element::CONSTRUCTOR;
const Element_Kind Element::CONSTRUCTOR_DECL;
const Element_Kind Element::DESTRUCTOR;
const Element_Kind Element::DESTRUCTOR_DECL;
const Element_Kind Element::MACRO;
const Element_Kind Element::SINGLE_MACRO;
const Element_Kind Element::NULLOPERATOR;
const Element_Kind Element::ENUM_DEFN;
const Element_Kind Element::ENUM_DECL;
const Element_Kind Element::GLOBAL_ATTRIBUTE;
const Element_Kind Element::PROPERTY_ACCESSOR;
const Element_Kind Element::PROPERTY_ACCESSOR_DECL;
const Element_Kind Element::EXPRESSION;
const Element_Kind Element::CLASS_DEFN;
const Element_Kind Element::CLASS_DECL;
const Element_Kind Element::UNION_DEFN;
const Element_Kind Element::UNION_DECL;
const Element_Kind Element::STRUCT_DEFN;
const Element_Kind Element::STRUCT_DECL;
const Element_Kind Element::INTERFACE_DEFN;
const Element_Kind Element::INTERFACE_DECL;
const Element_Kind Element::ACCESS_REGION;
const Element_Kind Element::USING;
const Element_Kind Element::OPERATOR_FUNCTION;
const Element_Kind Element::OPERATOR_FUNCTION_DECL;
const Element_Kind Element::EVENT;
const Element_Kind Element::PROPERTY;
const Element_Kind Element::ANNOTATION_DEFN;
const Element_Kind Element::GLOBAL_TEMPLATE;
const Element_Kind Element::UNIT;
const Element_Kind Element::TART_ELEMENT_TOKEN;
const Element_Kind Element::NOP;
const Element_Kind Element::STRING;
const Element_Kind Element::CHAR;
const Element_Kind Element::LITERAL;
const Element_Kind Element::BOOLEAN;
const Element_Kind Element::NULL_;
const Element_Kind Element::COMPLEX;
const Element_Kind Element::OPERATOR;
const Element_Kind Element::MODIFIER;
const Element_Kind Element::NAME;
const Element_Kind Element::ONAME;
const Element_Kind Element::CNAME;
const Element_Kind Element::TYPE;
const Element_Kind Element::TYPEPREV;
const Element_Kind Element::CONDITION;
const Element_Kind Element::BLOCK;
const Element_Kind Element::PSEUDO_BLOCK;
const Element_Kind Element::INDEX;
const Element_Kind Element::ENUM;
const Element_Kind Element::ENUM_DECLARATION;
const Element_Kind Element::IF_STATEMENT;
const Element_Kind Element::TERNARY;
const Element_Kind Element::THEN;
const Element_Kind Element::ELSE;
const Element_Kind Element::ELSEIF;
const Element_Kind Element::WHILE_STATEMENT;
const Element_Kind Element::DO_STATEMENT;
const Element_Kind Element::FOR_STATEMENT;
const Element_Kind Element::FOREACH_STATEMENT;
const Element_Kind Element::FOR_CONTROL;
const Element_Kind Element::FOR_INITIALIZATION;
const Element_Kind Element::FOR_CONDITION;
const Element_Kind Element::FOR_INCREMENT;
const Element_Kind Element::FOR_LIKE_CONTROL;
const Element_Kind Element::EXPRESSION_STATEMENT;
const Element_Kind Element::FUNCTION_CALL;
const Element_Kind Element::DECLARATION_STATEMENT;
const Element_Kind Element::DECLARATION;
const Element_Kind Element::DECLARATION_INITIALIZATION;
const Element_Kind Element::DECLARATION_RANGE;
const Element_Kind Element::RANGE;
const Element_Kind Element::GOTO_STATEMENT;
const Element_Kind Element::CONTINUE_STATEMENT;
const Element_Kind Element::BREAK_STATEMENT;
const Element_Kind Element::LABEL_STATEMENT;
const Element_Kind Element::LABEL;
const Element_Kind Element::SWITCH;
const Element_Kind Element::CASE;
const Element_Kind Element::DEFAULT;
const Element_Kind Element::FUNCTION_DEFINITION;
const Element_Kind Element::FUNCTION_DECLARATION;
const Element_Kind Element::LAMBDA;
const Element_Kind Element::FUNCTION_LAMBDA;
const Element_Kind Element::FUNCTION_SPECIFIER;
const Element_Kind Element::RETURN_STATEMENT;
const Element_Kind Element::PARAMETER_LIST;
const Element_Kind Element::PARAMETER;
const Element_Kind Element::KRPARAMETER_LIST;
const Element_Kind Element::KRPARAMETER;
const Element_Kind Element::ARGUMENT_LIST;
const Element_Kind Element::ARGUMENT;
const Element_Kind Element::PSEUDO_PARAMETER_LIST;
const Element_Kind Element::INDEXER_PARAMETER_LIST;
const Element_Kind Element::CLASS;
const Element_Kind Element::CLASS_DECLARATION;
const Element_Kind Element::STRUCT;
const Element_Kind Element::STRUCT_DECLARATION;
const Element_Kind Element::UNION;
const Element_Kind Element::UNION_DECLARATION;
const Element_Kind Element::DERIVATION_LIST;
const Element_Kind Element::PUBLIC_ACCESS;
const Element_Kind Element::PUBLIC_ACCESS_DEFAULT;
const Element_Kind Element::PRIVATE_ACCESS;
const Element_Kind Element::PRIVATE_ACCESS_DEFAULT;
const Element_Kind Element::PROTECTED_ACCESS;
const Element_Kind Element::PROTECTED_ACCESS_DEFAULT;
const Element_Kind Element::MEMBER_INIT_LIST;
const Element_Kind Element::MEMBER_INITIALIZATION_LIST;
const Element_Kind Element::MEMBER_INITIALIZATION;
const Element_Kind Element::CONSTRUCTOR_DEFINITION;
const Element_Kind Element::CONSTRUCTOR_DECLARATION;
const Element_Kind Element::DESTRUCTOR_DEFINITION;
const Element_Kind Element::DESTRUCTOR_DECLARATION;
const Element_Kind Element::FRIEND;
const Element_Kind Element::CLASS_SPECIFIER;
const Element_Kind Element::TRY_BLOCK;
const Element_Kind Element::CATCH_BLOCK;
const Element_Kind Element::FINALLY_BLOCK;
const Element_Kind Element::THROW_STATEMENT;
const Element_Kind Element::THROW_SPECIFIER;
const Element_Kind Element::THROW_SPECIFIER_JAVA;
const Element_Kind Element::TEMPLATE;
const Element_Kind Element::GENERIC_ARGUMENT;
const Element_Kind Element::GENERIC_ARGUMENT_LIST;
const Element_Kind Element::TEMPLATE_PARAMETER;
const Element_Kind Element::TEMPLATE_PARAMETER_LIST;
const Element_Kind Element::GENERIC_PARAMETER;
const Element_Kind Element::GENERIC_PARAMETER_LIST;
const Element_Kind Element::TYPEDEF;
const Element_Kind Element::ASM;
const Element_Kind Element::MACRO_CALL;
const Element_Kind Element::SIZEOF_CALL;
const Element_Kind Element::EXTERN;
const Element_Kind Element::NAMESPACE;
const Element_Kind Element::USING_DIRECTIVE;
const Element_Kind Element::DIRECTIVE;
const Element_Kind Element::ATOMIC;
const Element_Kind Element::STATIC_ASSERT_STATEMENT;
const Element_Kind Element::GENERIC_SELECTION;
const Element_Kind Element::GENERIC_SELECTOR;
const Element_Kind Element::GENERIC_ASSOCIATION_LIST;
const Element_Kind Element::GENERIC_ASSOCIATION;
const Element_Kind Element::ALIGNAS;
const Element_Kind Element::DECLTYPE;
const Element_Kind Element::CAPTURE;
const Element_Kind Element::LAMBDA_CAPTURE;
const Element_Kind Element::NOEXCEPT;
const Element_Kind Element::TYPENAME;
const Element_Kind Element::ALIGNOF;
const Element_Kind Element::TYPEID;
const Element_Kind Element::SIZEOF_PACK;
const Element_Kind Element::ENUM_CLASS;
const Element_Kind Element::ENUM_CLASS_DECLARATION;
const Element_Kind Element::REF_QUALIFIER;
const Element_Kind Element::SIGNAL_ACCESS;
const Element_Kind Element::FOREVER_STATEMENT;
const Element_Kind Element::EMIT_STATEMENT;
const Element_Kind Element::CPP_DIRECTIVE;
const Element_Kind Element::CPP_FILENAME;
const Element_Kind Element::FILE;
const Element_Kind Element::NUMBER;
const Element_Kind Element::CPP_NUMBER;
const Element_Kind Element::CPP_LITERAL;
const Element_Kind Element::CPP_MACRO_DEFN;
const Element_Kind Element::CPP_MACRO_VALUE;
const Element_Kind Element::ERROR;
const Element_Kind Element::CPP_ERROR;
const Element_Kind Element::CPP_WARNING;
const Element_Kind Element::CPP_PRAGMA;
const Element_Kind Element::CPP_INCLUDE;
const Element_Kind Element::CPP_DEFINE;
const Element_Kind Element::CPP_UNDEF;
const Element_Kind Element::CPP_LINE;
const Element_Kind Element::CPP_IF;
const Element_Kind Element::CPP_IFDEF;
const Element_Kind Element::CPP_IFNDEF;
const Element_Kind Element::CPP_THEN;
const Element_Kind Element::CPP_ELSE;
const Element_Kind Element::CPP_ELIF;
const Element_Kind Element::CPP_EMPTY;
const Element_Kind Element::CPP_REGION;
const Element_Kind Element::CPP_ENDREGION;
const Element_Kind Element::USING_STMT;
const Element_Kind Element::ESCAPE;
const Element_Kind Element::VALUE;
const Element_Kind Element::CPP_IMPORT;
const Element_Kind Element::CPP_ENDIF;
const Element_Kind Element::MARKER;
const Element_Kind Element::ERROR_PARSE;
const Element_Kind Element::ERROR_MODE;
const Element_Kind Element::IMPLEMENTS;
const Element_Kind Element::EXTENDS;
const Element_Kind Element::IMPORT;
const Element_Kind Element::PACKAGE;
const Element_Kind Element::ASSERT_STATEMENT;
const Element_Kind Element::INTERFACE;
const Element_Kind Element::INTERFACE_DECLARATION;
const Element_Kind Element::SYNCHRONIZED_STATEMENT;
const Element_Kind Element::ANNOTATION;
const Element_Kind Element::STATIC_BLOCK;
const Element_Kind Element::CHECKED_STATEMENT;
const Element_Kind Element::UNCHECKED_STATEMENT;
const Element_Kind Element::ATTRIBUTE;
const Element_Kind Element::TARGET;
const Element_Kind Element::UNSAFE_STATEMENT;
const Element_Kind Element::LOCK_STATEMENT;
const Element_Kind Element::FIXED_STATEMENT;
const Element_Kind Element::TYPEOF;
const Element_Kind Element::USING_STATEMENT;
const Element_Kind Element::FUNCTION_DELEGATE;
const Element_Kind Element::CONSTRAINT;
const Element_Kind Element::LINQ;
const Element_Kind Element::FROM;
const Element_Kind Element::WHERE;
const Element_Kind Element::SELECT;
const Element_Kind Element::LET;
const Element_Kind Element::ORDERBY;
const Element_Kind Element::JOIN;
const Element_Kind Element::GROUP;
const Element_Kind Element::IN;
const Element_Kind Element::ON;
const Element_Kind Element::EQUALS;
const Element_Kind Element::BY;
const Element_Kind Element::INTO;
const Element_Kind Element::EMPTY;
const Element_Kind Element::EMPTY_STMT;
const Element_Kind Element::RECEIVER;
const Element_Kind Element::MESSAGE;
const Element_Kind Element::SELECTOR;
const Element_Kind Element::PROTOCOL_LIST;
const Element_Kind Element::CATEGORY;
const Element_Kind Element::PROTOCOL;
const Element_Kind Element::REQUIRED_DEFAULT;
const Element_Kind Element::REQUIRED;
const Element_Kind Element::OPTIONAL;
const Element_Kind Element::ATTRIBUTE_LIST;
const Element_Kind Element::SYNTHESIZE;
const Element_Kind Element::DYNAMIC;
const Element_Kind Element::ENCODE;
const Element_Kind Element::AUTORELEASEPOOL;
const Element_Kind Element::COMPATIBILITY_ALIAS;
const Element_Kind Element::NIL;
const Element_Kind Element::CLASS_INTERFACE;
const Element_Kind Element::CLASS_IMPLEMENTATION;
const Element_Kind Element::PROTOCOL_DECLARATION;
const Element_Kind Element::CAST;
const Element_Kind Element::CONST_CAST;
const Element_Kind Element::DYNAMIC_CAST;
const Element_Kind Element::REINTERPRET_CAST;
const Element_Kind Element::STATIC_CAST;
const Element_Kind Element::POSITION;
const Element_Kind Element::CUDA_ARGUMENT_LIST;
const Element_Kind Element::OMP_DIRECTIVE;
const Element_Kind Element::OMP_NAME;
const Element_Kind Element::OMP_CLAUSE;
const Element_Kind Element::OMP_ARGUMENT_LIST;
const Element_Kind Element::OMP_ARGUMENT;
const Element_Kind Element::OMP_EXPRESSION;
const Element_Kind Element::END_ELEMENT_TOKEN;
const Element_Kind Element::MAIN;
const Element_Kind Element::BREAK;
const Element_Kind Element::CONTINUE;
const Element_Kind Element::WHILE;
const Element_Kind Element::DO;
const Element_Kind Element::FOR;
const Element_Kind Element::IF;
const Element_Kind Element::GOTO;
const Element_Kind Element::VISUAL_CXX_ASM;
const Element_Kind Element::SIZEOF;
const Element_Kind Element::AUTO;
const Element_Kind Element::REGISTER;
const Element_Kind Element::RESTRICT;
const Element_Kind Element::IMAGINARY;
const Element_Kind Element::NORETURN;
const Element_Kind Element::STATIC_ASSERT;
const Element_Kind Element::CRESTRICT;
const Element_Kind Element::CXX_TRY;
const Element_Kind Element::CXX_CATCH;
const Element_Kind Element::CXX_CLASS;
const Element_Kind Element::CONSTEXPR;
const Element_Kind Element::THREAD_LOCAL;
const Element_Kind Element::NULLPTR;
const Element_Kind Element::VOID;
const Element_Kind Element::RETURN;
const Element_Kind Element::INCLUDE;
const Element_Kind Element::DEFINE;
const Element_Kind Element::ELIF;
const Element_Kind Element::ENDIF;
const Element_Kind Element::ERRORPREC;
const Element_Kind Element::WARNING;
const Element_Kind Element::IFDEF;
const Element_Kind Element::IFNDEF;
const Element_Kind Element::LINE;
const Element_Kind Element::PRAGMA;
const Element_Kind Element::UNDEF;
const Element_Kind Element::INLINE;
const Element_Kind Element::MACRO_TYPE_NAME;
const Element_Kind Element::MACRO_CASE;
const Element_Kind Element::MACRO_LABEL;
const Element_Kind Element::SPECIFIER;
const Element_Kind Element::TRY;
const Element_Kind Element::CATCH;
const Element_Kind Element::THROW;
const Element_Kind Element::THROWS;
const Element_Kind Element::PUBLIC;
const Element_Kind Element::PRIVATE;
const Element_Kind Element::PROTECTED;
const Element_Kind Element::VIRTUAL;
const Element_Kind Element::EXPLICIT;
const Element_Kind Element::FOREVER;
const Element_Kind Element::SIGNAL;
const Element_Kind Element::EMIT;
const Element_Kind Element::NEW;
const Element_Kind Element::DELETE;
const Element_Kind Element::STATIC;
const Element_Kind Element::CONST;
const Element_Kind Element::MUTABLE;
const Element_Kind Element::VOLATILE;
const Element_Kind Element::TRANSIENT;
const Element_Kind Element::FINALLY;
const Element_Kind Element::FINAL;
const Element_Kind Element::ABSTRACT;
const Element_Kind Element::SUPER;
const Element_Kind Element::SYNCHRONIZED;
const Element_Kind Element::NATIVE;
const Element_Kind Element::STRICTFP;
const Element_Kind Element::NULLLITERAL;
const Element_Kind Element::ASSERT;
const Element_Kind Element::FOREACH;
const Element_Kind Element::REF;
const Element_Kind Element::OUT;
const Element_Kind Element::LOCK;
const Element_Kind Element::IS;
const Element_Kind Element::INTERNAL;
const Element_Kind Element::SEALED;
const Element_Kind Element::OVERRIDE;
const Element_Kind Element::IMPLICIT;
const Element_Kind Element::STACKALLOC;
const Element_Kind Element::AS;
const Element_Kind Element::DELEGATE;
const Element_Kind Element::FIXED;
const Element_Kind Element::CHECKED;
const Element_Kind Element::UNCHECKED;
const Element_Kind Element::REGION;
const Element_Kind Element::ENDREGION;
const Element_Kind Element::UNSAFE;
const Element_Kind Element::READONLY;
const Element_Kind Element::GET;
const Element_Kind Element::SET;
const Element_Kind Element::ADD;
const Element_Kind Element::REMOVE;
const Element_Kind Element::YIELD;
const Element_Kind Element::PARTIAL;
const Element_Kind Element::AWAIT;
const Element_Kind Element::ASYNC;
const Element_Kind Element::THIS;
const Element_Kind Element::PARAMS;
const Element_Kind Element::ALIAS;
const Element_Kind Element::ASCENDING;
const Element_Kind Element::DESCENDING;
const Element_Kind Element::ATINTERFACE;
const Element_Kind Element::ATIMPLEMENTATION;
const Element_Kind Element::ATEND;
const Element_Kind Element::ATPROTOCOL;
const Element_Kind Element::ATREQUIRED;
const Element_Kind Element::ATOPTIONAL;
const Element_Kind Element::ATCLASS;
const Element_Kind Element::WEAK;
const Element_Kind Element::STRONG;
const Element_Kind Element::OMP_OMP;
const Element_Kind Element::SPECIAL_CHARS;
const Element_Kind Element::Kind_MIN;
const Element_Kind Element::Kind_MAX;
const int Element::Kind_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Element_Unit::kFilenameFieldNumber;
const int Element_Unit::kRevisionFieldNumber;
const int Element_Unit::kLanguageFieldNumber;
const int Element_Unit::kItemFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Element_Unit::Element_Unit()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_fast_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:fast.Element.Unit)
}
Element_Unit::Element_Unit(const Element_Unit& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  filename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.filename().size() > 0) {
    filename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.filename_);
  }
  revision_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.revision().size() > 0) {
    revision_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.revision_);
  }
  ::memcpy(&language_, &from.language_,
    reinterpret_cast<char*>(&item_) -
    reinterpret_cast<char*>(&language_) + sizeof(item_));
  // @@protoc_insertion_point(copy_constructor:fast.Element.Unit)
}

void Element_Unit::SharedCtor() {
  filename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  revision_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&language_, 0, reinterpret_cast<char*>(&item_) -
    reinterpret_cast<char*>(&language_) + sizeof(item_));
  _cached_size_ = 0;
}

Element_Unit::~Element_Unit() {
  // @@protoc_insertion_point(destructor:fast.Element.Unit)
  SharedDtor();
}

void Element_Unit::SharedDtor() {
  filename_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  revision_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Element_Unit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Element_Unit::descriptor() {
  protobuf_fast_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_fast_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Element_Unit& Element_Unit::default_instance() {
  protobuf_fast_2eproto::InitDefaults();
  return *internal_default_instance();
}

Element_Unit* Element_Unit::New(::google::protobuf::Arena* arena) const {
  Element_Unit* n = new Element_Unit;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Element_Unit::Clear() {
// @@protoc_insertion_point(message_clear_start:fast.Element.Unit)
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&language_, 0, reinterpret_cast<char*>(&item_) -
    reinterpret_cast<char*>(&language_) + sizeof(item_));
}

bool Element_Unit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:fast.Element.Unit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string filename = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filename()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->filename().data(), this->filename().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "fast.Element.Unit.filename"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string revision = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_revision()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->revision().data(), this->revision().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "fast.Element.Unit.revision"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .fast.Element.Unit.LanguageType language = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_language(static_cast< ::fast::Element_Unit_LanguageType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 item = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &item_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fast.Element.Unit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fast.Element.Unit)
  return false;
#undef DO_
}

void Element_Unit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fast.Element.Unit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string filename = 1;
  if (this->filename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->filename().data(), this->filename().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "fast.Element.Unit.filename");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->filename(), output);
  }

  // string revision = 2;
  if (this->revision().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->revision().data(), this->revision().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "fast.Element.Unit.revision");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->revision(), output);
  }

  // .fast.Element.Unit.LanguageType language = 3;
  if (this->language() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->language(), output);
  }

  // int32 item = 4;
  if (this->item() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->item(), output);
  }

  // @@protoc_insertion_point(serialize_end:fast.Element.Unit)
}

::google::protobuf::uint8* Element_Unit::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:fast.Element.Unit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string filename = 1;
  if (this->filename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->filename().data(), this->filename().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "fast.Element.Unit.filename");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->filename(), target);
  }

  // string revision = 2;
  if (this->revision().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->revision().data(), this->revision().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "fast.Element.Unit.revision");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->revision(), target);
  }

  // .fast.Element.Unit.LanguageType language = 3;
  if (this->language() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->language(), target);
  }

  // int32 item = 4;
  if (this->item() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->item(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:fast.Element.Unit)
  return target;
}

size_t Element_Unit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fast.Element.Unit)
  size_t total_size = 0;

  // string filename = 1;
  if (this->filename().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->filename());
  }

  // string revision = 2;
  if (this->revision().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->revision());
  }

  // .fast.Element.Unit.LanguageType language = 3;
  if (this->language() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->language());
  }

  // int32 item = 4;
  if (this->item() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->item());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Element_Unit::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:fast.Element.Unit)
  GOOGLE_DCHECK_NE(&from, this);
  const Element_Unit* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Element_Unit>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:fast.Element.Unit)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:fast.Element.Unit)
    MergeFrom(*source);
  }
}

void Element_Unit::MergeFrom(const Element_Unit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:fast.Element.Unit)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.filename().size() > 0) {

    filename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.filename_);
  }
  if (from.revision().size() > 0) {

    revision_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.revision_);
  }
  if (from.language() != 0) {
    set_language(from.language());
  }
  if (from.item() != 0) {
    set_item(from.item());
  }
}

void Element_Unit::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:fast.Element.Unit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Element_Unit::CopyFrom(const Element_Unit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fast.Element.Unit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Element_Unit::IsInitialized() const {
  return true;
}

void Element_Unit::Swap(Element_Unit* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Element_Unit::InternalSwap(Element_Unit* other) {
  filename_.Swap(&other->filename_);
  revision_.Swap(&other->revision_);
  std::swap(language_, other->language_);
  std::swap(item_, other->item_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Element_Unit::GetMetadata() const {
  protobuf_fast_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_fast_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Element_Unit

// string filename = 1;
void Element_Unit::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Element_Unit::filename() const {
  // @@protoc_insertion_point(field_get:fast.Element.Unit.filename)
  return filename_.GetNoArena();
}
void Element_Unit::set_filename(const ::std::string& value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Element.Unit.filename)
}
#if LANG_CXX11
void Element_Unit::set_filename(::std::string&& value) {
  
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Element.Unit.filename)
}
#endif
void Element_Unit::set_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Element.Unit.filename)
}
void Element_Unit::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Element.Unit.filename)
}
::std::string* Element_Unit::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:fast.Element.Unit.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Element_Unit::release_filename() {
  // @@protoc_insertion_point(field_release:fast.Element.Unit.filename)
  
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Element_Unit::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:fast.Element.Unit.filename)
}

// string revision = 2;
void Element_Unit::clear_revision() {
  revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Element_Unit::revision() const {
  // @@protoc_insertion_point(field_get:fast.Element.Unit.revision)
  return revision_.GetNoArena();
}
void Element_Unit::set_revision(const ::std::string& value) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Element.Unit.revision)
}
#if LANG_CXX11
void Element_Unit::set_revision(::std::string&& value) {
  
  revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Element.Unit.revision)
}
#endif
void Element_Unit::set_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Element.Unit.revision)
}
void Element_Unit::set_revision(const char* value, size_t size) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Element.Unit.revision)
}
::std::string* Element_Unit::mutable_revision() {
  
  // @@protoc_insertion_point(field_mutable:fast.Element.Unit.revision)
  return revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Element_Unit::release_revision() {
  // @@protoc_insertion_point(field_release:fast.Element.Unit.revision)
  
  return revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Element_Unit::set_allocated_revision(::std::string* revision) {
  if (revision != NULL) {
    
  } else {
    
  }
  revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), revision);
  // @@protoc_insertion_point(field_set_allocated:fast.Element.Unit.revision)
}

// .fast.Element.Unit.LanguageType language = 3;
void Element_Unit::clear_language() {
  language_ = 0;
}
::fast::Element_Unit_LanguageType Element_Unit::language() const {
  // @@protoc_insertion_point(field_get:fast.Element.Unit.language)
  return static_cast< ::fast::Element_Unit_LanguageType >(language_);
}
void Element_Unit::set_language(::fast::Element_Unit_LanguageType value) {
  
  language_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.Unit.language)
}

// int32 item = 4;
void Element_Unit::clear_item() {
  item_ = 0;
}
::google::protobuf::int32 Element_Unit::item() const {
  // @@protoc_insertion_point(field_get:fast.Element.Unit.item)
  return item_;
}
void Element_Unit::set_item(::google::protobuf::int32 value) {
  
  item_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.Unit.item)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Element_Literal::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Element_Literal::Element_Literal()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_fast_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:fast.Element.Literal)
}
Element_Literal::Element_Literal(const Element_Literal& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:fast.Element.Literal)
}

void Element_Literal::SharedCtor() {
  type_ = 0;
  _cached_size_ = 0;
}

Element_Literal::~Element_Literal() {
  // @@protoc_insertion_point(destructor:fast.Element.Literal)
  SharedDtor();
}

void Element_Literal::SharedDtor() {
}

void Element_Literal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Element_Literal::descriptor() {
  protobuf_fast_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_fast_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Element_Literal& Element_Literal::default_instance() {
  protobuf_fast_2eproto::InitDefaults();
  return *internal_default_instance();
}

Element_Literal* Element_Literal::New(::google::protobuf::Arena* arena) const {
  Element_Literal* n = new Element_Literal;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Element_Literal::Clear() {
// @@protoc_insertion_point(message_clear_start:fast.Element.Literal)
  type_ = 0;
}

bool Element_Literal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:fast.Element.Literal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .fast.Element.Literal.LiteralType type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::fast::Element_Literal_LiteralType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fast.Element.Literal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fast.Element.Literal)
  return false;
#undef DO_
}

void Element_Literal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fast.Element.Literal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .fast.Element.Literal.LiteralType type = 1;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // @@protoc_insertion_point(serialize_end:fast.Element.Literal)
}

::google::protobuf::uint8* Element_Literal::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:fast.Element.Literal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .fast.Element.Literal.LiteralType type = 1;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:fast.Element.Literal)
  return target;
}

size_t Element_Literal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fast.Element.Literal)
  size_t total_size = 0;

  // .fast.Element.Literal.LiteralType type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Element_Literal::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:fast.Element.Literal)
  GOOGLE_DCHECK_NE(&from, this);
  const Element_Literal* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Element_Literal>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:fast.Element.Literal)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:fast.Element.Literal)
    MergeFrom(*source);
  }
}

void Element_Literal::MergeFrom(const Element_Literal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:fast.Element.Literal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.type() != 0) {
    set_type(from.type());
  }
}

void Element_Literal::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:fast.Element.Literal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Element_Literal::CopyFrom(const Element_Literal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fast.Element.Literal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Element_Literal::IsInitialized() const {
  return true;
}

void Element_Literal::Swap(Element_Literal* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Element_Literal::InternalSwap(Element_Literal* other) {
  std::swap(type_, other->type_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Element_Literal::GetMetadata() const {
  protobuf_fast_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_fast_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Element_Literal

// .fast.Element.Literal.LiteralType type = 1;
void Element_Literal::clear_type() {
  type_ = 0;
}
::fast::Element_Literal_LiteralType Element_Literal::type() const {
  // @@protoc_insertion_point(field_get:fast.Element.Literal.type)
  return static_cast< ::fast::Element_Literal_LiteralType >(type_);
}
void Element_Literal::set_type(::fast::Element_Literal_LiteralType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.Literal.type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Element::kKindFieldNumber;
const int Element::kTextFieldNumber;
const int Element::kTailFieldNumber;
const int Element::kChildFieldNumber;
const int Element::kUnitFieldNumber;
const int Element::kLiteralFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Element::Element()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_fast_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:fast.Element)
}
Element::Element(const Element& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      child_(from.child_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.text().size() > 0) {
    text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
  }
  tail_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.tail().size() > 0) {
    tail_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.tail_);
  }
  kind_ = from.kind_;
  clear_has_extra();
  switch (from.extra_case()) {
    case kUnit: {
      mutable_unit()->::fast::Element_Unit::MergeFrom(from.unit());
      break;
    }
    case kLiteral: {
      mutable_literal()->::fast::Element_Literal::MergeFrom(from.literal());
      break;
    }
    case EXTRA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:fast.Element)
}

void Element::SharedCtor() {
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  tail_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  kind_ = 0;
  clear_has_extra();
  _cached_size_ = 0;
}

Element::~Element() {
  // @@protoc_insertion_point(destructor:fast.Element)
  SharedDtor();
}

void Element::SharedDtor() {
  text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  tail_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (has_extra()) {
    clear_extra();
  }
}

void Element::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Element::descriptor() {
  protobuf_fast_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_fast_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Element& Element::default_instance() {
  protobuf_fast_2eproto::InitDefaults();
  return *internal_default_instance();
}

Element* Element::New(::google::protobuf::Arena* arena) const {
  Element* n = new Element;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Element::clear_extra() {
// @@protoc_insertion_point(one_of_clear_start:fast.Element)
  switch (extra_case()) {
    case kUnit: {
      delete extra_.unit_;
      break;
    }
    case kLiteral: {
      delete extra_.literal_;
      break;
    }
    case EXTRA_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = EXTRA_NOT_SET;
}


void Element::Clear() {
// @@protoc_insertion_point(message_clear_start:fast.Element)
  child_.Clear();
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  tail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  kind_ = 0;
  clear_extra();
}

bool Element::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:fast.Element)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .fast.Element.Kind kind = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_kind(static_cast< ::fast::Element_Kind >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string text = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "fast.Element.text"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string tail = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_tail()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->tail().data(), this->tail().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "fast.Element.tail"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .fast.Element child = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_child()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .fast.Element.Unit unit = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .fast.Element.Literal literal = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_literal()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:fast.Element)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:fast.Element)
  return false;
#undef DO_
}

void Element::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:fast.Element)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .fast.Element.Kind kind = 1;
  if (this->kind() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->kind(), output);
  }

  // string text = 2;
  if (this->text().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "fast.Element.text");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->text(), output);
  }

  // string tail = 3;
  if (this->tail().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->tail().data(), this->tail().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "fast.Element.tail");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->tail(), output);
  }

  // repeated .fast.Element child = 4;
  for (unsigned int i = 0, n = this->child_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->child(i), output);
  }

  // .fast.Element.Unit unit = 5;
  if (has_unit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *extra_.unit_, output);
  }

  // .fast.Element.Literal literal = 6;
  if (has_literal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *extra_.literal_, output);
  }

  // @@protoc_insertion_point(serialize_end:fast.Element)
}

::google::protobuf::uint8* Element::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:fast.Element)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .fast.Element.Kind kind = 1;
  if (this->kind() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->kind(), target);
  }

  // string text = 2;
  if (this->text().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "fast.Element.text");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->text(), target);
  }

  // string tail = 3;
  if (this->tail().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->tail().data(), this->tail().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "fast.Element.tail");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->tail(), target);
  }

  // repeated .fast.Element child = 4;
  for (unsigned int i = 0, n = this->child_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, this->child(i), deterministic, target);
  }

  // .fast.Element.Unit unit = 5;
  if (has_unit()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *extra_.unit_, deterministic, target);
  }

  // .fast.Element.Literal literal = 6;
  if (has_literal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *extra_.literal_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:fast.Element)
  return target;
}

size_t Element::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fast.Element)
  size_t total_size = 0;

  // repeated .fast.Element child = 4;
  {
    unsigned int count = this->child_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->child(i));
    }
  }

  // string text = 2;
  if (this->text().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->text());
  }

  // string tail = 3;
  if (this->tail().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->tail());
  }

  // .fast.Element.Kind kind = 1;
  if (this->kind() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->kind());
  }

  switch (extra_case()) {
    // .fast.Element.Unit unit = 5;
    case kUnit: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *extra_.unit_);
      break;
    }
    // .fast.Element.Literal literal = 6;
    case kLiteral: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *extra_.literal_);
      break;
    }
    case EXTRA_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Element::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:fast.Element)
  GOOGLE_DCHECK_NE(&from, this);
  const Element* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Element>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:fast.Element)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:fast.Element)
    MergeFrom(*source);
  }
}

void Element::MergeFrom(const Element& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:fast.Element)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  child_.MergeFrom(from.child_);
  if (from.text().size() > 0) {

    text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
  }
  if (from.tail().size() > 0) {

    tail_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.tail_);
  }
  if (from.kind() != 0) {
    set_kind(from.kind());
  }
  switch (from.extra_case()) {
    case kUnit: {
      mutable_unit()->::fast::Element_Unit::MergeFrom(from.unit());
      break;
    }
    case kLiteral: {
      mutable_literal()->::fast::Element_Literal::MergeFrom(from.literal());
      break;
    }
    case EXTRA_NOT_SET: {
      break;
    }
  }
}

void Element::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:fast.Element)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Element::CopyFrom(const Element& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fast.Element)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Element::IsInitialized() const {
  return true;
}

void Element::Swap(Element* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Element::InternalSwap(Element* other) {
  child_.InternalSwap(&other->child_);
  text_.Swap(&other->text_);
  tail_.Swap(&other->tail_);
  std::swap(kind_, other->kind_);
  std::swap(extra_, other->extra_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Element::GetMetadata() const {
  protobuf_fast_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_fast_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Element

// .fast.Element.Kind kind = 1;
void Element::clear_kind() {
  kind_ = 0;
}
::fast::Element_Kind Element::kind() const {
  // @@protoc_insertion_point(field_get:fast.Element.kind)
  return static_cast< ::fast::Element_Kind >(kind_);
}
void Element::set_kind(::fast::Element_Kind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:fast.Element.kind)
}

// string text = 2;
void Element::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Element::text() const {
  // @@protoc_insertion_point(field_get:fast.Element.text)
  return text_.GetNoArena();
}
void Element::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Element.text)
}
#if LANG_CXX11
void Element::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Element.text)
}
#endif
void Element::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Element.text)
}
void Element::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Element.text)
}
::std::string* Element::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:fast.Element.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Element::release_text() {
  // @@protoc_insertion_point(field_release:fast.Element.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Element::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:fast.Element.text)
}

// string tail = 3;
void Element::clear_tail() {
  tail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Element::tail() const {
  // @@protoc_insertion_point(field_get:fast.Element.tail)
  return tail_.GetNoArena();
}
void Element::set_tail(const ::std::string& value) {
  
  tail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fast.Element.tail)
}
#if LANG_CXX11
void Element::set_tail(::std::string&& value) {
  
  tail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fast.Element.tail)
}
#endif
void Element::set_tail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fast.Element.tail)
}
void Element::set_tail(const char* value, size_t size) {
  
  tail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fast.Element.tail)
}
::std::string* Element::mutable_tail() {
  
  // @@protoc_insertion_point(field_mutable:fast.Element.tail)
  return tail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Element::release_tail() {
  // @@protoc_insertion_point(field_release:fast.Element.tail)
  
  return tail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Element::set_allocated_tail(::std::string* tail) {
  if (tail != NULL) {
    
  } else {
    
  }
  tail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tail);
  // @@protoc_insertion_point(field_set_allocated:fast.Element.tail)
}

// repeated .fast.Element child = 4;
int Element::child_size() const {
  return child_.size();
}
void Element::clear_child() {
  child_.Clear();
}
const ::fast::Element& Element::child(int index) const {
  // @@protoc_insertion_point(field_get:fast.Element.child)
  return child_.Get(index);
}
::fast::Element* Element::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:fast.Element.child)
  return child_.Mutable(index);
}
::fast::Element* Element::add_child() {
  // @@protoc_insertion_point(field_add:fast.Element.child)
  return child_.Add();
}
::google::protobuf::RepeatedPtrField< ::fast::Element >*
Element::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:fast.Element.child)
  return &child_;
}
const ::google::protobuf::RepeatedPtrField< ::fast::Element >&
Element::child() const {
  // @@protoc_insertion_point(field_list:fast.Element.child)
  return child_;
}

// .fast.Element.Unit unit = 5;
bool Element::has_unit() const {
  return extra_case() == kUnit;
}
void Element::set_has_unit() {
  _oneof_case_[0] = kUnit;
}
void Element::clear_unit() {
  if (has_unit()) {
    delete extra_.unit_;
    clear_has_extra();
  }
}
 const ::fast::Element_Unit& Element::unit() const {
  // @@protoc_insertion_point(field_get:fast.Element.unit)
  return has_unit()
      ? *extra_.unit_
      : ::fast::Element_Unit::default_instance();
}
::fast::Element_Unit* Element::mutable_unit() {
  if (!has_unit()) {
    clear_extra();
    set_has_unit();
    extra_.unit_ = new ::fast::Element_Unit;
  }
  // @@protoc_insertion_point(field_mutable:fast.Element.unit)
  return extra_.unit_;
}
::fast::Element_Unit* Element::release_unit() {
  // @@protoc_insertion_point(field_release:fast.Element.unit)
  if (has_unit()) {
    clear_has_extra();
    ::fast::Element_Unit* temp = extra_.unit_;
    extra_.unit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Element::set_allocated_unit(::fast::Element_Unit* unit) {
  clear_extra();
  if (unit) {
    set_has_unit();
    extra_.unit_ = unit;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Element.unit)
}

// .fast.Element.Literal literal = 6;
bool Element::has_literal() const {
  return extra_case() == kLiteral;
}
void Element::set_has_literal() {
  _oneof_case_[0] = kLiteral;
}
void Element::clear_literal() {
  if (has_literal()) {
    delete extra_.literal_;
    clear_has_extra();
  }
}
 const ::fast::Element_Literal& Element::literal() const {
  // @@protoc_insertion_point(field_get:fast.Element.literal)
  return has_literal()
      ? *extra_.literal_
      : ::fast::Element_Literal::default_instance();
}
::fast::Element_Literal* Element::mutable_literal() {
  if (!has_literal()) {
    clear_extra();
    set_has_literal();
    extra_.literal_ = new ::fast::Element_Literal;
  }
  // @@protoc_insertion_point(field_mutable:fast.Element.literal)
  return extra_.literal_;
}
::fast::Element_Literal* Element::release_literal() {
  // @@protoc_insertion_point(field_release:fast.Element.literal)
  if (has_literal()) {
    clear_has_extra();
    ::fast::Element_Literal* temp = extra_.literal_;
    extra_.literal_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Element::set_allocated_literal(::fast::Element_Literal* literal) {
  clear_extra();
  if (literal) {
    set_has_literal();
    extra_.literal_ = literal;
  }
  // @@protoc_insertion_point(field_set_allocated:fast.Element.literal)
}

bool Element::has_extra() const {
  return extra_case() != EXTRA_NOT_SET;
}
void Element::clear_has_extra() {
  _oneof_case_[0] = EXTRA_NOT_SET;
}
Element::ExtraCase Element::extra_case() const {
  return Element::ExtraCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace fast

// @@protoc_insertion_point(global_scope)
