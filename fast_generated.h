// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FAST__FAST__ELEMENT_H_
#define FLATBUFFERS_GENERATED_FAST__FAST__ELEMENT_H_

#include "flatbuffers/flatbuffers.h"

namespace _fast {

struct Element;

namespace _Element {

struct Anonymous0;

struct Unit;

struct Literal;

enum Kind {
  Kind_UNIT_KIND = 0,
  Kind_DECL = 1,
  Kind_DECL_STMT = 2,
  Kind_INIT = 3,
  Kind_EXPR = 4,
  Kind_EXPR_STMT = 5,
  Kind_COMMENT = 6,
  Kind_CALL = 7,
  Kind_CONTROL = 8,
  Kind_INCR = 9,
  Kind_NONE = 10,
  Kind_VARIABLE = 11,
  Kind_FUNCTION = 12,
  Kind_FUNCTION_DECL = 13,
  Kind_CONSTRUCTOR = 14,
  Kind_CONSTRUCTOR_DECL = 15,
  Kind_DESTRUCTOR = 16,
  Kind_DESTRUCTOR_DECL = 17,
  Kind_MACRO = 18,
  Kind_SINGLE_MACRO = 19,
  Kind_NULLOPERATOR = 20,
  Kind_ENUM_DEFN = 21,
  Kind_ENUM_DECL = 22,
  Kind_GLOBAL_ATTRIBUTE = 23,
  Kind_PROPERTY_ACCESSOR = 24,
  Kind_PROPERTY_ACCESSOR_DECL = 25,
  Kind_EXPRESSION = 26,
  Kind_CLASS_DEFN = 27,
  Kind_CLASS_DECL = 28,
  Kind_UNION_DEFN = 29,
  Kind_UNION_DECL = 30,
  Kind_STRUCT_DEFN = 31,
  Kind_STRUCT_DECL = 32,
  Kind_INTERFACE_DEFN = 33,
  Kind_INTERFACE_DECL = 34,
  Kind_ACCESS_REGION = 35,
  Kind_USING = 36,
  Kind_OPERATOR_FUNCTION = 37,
  Kind_OPERATOR_FUNCTION_DECL = 38,
  Kind_EVENT = 39,
  Kind_PROPERTY = 40,
  Kind_ANNOTATION_DEFN = 41,
  Kind_GLOBAL_TEMPLATE = 42,
  Kind_UNIT = 43,
  Kind_TART_ELEMENT_TOKEN = 44,
  Kind_NOP = 45,
  Kind_STRING = 46,
  Kind_CHAR = 47,
  Kind_LITERAL = 48,
  Kind_BOOLEAN = 49,
  Kind_NULL = 50,
  Kind_COMPLEX = 51,
  Kind_OPERATOR = 52,
  Kind_MODIFIER = 53,
  Kind_NAME = 54,
  Kind_ONAME = 55,
  Kind_CNAME = 56,
  Kind_TYPE = 57,
  Kind_TYPEPREV = 58,
  Kind_CONDITION = 59,
  Kind_BLOCK = 60,
  Kind_PSEUDO_BLOCK = 61,
  Kind_INDEX = 62,
  Kind_ENUM = 63,
  Kind_ENUM_DECLARATION = 64,
  Kind_IF_STATEMENT = 65,
  Kind_TERNARY = 66,
  Kind_THEN = 67,
  Kind_ELSE = 68,
  Kind_ELSEIF = 69,
  Kind_WHILE_STATEMENT = 70,
  Kind_DO_STATEMENT = 71,
  Kind_FOR_STATEMENT = 72,
  Kind_FOREACH_STATEMENT = 73,
  Kind_FOR_CONTROL = 74,
  Kind_FOR_INITIALIZATION = 75,
  Kind_FOR_CONDITION = 76,
  Kind_FOR_INCREMENT = 77,
  Kind_FOR_LIKE_CONTROL = 78,
  Kind_EXPRESSION_STATEMENT = 79,
  Kind_FUNCTION_CALL = 81,
  Kind_DECLARATION_STATEMENT = 82,
  Kind_DECLARATION = 83,
  Kind_DECLARATION_INITIALIZATION = 84,
  Kind_DECLARATION_RANGE = 85,
  Kind_RANGE = 86,
  Kind_GOTO_STATEMENT = 87,
  Kind_CONTINUE_STATEMENT = 88,
  Kind_BREAK_STATEMENT = 89,
  Kind_LABEL_STATEMENT = 90,
  Kind_LABEL = 91,
  Kind_SWITCH = 92,
  Kind_CASE = 93,
  Kind_DEFAULT = 94,
  Kind_FUNCTION_DEFINITION = 95,
  Kind_FUNCTION_DECLARATION = 96,
  Kind_LAMBDA = 97,
  Kind_FUNCTION_LAMBDA = 98,
  Kind_FUNCTION_SPECIFIER = 99,
  Kind_RETURN_STATEMENT = 100,
  Kind_PARAMETER_LIST = 101,
  Kind_PARAMETER = 102,
  Kind_KRPARAMETER_LIST = 103,
  Kind_KRPARAMETER = 104,
  Kind_ARGUMENT_LIST = 105,
  Kind_ARGUMENT = 106,
  Kind_PSEUDO_PARAMETER_LIST = 107,
  Kind_INDEXER_PARAMETER_LIST = 108,
  Kind_CLASS = 109,
  Kind_CLASS_DECLARATION = 110,
  Kind_STRUCT = 111,
  Kind_STRUCT_DECLARATION = 112,
  Kind_UNION = 113,
  Kind_UNION_DECLARATION = 114,
  Kind_DERIVATION_LIST = 115,
  Kind_PUBLIC_ACCESS = 116,
  Kind_PUBLIC_ACCESS_DEFAULT = 117,
  Kind_PRIVATE_ACCESS = 118,
  Kind_PRIVATE_ACCESS_DEFAULT = 119,
  Kind_PROTECTED_ACCESS = 120,
  Kind_PROTECTED_ACCESS_DEFAULT = 121,
  Kind_MEMBER_INIT_LIST = 122,
  Kind_MEMBER_INITIALIZATION_LIST = 123,
  Kind_MEMBER_INITIALIZATION = 124,
  Kind_CONSTRUCTOR_DEFINITION = 125,
  Kind_CONSTRUCTOR_DECLARATION = 126,
  Kind_DESTRUCTOR_DEFINITION = 127,
  Kind_DESTRUCTOR_DECLARATION = 128,
  Kind_FRIEND = 129,
  Kind_CLASS_SPECIFIER = 130,
  Kind_TRY_BLOCK = 131,
  Kind_CATCH_BLOCK = 132,
  Kind_FINALLY_BLOCK = 133,
  Kind_THROW_STATEMENT = 134,
  Kind_THROW_SPECIFIER = 135,
  Kind_THROW_SPECIFIER_JAVA = 136,
  Kind_TEMPLATE = 137,
  Kind_GENERIC_ARGUMENT = 138,
  Kind_GENERIC_ARGUMENT_LIST = 139,
  Kind_TEMPLATE_PARAMETER = 140,
  Kind_TEMPLATE_PARAMETER_LIST = 141,
  Kind_GENERIC_PARAMETER = 142,
  Kind_GENERIC_PARAMETER_LIST = 143,
  Kind_TYPEDEF = 144,
  Kind_ASM = 145,
  Kind_MACRO_CALL = 146,
  Kind_SIZEOF_CALL = 147,
  Kind_EXTERN = 148,
  Kind_NAMESPACE = 149,
  Kind_USING_DIRECTIVE = 150,
  Kind_DIRECTIVE = 151,
  Kind_ATOMIC = 152,
  Kind_STATIC_ASSERT_STATEMENT = 153,
  Kind_GENERIC_SELECTION = 154,
  Kind_GENERIC_SELECTOR = 155,
  Kind_GENERIC_ASSOCIATION_LIST = 156,
  Kind_GENERIC_ASSOCIATION = 157,
  Kind_ALIGNAS = 158,
  Kind_DECLTYPE = 159,
  Kind_CAPTURE = 160,
  Kind_LAMBDA_CAPTURE = 161,
  Kind_NOEXCEPT = 162,
  Kind_TYPENAME = 163,
  Kind_ALIGNOF = 164,
  Kind_TYPEID = 165,
  Kind_SIZEOF_PACK = 166,
  Kind_ENUM_CLASS = 167,
  Kind_ENUM_CLASS_DECLARATION = 168,
  Kind_REF_QUALIFIER = 171,
  Kind_SIGNAL_ACCESS = 172,
  Kind_FOREVER_STATEMENT = 173,
  Kind_EMIT_STATEMENT = 174,
  Kind_CPP_DIRECTIVE = 175,
  Kind_CPP_FILENAME = 176,
  Kind_FILE = 177,
  Kind_NUMBER = 178,
  Kind_CPP_NUMBER = 179,
  Kind_CPP_LITERAL = 180,
  Kind_CPP_MACRO_DEFN = 181,
  Kind_CPP_MACRO_VALUE = 182,
  Kind_ERROR = 183,
  Kind_CPP_ERROR = 184,
  Kind_CPP_WARNING = 185,
  Kind_CPP_PRAGMA = 186,
  Kind_CPP_INCLUDE = 187,
  Kind_CPP_DEFINE = 188,
  Kind_CPP_UNDEF = 189,
  Kind_CPP_LINE = 190,
  Kind_CPP_IF = 191,
  Kind_CPP_IFDEF = 192,
  Kind_CPP_IFNDEF = 193,
  Kind_CPP_THEN = 194,
  Kind_CPP_ELSE = 195,
  Kind_CPP_ELIF = 196,
  Kind_CPP_EMPTY = 197,
  Kind_CPP_REGION = 198,
  Kind_CPP_ENDREGION = 199,
  Kind_USING_STMT = 200,
  Kind_ESCAPE = 201,
  Kind_VALUE = 202,
  Kind_CPP_IMPORT = 203,
  Kind_CPP_ENDIF = 204,
  Kind_MARKER = 205,
  Kind_ERROR_PARSE = 206,
  Kind_ERROR_MODE = 207,
  Kind_IMPLEMENTS = 208,
  Kind_EXTENDS = 209,
  Kind_IMPORT = 210,
  Kind_PACKAGE = 211,
  Kind_ASSERT_STATEMENT = 212,
  Kind_INTERFACE = 213,
  Kind_INTERFACE_DECLARATION = 214,
  Kind_SYNCHRONIZED_STATEMENT = 215,
  Kind_ANNOTATION = 216,
  Kind_STATIC_BLOCK = 218,
  Kind_CHECKED_STATEMENT = 219,
  Kind_UNCHECKED_STATEMENT = 220,
  Kind_ATTRIBUTE = 221,
  Kind_TARGET = 222,
  Kind_UNSAFE_STATEMENT = 223,
  Kind_LOCK_STATEMENT = 224,
  Kind_FIXED_STATEMENT = 225,
  Kind_TYPEOF = 226,
  Kind_USING_STATEMENT = 227,
  Kind_FUNCTION_DELEGATE = 228,
  Kind_CONSTRAINT = 230,
  Kind_LINQ = 231,
  Kind_FROM = 232,
  Kind_WHERE = 233,
  Kind_SELECT = 234,
  Kind_LET = 235,
  Kind_ORDERBY = 236,
  Kind_JOIN = 237,
  Kind_GROUP = 238,
  Kind_IN = 239,
  Kind_ON = 240,
  Kind_EQUALS = 241,
  Kind_BY = 242,
  Kind_INTO = 243,
  Kind_EMPTY = 244,
  Kind_EMPTY_STMT = 245,
  Kind_RECEIVER = 246,
  Kind_MESSAGE = 247,
  Kind_SELECTOR = 248,
  Kind_PROTOCOL_LIST = 249,
  Kind_CATEGORY = 250,
  Kind_PROTOCOL = 251,
  Kind_REQUIRED_DEFAULT = 252,
  Kind_REQUIRED = 253,
  Kind_OPTIONAL = 254,
  Kind_ATTRIBUTE_LIST = 256,
  Kind_SYNTHESIZE = 257,
  Kind_DYNAMIC = 258,
  Kind_ENCODE = 259,
  Kind_AUTORELEASEPOOL = 260,
  Kind_COMPATIBILITY_ALIAS = 261,
  Kind_NIL = 262,
  Kind_CLASS_INTERFACE = 263,
  Kind_CLASS_IMPLEMENTATION = 264,
  Kind_PROTOCOL_DECLARATION = 265,
  Kind_CAST = 266,
  Kind_CONST_CAST = 267,
  Kind_DYNAMIC_CAST = 268,
  Kind_REINTERPRET_CAST = 269,
  Kind_STATIC_CAST = 270,
  Kind_POSITION = 271,
  Kind_CUDA_ARGUMENT_LIST = 272,
  Kind_OMP_DIRECTIVE = 273,
  Kind_OMP_NAME = 274,
  Kind_OMP_CLAUSE = 275,
  Kind_OMP_ARGUMENT_LIST = 276,
  Kind_OMP_ARGUMENT = 277,
  Kind_OMP_EXPRESSION = 278,
  Kind_END_ELEMENT_TOKEN = 279,
  Kind_MAIN = 280,
  Kind_BREAK = 281,
  Kind_CONTINUE = 282,
  Kind_WHILE = 283,
  Kind_DO = 284,
  Kind_FOR = 285,
  Kind_IF = 286,
  Kind_GOTO = 293,
  Kind_VISUAL_CXX_ASM = 295,
  Kind_SIZEOF = 296,
  Kind_AUTO = 298,
  Kind_REGISTER = 299,
  Kind_RESTRICT = 300,
  Kind_IMAGINARY = 304,
  Kind_NORETURN = 305,
  Kind_STATIC_ASSERT = 306,
  Kind_CRESTRICT = 307,
  Kind_CXX_TRY = 308,
  Kind_CXX_CATCH = 309,
  Kind_CXX_CLASS = 310,
  Kind_CONSTEXPR = 311,
  Kind_THREAD_LOCAL = 313,
  Kind_NULLPTR = 314,
  Kind_VOID = 326,
  Kind_RETURN = 327,
  Kind_INCLUDE = 328,
  Kind_DEFINE = 329,
  Kind_ELIF = 330,
  Kind_ENDIF = 331,
  Kind_ERRORPREC = 332,
  Kind_WARNING = 333,
  Kind_IFDEF = 334,
  Kind_IFNDEF = 335,
  Kind_LINE = 336,
  Kind_PRAGMA = 337,
  Kind_UNDEF = 338,
  Kind_INLINE = 339,
  Kind_MACRO_TYPE_NAME = 340,
  Kind_MACRO_CASE = 341,
  Kind_MACRO_LABEL = 342,
  Kind_SPECIFIER = 344,
  Kind_TRY = 345,
  Kind_CATCH = 346,
  Kind_THROW = 347,
  Kind_THROWS = 348,
  Kind_PUBLIC = 350,
  Kind_PRIVATE = 351,
  Kind_PROTECTED = 352,
  Kind_VIRTUAL = 353,
  Kind_EXPLICIT = 356,
  Kind_FOREVER = 357,
  Kind_SIGNAL = 358,
  Kind_EMIT = 359,
  Kind_NEW = 363,
  Kind_DELETE = 364,
  Kind_STATIC = 365,
  Kind_CONST = 366,
  Kind_MUTABLE = 367,
  Kind_VOLATILE = 368,
  Kind_TRANSIENT = 369,
  Kind_FINALLY = 372,
  Kind_FINAL = 376,
  Kind_ABSTRACT = 377,
  Kind_SUPER = 378,
  Kind_SYNCHRONIZED = 379,
  Kind_NATIVE = 380,
  Kind_STRICTFP = 381,
  Kind_NULLLITERAL = 382,
  Kind_ASSERT = 383,
  Kind_FOREACH = 384,
  Kind_REF = 385,
  Kind_OUT = 386,
  Kind_LOCK = 388,
  Kind_IS = 389,
  Kind_INTERNAL = 390,
  Kind_SEALED = 391,
  Kind_OVERRIDE = 392,
  Kind_IMPLICIT = 393,
  Kind_STACKALLOC = 394,
  Kind_AS = 395,
  Kind_DELEGATE = 396,
  Kind_FIXED = 397,
  Kind_CHECKED = 398,
  Kind_UNCHECKED = 399,
  Kind_REGION = 400,
  Kind_ENDREGION = 401,
  Kind_UNSAFE = 402,
  Kind_READONLY = 403,
  Kind_GET = 404,
  Kind_SET = 405,
  Kind_ADD = 406,
  Kind_REMOVE = 407,
  Kind_YIELD = 408,
  Kind_PARTIAL = 409,
  Kind_AWAIT = 410,
  Kind_ASYNC = 412,
  Kind_THIS = 413,
  Kind_PARAMS = 414,
  Kind_ALIAS = 416,
  Kind_ASCENDING = 422,
  Kind_DESCENDING = 423,
  Kind_ATINTERFACE = 430,
  Kind_ATIMPLEMENTATION = 431,
  Kind_ATEND = 432,
  Kind_ATPROTOCOL = 433,
  Kind_ATREQUIRED = 434,
  Kind_ATOPTIONAL = 435,
  Kind_ATCLASS = 441,
  Kind_WEAK = 443,
  Kind_STRONG = 444,
  Kind_OMP_OMP = 448,
  Kind_SPECIAL_CHARS = 449,
  Kind_MIN = Kind_UNIT_KIND,
  Kind_MAX = Kind_SPECIAL_CHARS
};

inline const char **EnumNamesKind() {
  static const char *names[] = {
    "UNIT_KIND",
    "DECL",
    "DECL_STMT",
    "INIT",
    "EXPR",
    "EXPR_STMT",
    "COMMENT",
    "CALL",
    "CONTROL",
    "INCR",
    "NONE",
    "VARIABLE",
    "FUNCTION",
    "FUNCTION_DECL",
    "CONSTRUCTOR",
    "CONSTRUCTOR_DECL",
    "DESTRUCTOR",
    "DESTRUCTOR_DECL",
    "MACRO",
    "SINGLE_MACRO",
    "NULLOPERATOR",
    "ENUM_DEFN",
    "ENUM_DECL",
    "GLOBAL_ATTRIBUTE",
    "PROPERTY_ACCESSOR",
    "PROPERTY_ACCESSOR_DECL",
    "EXPRESSION",
    "CLASS_DEFN",
    "CLASS_DECL",
    "UNION_DEFN",
    "UNION_DECL",
    "STRUCT_DEFN",
    "STRUCT_DECL",
    "INTERFACE_DEFN",
    "INTERFACE_DECL",
    "ACCESS_REGION",
    "USING",
    "OPERATOR_FUNCTION",
    "OPERATOR_FUNCTION_DECL",
    "EVENT",
    "PROPERTY",
    "ANNOTATION_DEFN",
    "GLOBAL_TEMPLATE",
    "UNIT",
    "TART_ELEMENT_TOKEN",
    "NOP",
    "STRING",
    "CHAR",
    "LITERAL",
    "BOOLEAN",
    "NULL",
    "COMPLEX",
    "OPERATOR",
    "MODIFIER",
    "NAME",
    "ONAME",
    "CNAME",
    "TYPE",
    "TYPEPREV",
    "CONDITION",
    "BLOCK",
    "PSEUDO_BLOCK",
    "INDEX",
    "ENUM",
    "ENUM_DECLARATION",
    "IF_STATEMENT",
    "TERNARY",
    "THEN",
    "ELSE",
    "ELSEIF",
    "WHILE_STATEMENT",
    "DO_STATEMENT",
    "FOR_STATEMENT",
    "FOREACH_STATEMENT",
    "FOR_CONTROL",
    "FOR_INITIALIZATION",
    "FOR_CONDITION",
    "FOR_INCREMENT",
    "FOR_LIKE_CONTROL",
    "EXPRESSION_STATEMENT",
    "",
    "FUNCTION_CALL",
    "DECLARATION_STATEMENT",
    "DECLARATION",
    "DECLARATION_INITIALIZATION",
    "DECLARATION_RANGE",
    "RANGE",
    "GOTO_STATEMENT",
    "CONTINUE_STATEMENT",
    "BREAK_STATEMENT",
    "LABEL_STATEMENT",
    "LABEL",
    "SWITCH",
    "CASE",
    "DEFAULT",
    "FUNCTION_DEFINITION",
    "FUNCTION_DECLARATION",
    "LAMBDA",
    "FUNCTION_LAMBDA",
    "FUNCTION_SPECIFIER",
    "RETURN_STATEMENT",
    "PARAMETER_LIST",
    "PARAMETER",
    "KRPARAMETER_LIST",
    "KRPARAMETER",
    "ARGUMENT_LIST",
    "ARGUMENT",
    "PSEUDO_PARAMETER_LIST",
    "INDEXER_PARAMETER_LIST",
    "CLASS",
    "CLASS_DECLARATION",
    "STRUCT",
    "STRUCT_DECLARATION",
    "UNION",
    "UNION_DECLARATION",
    "DERIVATION_LIST",
    "PUBLIC_ACCESS",
    "PUBLIC_ACCESS_DEFAULT",
    "PRIVATE_ACCESS",
    "PRIVATE_ACCESS_DEFAULT",
    "PROTECTED_ACCESS",
    "PROTECTED_ACCESS_DEFAULT",
    "MEMBER_INIT_LIST",
    "MEMBER_INITIALIZATION_LIST",
    "MEMBER_INITIALIZATION",
    "CONSTRUCTOR_DEFINITION",
    "CONSTRUCTOR_DECLARATION",
    "DESTRUCTOR_DEFINITION",
    "DESTRUCTOR_DECLARATION",
    "FRIEND",
    "CLASS_SPECIFIER",
    "TRY_BLOCK",
    "CATCH_BLOCK",
    "FINALLY_BLOCK",
    "THROW_STATEMENT",
    "THROW_SPECIFIER",
    "THROW_SPECIFIER_JAVA",
    "TEMPLATE",
    "GENERIC_ARGUMENT",
    "GENERIC_ARGUMENT_LIST",
    "TEMPLATE_PARAMETER",
    "TEMPLATE_PARAMETER_LIST",
    "GENERIC_PARAMETER",
    "GENERIC_PARAMETER_LIST",
    "TYPEDEF",
    "ASM",
    "MACRO_CALL",
    "SIZEOF_CALL",
    "EXTERN",
    "NAMESPACE",
    "USING_DIRECTIVE",
    "DIRECTIVE",
    "ATOMIC",
    "STATIC_ASSERT_STATEMENT",
    "GENERIC_SELECTION",
    "GENERIC_SELECTOR",
    "GENERIC_ASSOCIATION_LIST",
    "GENERIC_ASSOCIATION",
    "ALIGNAS",
    "DECLTYPE",
    "CAPTURE",
    "LAMBDA_CAPTURE",
    "NOEXCEPT",
    "TYPENAME",
    "ALIGNOF",
    "TYPEID",
    "SIZEOF_PACK",
    "ENUM_CLASS",
    "ENUM_CLASS_DECLARATION",
    "",
    "",
    "REF_QUALIFIER",
    "SIGNAL_ACCESS",
    "FOREVER_STATEMENT",
    "EMIT_STATEMENT",
    "CPP_DIRECTIVE",
    "CPP_FILENAME",
    "FILE",
    "NUMBER",
    "CPP_NUMBER",
    "CPP_LITERAL",
    "CPP_MACRO_DEFN",
    "CPP_MACRO_VALUE",
    "ERROR",
    "CPP_ERROR",
    "CPP_WARNING",
    "CPP_PRAGMA",
    "CPP_INCLUDE",
    "CPP_DEFINE",
    "CPP_UNDEF",
    "CPP_LINE",
    "CPP_IF",
    "CPP_IFDEF",
    "CPP_IFNDEF",
    "CPP_THEN",
    "CPP_ELSE",
    "CPP_ELIF",
    "CPP_EMPTY",
    "CPP_REGION",
    "CPP_ENDREGION",
    "USING_STMT",
    "ESCAPE",
    "VALUE",
    "CPP_IMPORT",
    "CPP_ENDIF",
    "MARKER",
    "ERROR_PARSE",
    "ERROR_MODE",
    "IMPLEMENTS",
    "EXTENDS",
    "IMPORT",
    "PACKAGE",
    "ASSERT_STATEMENT",
    "INTERFACE",
    "INTERFACE_DECLARATION",
    "SYNCHRONIZED_STATEMENT",
    "ANNOTATION",
    "",
    "STATIC_BLOCK",
    "CHECKED_STATEMENT",
    "UNCHECKED_STATEMENT",
    "ATTRIBUTE",
    "TARGET",
    "UNSAFE_STATEMENT",
    "LOCK_STATEMENT",
    "FIXED_STATEMENT",
    "TYPEOF",
    "USING_STATEMENT",
    "FUNCTION_DELEGATE",
    "",
    "CONSTRAINT",
    "LINQ",
    "FROM",
    "WHERE",
    "SELECT",
    "LET",
    "ORDERBY",
    "JOIN",
    "GROUP",
    "IN",
    "ON",
    "EQUALS",
    "BY",
    "INTO",
    "EMPTY",
    "EMPTY_STMT",
    "RECEIVER",
    "MESSAGE",
    "SELECTOR",
    "PROTOCOL_LIST",
    "CATEGORY",
    "PROTOCOL",
    "REQUIRED_DEFAULT",
    "REQUIRED",
    "OPTIONAL",
    "",
    "ATTRIBUTE_LIST",
    "SYNTHESIZE",
    "DYNAMIC",
    "ENCODE",
    "AUTORELEASEPOOL",
    "COMPATIBILITY_ALIAS",
    "NIL",
    "CLASS_INTERFACE",
    "CLASS_IMPLEMENTATION",
    "PROTOCOL_DECLARATION",
    "CAST",
    "CONST_CAST",
    "DYNAMIC_CAST",
    "REINTERPRET_CAST",
    "STATIC_CAST",
    "POSITION",
    "CUDA_ARGUMENT_LIST",
    "OMP_DIRECTIVE",
    "OMP_NAME",
    "OMP_CLAUSE",
    "OMP_ARGUMENT_LIST",
    "OMP_ARGUMENT",
    "OMP_EXPRESSION",
    "END_ELEMENT_TOKEN",
    "MAIN",
    "BREAK",
    "CONTINUE",
    "WHILE",
    "DO",
    "FOR",
    "IF",
    "",
    "",
    "",
    "",
    "",
    "",
    "GOTO",
    "",
    "VISUAL_CXX_ASM",
    "SIZEOF",
    "",
    "AUTO",
    "REGISTER",
    "RESTRICT",
    "",
    "",
    "",
    "IMAGINARY",
    "NORETURN",
    "STATIC_ASSERT",
    "CRESTRICT",
    "CXX_TRY",
    "CXX_CATCH",
    "CXX_CLASS",
    "CONSTEXPR",
    "",
    "THREAD_LOCAL",
    "NULLPTR",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "VOID",
    "RETURN",
    "INCLUDE",
    "DEFINE",
    "ELIF",
    "ENDIF",
    "ERRORPREC",
    "WARNING",
    "IFDEF",
    "IFNDEF",
    "LINE",
    "PRAGMA",
    "UNDEF",
    "INLINE",
    "MACRO_TYPE_NAME",
    "MACRO_CASE",
    "MACRO_LABEL",
    "",
    "SPECIFIER",
    "TRY",
    "CATCH",
    "THROW",
    "THROWS",
    "",
    "PUBLIC",
    "PRIVATE",
    "PROTECTED",
    "VIRTUAL",
    "",
    "",
    "EXPLICIT",
    "FOREVER",
    "SIGNAL",
    "EMIT",
    "",
    "",
    "",
    "NEW",
    "DELETE",
    "STATIC",
    "CONST",
    "MUTABLE",
    "VOLATILE",
    "TRANSIENT",
    "",
    "",
    "FINALLY",
    "",
    "",
    "",
    "FINAL",
    "ABSTRACT",
    "SUPER",
    "SYNCHRONIZED",
    "NATIVE",
    "STRICTFP",
    "NULLLITERAL",
    "ASSERT",
    "FOREACH",
    "REF",
    "OUT",
    "",
    "LOCK",
    "IS",
    "INTERNAL",
    "SEALED",
    "OVERRIDE",
    "IMPLICIT",
    "STACKALLOC",
    "AS",
    "DELEGATE",
    "FIXED",
    "CHECKED",
    "UNCHECKED",
    "REGION",
    "ENDREGION",
    "UNSAFE",
    "READONLY",
    "GET",
    "SET",
    "ADD",
    "REMOVE",
    "YIELD",
    "PARTIAL",
    "AWAIT",
    "",
    "ASYNC",
    "THIS",
    "PARAMS",
    "",
    "ALIAS",
    "",
    "",
    "",
    "",
    "",
    "ASCENDING",
    "DESCENDING",
    "",
    "",
    "",
    "",
    "",
    "",
    "ATINTERFACE",
    "ATIMPLEMENTATION",
    "ATEND",
    "ATPROTOCOL",
    "ATREQUIRED",
    "ATOPTIONAL",
    "",
    "",
    "",
    "",
    "",
    "ATCLASS",
    "",
    "WEAK",
    "STRONG",
    "",
    "",
    "",
    "OMP_OMP",
    "SPECIAL_CHARS",
    nullptr
  };
  return names;
}

inline const char *EnumNameKind(Kind e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesKind()[index];
}

namespace _Unit {

enum LanguageType {
  LanguageType_ALL = 0,
  LanguageType_OO = 1,
  LanguageType_CXX = 2,
  LanguageType_C = 3,
  LanguageType_C_FAMILY = 4,
  LanguageType_JAVA = 5,
  LanguageType_CSHARP = 6,
  LanguageType_OBJECTIVE_C = 7,
  LanguageType_MIN = LanguageType_ALL,
  LanguageType_MAX = LanguageType_OBJECTIVE_C
};

inline const char **EnumNamesLanguageType() {
  static const char *names[] = {
    "ALL",
    "OO",
    "CXX",
    "C",
    "C_FAMILY",
    "JAVA",
    "CSHARP",
    "OBJECTIVE_C",
    nullptr
  };
  return names;
}

inline const char *EnumNameLanguageType(LanguageType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLanguageType()[index];
}

}  // namespace _Unit

namespace _Literal {

enum LiteralType {
  LiteralType_number_type = 0,
  LiteralType_char_type = 1,
  LiteralType_string_type = 2,
  LiteralType_boolean_type = 3,
  LiteralType_null_type = 4,
  LiteralType_MIN = LiteralType_number_type,
  LiteralType_MAX = LiteralType_null_type
};

inline const char **EnumNamesLiteralType() {
  static const char *names[] = {
    "number_type",
    "char_type",
    "string_type",
    "boolean_type",
    "null_type",
    nullptr
  };
  return names;
}

inline const char *EnumNameLiteralType(LiteralType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLiteralType()[index];
}

}  // namespace _Literal
}  // namespace _Element

struct Element FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KIND = 4,
    VT_TEXT = 6,
    VT_TAIL = 8,
    VT_CHILD = 10,
    VT_EXTRA = 12
  };
  int32_t kind() const {
    return GetField<int32_t>(VT_KIND, 0);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  const flatbuffers::String *tail() const {
    return GetPointer<const flatbuffers::String *>(VT_TAIL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Element>> *child() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Element>> *>(VT_CHILD);
  }
  const _fast::_Element::Anonymous0 *extra() const {
    return GetPointer<const _fast::_Element::Anonymous0 *>(VT_EXTRA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KIND) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TAIL) &&
           verifier.Verify(tail()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CHILD) &&
           verifier.Verify(child()) &&
           verifier.VerifyVectorOfTables(child()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EXTRA) &&
           verifier.VerifyTable(extra()) &&
           verifier.EndTable();
  }
};

struct ElementBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kind(int32_t kind) {
    fbb_.AddElement<int32_t>(Element::VT_KIND, kind, 0);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(Element::VT_TEXT, text);
  }
  void add_tail(flatbuffers::Offset<flatbuffers::String> tail) {
    fbb_.AddOffset(Element::VT_TAIL, tail);
  }
  void add_child(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Element>>> child) {
    fbb_.AddOffset(Element::VT_CHILD, child);
  }
  void add_extra(flatbuffers::Offset<_fast::_Element::Anonymous0> extra) {
    fbb_.AddOffset(Element::VT_EXTRA, extra);
  }
  ElementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ElementBuilder &operator=(const ElementBuilder &);
  flatbuffers::Offset<Element> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<Element>(end);
    return o;
  }
};

inline flatbuffers::Offset<Element> CreateElement(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kind = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    flatbuffers::Offset<flatbuffers::String> tail = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Element>>> child = 0,
    flatbuffers::Offset<_fast::_Element::Anonymous0> extra = 0) {
  ElementBuilder builder_(_fbb);
  builder_.add_extra(extra);
  builder_.add_child(child);
  builder_.add_tail(tail);
  builder_.add_text(text);
  builder_.add_kind(kind);
  return builder_.Finish();
}

inline flatbuffers::Offset<Element> CreateElementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kind = 0,
    const char *text = nullptr,
    const char *tail = nullptr,
    const std::vector<flatbuffers::Offset<Element>> *child = nullptr,
    flatbuffers::Offset<_fast::_Element::Anonymous0> extra = 0) {
  return _fast::CreateElement(
      _fbb,
      kind,
      text ? _fbb.CreateString(text) : 0,
      tail ? _fbb.CreateString(tail) : 0,
      child ? _fbb.CreateVector<flatbuffers::Offset<Element>>(*child) : 0,
      extra);
}

namespace _Element {

struct Anonymous0 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UNIT = 4,
    VT_LITERAL = 6
  };
  const Unit *unit() const {
    return GetPointer<const Unit *>(VT_UNIT);
  }
  const Literal *literal() const {
    return GetPointer<const Literal *>(VT_LITERAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UNIT) &&
           verifier.VerifyTable(unit()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LITERAL) &&
           verifier.VerifyTable(literal()) &&
           verifier.EndTable();
  }
};

struct Anonymous0Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_unit(flatbuffers::Offset<Unit> unit) {
    fbb_.AddOffset(Anonymous0::VT_UNIT, unit);
  }
  void add_literal(flatbuffers::Offset<Literal> literal) {
    fbb_.AddOffset(Anonymous0::VT_LITERAL, literal);
  }
  Anonymous0Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Anonymous0Builder &operator=(const Anonymous0Builder &);
  flatbuffers::Offset<Anonymous0> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Anonymous0>(end);
    return o;
  }
};

inline flatbuffers::Offset<Anonymous0> CreateAnonymous0(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Unit> unit = 0,
    flatbuffers::Offset<Literal> literal = 0) {
  Anonymous0Builder builder_(_fbb);
  builder_.add_literal(literal);
  builder_.add_unit(unit);
  return builder_.Finish();
}

struct Unit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FILENAME = 4,
    VT_REVISION = 6,
    VT_LANGUAGE = 8,
    VT_ITEM = 10
  };
  const flatbuffers::String *filename() const {
    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
  }
  const flatbuffers::String *revision() const {
    return GetPointer<const flatbuffers::String *>(VT_REVISION);
  }
  int32_t language() const {
    return GetField<int32_t>(VT_LANGUAGE, 0);
  }
  int32_t item() const {
    return GetField<int32_t>(VT_ITEM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FILENAME) &&
           verifier.Verify(filename()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_REVISION) &&
           verifier.Verify(revision()) &&
           VerifyField<int32_t>(verifier, VT_LANGUAGE) &&
           VerifyField<int32_t>(verifier, VT_ITEM) &&
           verifier.EndTable();
  }
};

struct UnitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) {
    fbb_.AddOffset(Unit::VT_FILENAME, filename);
  }
  void add_revision(flatbuffers::Offset<flatbuffers::String> revision) {
    fbb_.AddOffset(Unit::VT_REVISION, revision);
  }
  void add_language(int32_t language) {
    fbb_.AddElement<int32_t>(Unit::VT_LANGUAGE, language, 0);
  }
  void add_item(int32_t item) {
    fbb_.AddElement<int32_t>(Unit::VT_ITEM, item, 0);
  }
  UnitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnitBuilder &operator=(const UnitBuilder &);
  flatbuffers::Offset<Unit> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Unit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unit> CreateUnit(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> filename = 0,
    flatbuffers::Offset<flatbuffers::String> revision = 0,
    int32_t language = 0,
    int32_t item = 0) {
  UnitBuilder builder_(_fbb);
  builder_.add_item(item);
  builder_.add_language(language);
  builder_.add_revision(revision);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline flatbuffers::Offset<Unit> CreateUnitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr,
    const char *revision = nullptr,
    int32_t language = 0,
    int32_t item = 0) {
  return _fast::_Element::CreateUnit(
      _fbb,
      filename ? _fbb.CreateString(filename) : 0,
      revision ? _fbb.CreateString(revision) : 0,
      language,
      item);
}

struct Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct LiteralBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Literal::VT_TYPE, type, 0);
  }
  LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiteralBuilder &operator=(const LiteralBuilder &);
  flatbuffers::Offset<Literal> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Literal> CreateLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0) {
  LiteralBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

}  // namespace _Element

namespace _Element {

}  // namespace _Element
}  // namespace _fast

#endif  // FLATBUFFERS_GENERATED_FAST__FAST__ELEMENT_H_
