fpml,@@ -0,0 +1,63 @@$$+// Copyright (C),2006-2007 HandCoded Software Ltd.$$+// All rights reserved.$$+//$$+// This software is licensed in accordance with the terms of the 'Open Source$$+// License (OSL) Version 3.0'. Please see 'license.txt' for the details.$$+//$$+// HANDCODED SOFTWARE LTD MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE$$+// SUITABILITY OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT$$+// LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A$$+// PARTICULAR PURPOSE, OR NON-INFRINGEMENT. HANDCODED SOFTWARE LTD SHALL NOT BE$$+// LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING$$+// OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.$$+$$+package com.handcoded.fpml.meta;$$+$$+import org.w3c.dom.Document;$$+$$+import com.handcoded.meta.DefaultSchemaRecogniser;$$+import com.handcoded.meta.SchemaRelease;$$+$$+/**$$+ * The <CODE>FpMLSchemaRecogniser</CODE> extends the behaviour of the$$+ * <CODE>DefaultSchemaRecogniser</CODE> to look for a 'version' attribute$$+ * containing an appropriate version number.$$+ *$$+ * @author 	BitWise$$+ * @version	$Id$$$+ * @since	TFP 1.1$$+ */$$+public final class FpMLSchemaRecogniser extends DefaultSchemaRecogniser$$+{$$+	/**$$+	 * Constructs a <CODE>FpMLSchemaRecogniser</CODE> instance.$$+	 * @since	TFP 1.1$$+	 */$$+	public FpMLSchemaRecogniser ()$$+	{ }$$+$$+	/**$$+	 * {@inheritDoc}$$+	 * <P>$$+	 * Also checks that the FpML version attribute matches the <CODE>SchemaRelease</CODE>$$+	 * instance.$$+	 *$$+	 * @since	TFP 1.1$$+	 */$$+	public boolean recognises (SchemaRelease release, Document document)$$+	{$$+		if (super.recognises (release, document)) {$$+			int majorVersion = Integer.parseInt (release.getVersion().split("-")[0]);$$+$$+			if (majorVersion <= 4) {$$+				if (document.getDocumentElement ().getAttribute ("version").equals (release.getVersion ()))$$+					return (true);$$+			}$$+			else {$$+				if (document.getDocumentElement ().getAttribute ("fpmlVersion").equals (release.getVersion ()))$$+					return (true);$$+			}$$+		}$$+		return (false);$$+	}$$+}$$\ No newline at end of file$$,@@ -82,2222 +431,1704 @@ namespace HandCoded.FpML.Validation$$return (result);$$}$$$$+		// --------------------------------------------------------------------$$$$-#if false$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures that if forwardPoints exists then$$-	 * spotRate should also exist.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE02$$-		= new Rule (Preconditions.R3_0__LATER, "fx-2")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "ExchangeRate"), errorHandler));$$-$$-				return ($$-					  validate (nodeIndex.getElementsByName ("exchangeRate"), errorHandler));$$-			}$$+		private static bool Rule02 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule02 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "ExchangeRate"), errorHandler));$$+$$+			return ($$+				  Rule02 (name, nodeIndex.GetElementsByName ("exchangeRate"), errorHandler));$$+		}$$+$$+		private static bool Rule02 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement	context in list) {$$+				XmlElement 	forward = XPath.Path (context, "forwardPoints");$$+				XmlElement	spot	= XPath.Path (context, "spotRate");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element 	forward = XPath.path (context, "forwardPoints");$$-					Element		spot	= XPath.path (context, "spotRate");$$-$$-					if (!((forward != null) && (spot == null))) continue;$$-$$-					errorHandler.error ("305", context,$$-							"If forwardPoints exists then spotRate should also exist.",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+				if (!((forward != null) && (spot == null))) continue;$$$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures that if both forwardPoints and spotRate$$-	 * exist then rate equals 'spotRate + forwardRate'.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE03$$-		= new Rule (Preconditions.R3_0__LATER, "fx-3")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "ExchangeRate"), errorHandler));$$-$$-				return ($$-					  validate (nodeIndex.getElementsByName ("exchangeRate"), errorHandler));$$+				errorHandler ("305", context,$$+						"If forwardPoints exists then spotRate should also exist.",$$+						name, null);$$+$$+				result = false;$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$-$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element 	forward = XPath.path (context, "forwardPoints");$$-					Element		spot	= XPath.path (context, "spotRate");$$-					Element		rate	= XPath.path (context, "rate");$$-$$-					if ((rate == null) || (forward == null) || (spot == null)) continue;$$-$$-					if (toDecimal (rate).equals(toDecimal (spot).add (toDecimal (forward))))$$-						continue;$$-$$-					errorHandler.error ("305", context,$$-							"Sum of spotRate and forwardPoints does not equal rate.",$$-							getName (), Types.toString (rate));$$-$$-					result = false;$$-				}$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule03 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule03 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "ExchangeRate"), errorHandler));$$$$-				return (result);$$-			}$$-		};$$-$$-	// 4 5 6$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures sideRates/baseCurrency must be neither$$-	 * quotedCurrencyPair/currency1 nor quotedCurrencyPair/currency2.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE04$$-		= new Rule (Preconditions.R3_0__LATER, "fx-4")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "ExchangeRate"), errorHandler));$$-$$-				return ($$-					  validate (nodeIndex.getElementsByName ("exchangeRate"), errorHandler));$$-			}$$+			return ($$+				  Rule03 (name, nodeIndex.GetElementsByName ("exchangeRate"), errorHandler));$$+		}$$+$$+		private static bool Rule03 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement	context in list) {$$+				XmlElement 	forward = XPath.Path (context, "forwardPoints");$$+				XmlElement	spot	= XPath.Path (context, "spotRate");$$+				XmlElement	rate	= XPath.Path (context, "rate");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element 	baseCcy = XPath.path (context, "sideRates", "baseCurrency");$$-					Element		ccy1	= XPath.path (context, "quotedCurrencyPair", "currency1");$$-					Element		ccy2	= XPath.path (context, "quotedCurrencyPair", "currency2");$$-$$-					if ((baseCcy == null) || (ccy2 == null) || (ccy2 == null)) continue;$$-$$-					if (equal (baseCcy, ccy1) || equal (baseCcy, ccy2)) {$$-						errorHandler.error ("305", context,$$-								"The side rate base currency must not be one of the trade currencies.",$$-								getName (), Types.toString (baseCcy));$$-$$-						result = false;$$-					}$$-				}$$+				if ((rate == null) || (forward == null) || (spot == null)) continue;$$$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures sideRates/currency1SideRate/currency$$-	 * must be the same as quotedCurrencyPair/currency1.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE05$$-		= new Rule (Preconditions.R3_0__LATER, "fx-5")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "ExchangeRate"), errorHandler));$$-$$-				return ($$-					  validate (nodeIndex.getElementsByName ("exchangeRate"), errorHandler));$$+				if (ToDecimal (rate).Equals (ToDecimal (spot) + ToDecimal (forward)))$$+					continue;$$+$$+				errorHandler ("305", context,$$+						"Sum of spotRate and forwardPoints does not equal rate.",$$+						name, ToToken (rate));$$+$$+				result = false;$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule04 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule04 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "ExchangeRate"), errorHandler));$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		ccy		= XPath.path (context, "quotedCurrencyPair", "currency1");$$-					Element 	ccy1 	= XPath.path (context, "sideRates", "currency1SideRate", "currency");$$-$$-					if ((ccy == null) || (ccy1 == null) || equal (ccy, ccy1)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"The side rate currency1 '" + Types.toString(ccy1) +$$-							"' must be the same as trade currency1 '" + Types.toString(ccy) + "'.",$$-							getName (), null);$$+			return ($$+				  Rule04 (name, nodeIndex.GetElementsByName ("exchangeRate"), errorHandler));$$+		}$$+$$+		private static bool Rule04 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement context in list) {$$+				XmlElement 	baseCcy = XPath.Path (context, "sideRates", "baseCurrency");$$+				XmlElement	ccy1	= XPath.Path (context, "quotedCurrencyPair", "currency1");$$+				XmlElement	ccy2	= XPath.Path (context, "quotedCurrencyPair", "currency2");$$+$$+				if ((baseCcy == null) || (ccy2 == null) || (ccy2 == null)) continue;$$+$$+				if (Equal (baseCcy, ccy1) || Equal (baseCcy, ccy2)) {$$+					errorHandler ("305", context,$$+							"The side rate base currency must not be one of the trade currencies.",$$+							name, ToToken (baseCcy));$$$$result = false;$$}$$-$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures sideRates/currency2SideRate/currency$$-	 * must be the same as quotedCurrencyPair/currency2.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE06$$-		= new Rule (Preconditions.R3_0__LATER, "fx-6")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "ExchangeRate"), errorHandler));$$-$$-				return ($$-					  validate (nodeIndex.getElementsByName ("exchangeRate"), errorHandler));$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule05 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule05 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "ExchangeRate"), errorHandler));$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		ccy		= XPath.path (context, "quotedCurrencyPair", "currency2");$$-					Element 	ccy1 	= XPath.path (context, "sideRates", "currency2SideRate", "currency");$$-$$-					if ((ccy == null) || (ccy1 == null) || equal (ccy, ccy1)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"The side rate currency2 '" + Types.toString(ccy1) +$$-							"' must be the same as trade currency2 '" + Types.toString(ccy) + "'.",$$-							getName (), null);$$+			return ($$+				  Rule05 (name, nodeIndex.GetElementsByName ("exchangeRate"), errorHandler));$$+		}$$+$$+		private static bool Rule05 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement context in list) {$$+				XmlElement	ccy		= XPath.Path (context, "quotedCurrencyPair", "currency1");$$+				XmlElement 	ccy1 	= XPath.Path (context, "sideRates", "currency1SideRate", "currency");$$$$-					result = false;$$-				}$$+				if ((ccy == null) || (ccy1 == null) || Equal (ccy, ccy1)) continue;$$$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures triggerRate is positive.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE07$$-		= new Rule (Preconditions.R3_0__LATER, "fx-7")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXAmericanTrigger"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxAmericanTrigger"), errorHandler));$$-$$-				return ($$-					  validate (nodeIndex.getElementsByName ("fxAmericanTrigger"), errorHandler));$$+				errorHandler ("305", context,$$+						"The side rate currency1 '" + ToToken (ccy1) +$$+						"' must be the same as trade currency1 '" + ToToken (ccy) + "'.",$$+						name, null);$$+$$+				result = false;$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule06 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule06 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "ExchangeRate"), errorHandler));$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		rate	= XPath.path (context, "triggerRate");$$-$$-					if ((rate == null) || isPositive (rate)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"The trigger rate must be positive",$$-							getName (), Types.toString (rate));$$-$$-					result = false;$$-				}$$+			return ($$+				  Rule06 (name, nodeIndex.GetElementsByName ("exchangeRate"), errorHandler));$$+		}$$+$$+		private static bool Rule06 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement context in list) {$$+				XmlElement	ccy		= XPath.Path (context, "quotedCurrencyPair", "currency2");$$+				XmlElement 	ccy1 	= XPath.Path (context, "sideRates", "currency2SideRate", "currency");$$$$-				return (result);$$+				if ((ccy == null) || (ccy1 == null) || Equal (ccy, ccy1)) continue;$$+$$+				errorHandler ("305", context,$$+						"The side rate currency2 '" + ToToken (ccy1) +$$+						"' must be the same as trade currency2 '" + ToToken (ccy) + "'.",$$+						name, null);$$+$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that observationStartDate and observationEndDate$$-	 * both exist then observationStartDate <= observationEndDate.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE08$$-		= new Rule (Preconditions.R3_0__LATER, "fx-8")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXAmericanTrigger"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxAmericanTrigger"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule07 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxAmericanTrigger"), errorHandler));$$-			}$$+					  Rule07 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXAmericanTrigger"), errorHandler)$$+					& Rule07 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxAmericanTrigger"), errorHandler));$$+$$+			return ($$+				  Rule07 (name, nodeIndex.GetElementsByName ("fxAmericanTrigger"), errorHandler));$$+		}$$+$$+		private static bool Rule07 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement		rate	= XPath.Path (context, "triggerRate");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		start	= XPath.path (context, "observationStartDate");$$-					Element		end		= XPath.path (context, "observationEndDate");$$-$$-					if ((start == null) || (end == null) ||$$-						lessOrEqual (toDate (start), toDate (end))) continue;$$-$$-					errorHandler.error ("305", context,$$-							"The observationStartDate must not be after the observationEndDate",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+				if ((rate == null) || IsPositive (rate)) continue;$$+$$+				errorHandler ("305", context,$$+						"The trigger rate must be positive",$$+						name, ToToken (rate));$$$$-				return (result);$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures observationStartDate and observationEndDate$$-	 * both exist then observationStartDate <= observationEndDate.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE09$$-		= new Rule (Preconditions.R3_0__LATER, "fx-9")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXAverageRateObservationSchedule"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxAverageRateObservationSchedule"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule08 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("averageRateObservationSchedule"), errorHandler));$$-			}$$+					  Rule08 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXAmericanTrigger"), errorHandler)$$+					& Rule08 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxAmericanTrigger"), errorHandler));$$+$$+			return ($$+				  Rule08 (name, nodeIndex.GetElementsByName ("fxAmericanTrigger"), errorHandler));$$+		}$$+$$+		private static bool Rule08 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	start	= XPath.Path (context, "observationStartDate");$$+				XmlElement	end		= XPath.Path (context, "observationEndDate");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		start	= XPath.path (context, "observationStartDate");$$-					Element		end		= XPath.path (context, "observationEndDate");$$-$$-					if ((start == null) || (end == null) ||$$-						lessOrEqual (toDate (start), toDate (end))) continue;$$-$$-					errorHandler.error ("305", context,$$-							"The observationStartDate must not be after the observationEndDate",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+				if ((start == null) || (end == null) ||$$+					LessOrEqual (ToDate (start), ToDate (end))) continue;$$+$$+				errorHandler ("305", context,$$+						"The observationStartDate must not be after the observationEndDate",$$+						name, null);$$$$-				return (result);$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures the observation period defined by$$-	 * observationStartDate and observationEndDate should be an integer$$-	 * multiple of the calculationPeriodFrequency.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE10$$-		= new Rule (Preconditions.R3_0__LATER, "fx-10")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXAverageRateObservationSchedule"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxAverageRateObservationSchedule"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule09 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("averageRateObservationSchedule"), errorHandler));$$-			}$$+					  Rule09 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXAverageRateObservationSchedule"), errorHandler)$$+					& Rule09 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxAverageRateObservationSchedule"), errorHandler));$$+$$+			return ($$+				  Rule09 (name, nodeIndex.GetElementsByName ("averageRateObservationSchedule"), errorHandler));$$+		}$$+$$+		private static bool Rule09 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	start	= XPath.Path (context, "observationStartDate");$$+				XmlElement	end		= XPath.Path (context, "observationEndDate");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		start	= XPath.path (context, "observationStartDate");$$-					Element		end		= XPath.path (context, "observationEndDate");$$-					Element		period	= XPath.path (context, "calculationPeriodFrequency");$$-$$-					if ((start == null) || (end == null) || (period == null) ||$$-							toInterval (period).dividesDates(toDate (start), toDate (end))) continue;$$-$$-					errorHandler.error ("305", context,$$-							"The observation period is not a multiple of the calculationPeriodFrequency",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+				if ((start == null) || (end == null) ||$$+					LessOrEqual (ToDate (start), ToDate (end))) continue;$$+$$+				errorHandler ("305", context,$$+						"The observationStartDate must not be after the observationEndDate",$$+						name, null);$$$$-				return (result);$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures each observationDate is unique.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE11$$-		= new Rule (Preconditions.R3_0__LATER, "fx-11")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXAverageRateOption"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxAverageRateOption"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule10 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxAverageRateOption"), errorHandler));$$-			}$$+					  Rule10 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXAverageRateObservationSchedule"), errorHandler)$$+					& Rule10 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxAverageRateObservationSchedule"), errorHandler));$$+$$+			return ($$+				  Rule10 (name, nodeIndex.GetElementsByName ("averageRateObservationSchedule"), errorHandler));$$+		}$$+$$+		private static bool Rule10 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	start	= XPath.Path (context, "observationStartDate");$$+				XmlElement	end		= XPath.Path (context, "observationEndDate");$$+				XmlElement	period	= XPath.Path (context, "calculationPeriodFrequency");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					NodeList	nodes	= XPath.paths (context, "observedRates", "observationDate");$$-$$-					int			limit	= nodes.getLength ();$$-					Date []		dates	= new Date [limit];$$-$$-					for (int count = 0; count < limit; ++count)$$-						dates [count] = toDate (nodes.item(count));$$-$$-					for (int outer = 0; outer < (limit - 1); ++outer) {$$-						for (int inner = outer + 1; inner < limit; ++inner) {$$-							if (equal (dates [outer], dates [inner]))$$-								errorHandler.error ("305", nodes.item (inner),$$-										"Duplicate observation date",$$-										getName (), Types.toString(nodes.item (inner)));$$+				if ((start == null) || (end == null) || (period == null) ||$$+						ToInterval (period).DividesDates(ToDate (start), ToDate (end))) continue;$$$$-							result = false;$$-						}$$-					}$$-					dates = null;$$-				}$$+				errorHandler ("305", context,$$+						"The observation period is not a multiple of the calculationPeriodFrequency",$$+						name, null);$$$$-				return (result);$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures each observationDate matches one defined$$-	 * by the schedule.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE12$$-		= new Rule (Preconditions.R3_0__LATER, "fx-12")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXAverageRateOption"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxAverageRateOption"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule11 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxAverageRateOption"), errorHandler));$$-			}$$+					  Rule11 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXAverageRateOption"), errorHandler)$$+					& Rule11 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxAverageRateOption"), errorHandler));$$+$$+			return ($$+				  Rule11 (name, nodeIndex.GetElementsByName ("fxAverageRateOption"), errorHandler));$$+		}$$+$$+		private static bool Rule11 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlNodeList	nodes	= XPath.Paths (context, "observedRates", "observationDate");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context 	= (Element) list.item (index);$$-					Element		schedule	= XPath.path (context, "averageRateObservationSchedule");$$-$$-					if (schedule == null) continue;$$-$$-					Element		start	= XPath.path (schedule, "observationStartDate");$$-					Element		end		= XPath.path (schedule, "observationEndDate");$$-					Element		freq	= XPath.path (schedule, "calculationPeriodFrequency");$$-					Element		roll	= XPath.path (freq, "rollConvention");$$-$$-					if ((start == null) || (end == null) || (freq == null) || (roll == null)) continue;$$-$$-					Date [] 	dates	= generateSchedule (toDate (start), toDate (end),$$-							toInterval (freq), DateRoll.forName (Types.toString (roll)), null);$$-$$-					NodeList	nodes	= XPath.paths (context, "observedRates", "observationDate");$$-$$-					for (int count = 0; count < nodes.getLength(); ++count) {$$-						Element 	observed = (Element) nodes.item (count);$$-						Date		date 	 = toDate (observed);$$-$$-						boolean		found = false;$$-						for (int match = 0; match < dates.length; ++match) {$$-							if (equal (date, dates [match])) {$$-								found = true;$$-								break;$$-							}$$-						}$$+				int			limit	= nodes.Count;$$+				Date []		dates	= new Date [limit];$$+$$+				for (int count = 0; count < limit; ++count)$$+					dates [count] = ToDate (nodes [count]);$$+$$+				for (int outer = 0; outer < (limit - 1); ++outer) {$$+					for (int inner = outer + 1; inner < limit; ++inner) {$$+						if (Equal (dates [outer], dates [inner]))$$+							errorHandler ("305", nodes [inner],$$+									"Duplicate observation date",$$+									name, ToToken (nodes [inner]));$$$$-						if (!found) {$$-							errorHandler.error ("305", observed,$$-									"Observation date '" + Types.toString (observed) +$$-									"' does not match with the schedule.",$$-									getName (), Types.toString(observed));$$-$$-							result = false;$$-						}$$+						result = false;$$}$$-					dates = null;$$}$$-$$-				return (result);$$+				dates = null;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures each observationDate is unique.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE13$$-		= new Rule (Preconditions.R3_0__LATER, "fx-13")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXAverageRateOption"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxAverageRateOption"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule12 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxAverageRateOption"), errorHandler));$$-			}$$+					  Rule12 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXAverageRateOption"), errorHandler)$$+					& Rule12 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxAverageRateOption"), errorHandler));$$+$$+			return ($$+				  Rule12 (name, nodeIndex.GetElementsByName ("fxAverageRateOption"), errorHandler));$$+		}$$+$$+		private static bool Rule12 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	schedule	= XPath.Path (context, "averageRateObservationSchedule");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context 	= (Element) list.item (index);$$-					NodeList	schedule	= XPath.paths (context, "averageRateObservationDate", "observationDate");$$-					int			limit		= (schedule != null) ? schedule.getLength () : 0;$$-$$-					if (limit == 0) continue;$$-$$-					Date []		dates	= new Date [limit];$$-$$-					for (int count = 0; count < limit; ++count)$$-						dates [count] = toDate (schedule.item (count));$$+				if (schedule == null) continue;$$+$$+				XmlElement	start	= XPath.Path (schedule, "observationStartDate");$$+				XmlElement	end		= XPath.Path (schedule, "observationEndDate");$$+				XmlElement	freq	= XPath.Path (schedule, "calculationPeriodFrequency");$$+				XmlElement	roll	= XPath.Path (freq, "rollConvention");$$+$$+				if ((start == null) || (end == null) || (freq == null) || (roll == null)) continue;$$+$$+				Date [] 	dates	= GenerateSchedule (ToDate (start), ToDate (end),$$+						ToInterval (freq), DateRoll.ForName (ToToken (roll)), null);$$+$$+				XmlNodeList	nodes	= XPath.Paths (context, "observedRates", "observationDate");$$+$$+				foreach (XmlElement observed in nodes) {$$+					Date		date 	 = ToDate (observed);$$$$-					NodeList	nodes	= XPath.paths (context, "observedRates", "observationDate");$$-$$-					for (int count = 0; count < nodes.getLength(); ++count) {$$-						Element 	observed = (Element) nodes.item (count);$$-						Date		date 	 = toDate (observed);$$-$$-						boolean		found = false;$$-						for (int match = 0; match < dates.length; ++match) {$$-							if (equal (date, dates [match])) {$$-								found = true;$$-								break;$$-							}$$+					bool		found = false;$$+					foreach (Date match in dates) {$$+						if (Equal (date, match)) {$$+							found = true;$$+							break;$$}$$+					}$$+$$+					if (!found) {$$+						errorHandler ("305", observed,$$+								"Observation date '" + ToToken (observed) +$$+								"' does not match with the schedule.",$$+								name, ToToken (observed));$$$$-						if (!found) {$$-							errorHandler.error ("305", observed,$$-									"Observation date '" + Types.toString (observed) +$$-									"' does not match with a defined observationDate.",$$-									getName (), Types.toString(observed));$$-$$-							result = false;$$-						}$$+						result = false;$$}$$-					dates = null;$$}$$-$$-				return (result);$$+				dates = null;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures observationStartDate and observationEndDate$$-	 * both exist then observationStartDate <= observationEndDate.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE14$$-		= new Rule (Preconditions.R3_0__LATER, "fx-14")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXBarrier"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxBarrier"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule13 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxBarrier"), errorHandler));$$-			}$$+					  Rule13 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXAverageRateOption"), errorHandler)$$+					& Rule13 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxAverageRateOption"), errorHandler));$$+$$+			return ($$+				  Rule13 (name, nodeIndex.GetElementsByName ("fxAverageRateOption"), errorHandler));$$+		}$$+$$+		private static bool Rule13 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlNodeList	schedule	= XPath.Paths (context, "averageRateObservationDate", "observationDate");$$+				int			limit		= (schedule != null) ? schedule.Count : 0;$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		start	= XPath.path (context, "observationStartDate");$$-					Element		end		= XPath.path (context, "observationEndDate");$$+				if (limit == 0) continue;$$+$$+				Date []		dates	= new Date [limit];$$+$$+				for (int count = 0; count < limit; ++count)$$+					dates [count] = ToDate (schedule [count]);$$+$$+				XmlNodeList	nodes	= XPath.Paths (context, "observedRates", "observationDate");$$+$$+				foreach (XmlElement observed in nodes) {$$+					Date		date 	 = ToDate (observed);$$$$-					if ((start == null) || (end == null) ||$$-						lessOrEqual (toDate (start), toDate (end))) continue;$$-$$-					errorHandler.error ("305", context,$$-							"The observationStartDate must not be after the observationEndDate",$$-							getName (), null);$$+					bool		found = false;$$+					for (int match = 0; match < dates.Length; ++match) {$$+						if (Equal (date, dates [match])) {$$+							found = true;$$+							break;$$+						}$$+					}$$$$-					result = false;$$+					if (!found) {$$+						errorHandler ("305", observed,$$+								"Observation date '" + ToToken (observed) +$$+								"' does not match with a defined observationDate.",$$+								name, ToToken (observed));$$+$$+						result = false;$$+					}$$}$$-$$-				return (result);$$+				dates = null;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures spotRate is positive if it exists.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE15$$-		= new Rule (Preconditions.R3_0__LATER, "fx-15")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXBarrierOption"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxBarrierOption"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule14 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxBarrierOption"), errorHandler));$$-			}$$+					  Rule14 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXBarrier"), errorHandler)$$+					& Rule14 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxBarrier"), errorHandler));$$+$$+			return ($$+				  Rule14 (name, nodeIndex.GetElementsByName ("fxBarrier"), errorHandler));$$+		}$$+$$+		private static bool Rule14 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	start	= XPath.Path (context, "observationStartDate");$$+				XmlElement	end		= XPath.Path (context, "observationEndDate");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		rate	= XPath.path (context, "spotRate");$$-$$-					if ((rate == null) || isPositive (rate)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"The spot rate must be positive",$$-							getName (), Types.toString (rate));$$-$$-					result = false;$$-				}$$+				if ((start == null) || (end == null) ||$$+					LessOrEqual (ToDate (start), ToDate (end))) continue;$$+$$+				errorHandler ("305", context,$$+						"The observationStartDate must not be after the observationEndDate",$$+						name, null);$$$$-				return (result);$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * Context: FxDigitalOption (Complex Type)$$-	 * <P>$$-	 * A <CODE>Rule</CODE> that ensures spotRate is positive if it exists.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE16$$-		= new Rule (Preconditions.R3_0__LATER, "fx-16")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXDigitalOption"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxDigitalOption"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule15 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxDigitalOption"), errorHandler));$$-			}$$+					  Rule15 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXBarrierOption"), errorHandler)$$+					& Rule15 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxBarrierOption"), errorHandler));$$+$$+			return ($$+				  Rule15 (name, nodeIndex.GetElementsByName ("fxBarrierOption"), errorHandler));$$+		}$$+$$+		private static bool Rule15 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	rate	= XPath.Path (context, "spotRate");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		rate	= XPath.path (context, "spotRate");$$-$$-					if ((rate == null) || isPositive (rate)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"The spot rate must be positive",$$-							getName (), Types.toString (rate));$$-$$-					result = false;$$-				}$$+				if ((rate == null) || IsPositive (rate)) continue;$$+$$+				errorHandler ("305", context,$$+						"The spot rate must be positive",$$+						name, ToToken (rate));$$$$-				return (result);$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures triggerRate is positive.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE17$$-		= new Rule (Preconditions.R3_0__LATER, "fx-17")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXEuropeanTrigger"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxEuropeanTrigger"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule16 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxEuropeanTrigger"), errorHandler));$$-			}$$+					  Rule16 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXDigitalOption"), errorHandler)$$+					& Rule16 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxDigitalOption"), errorHandler));$$+$$+			return ($$+				  Rule16 (name, nodeIndex.GetElementsByName ("fxDigitalOption"), errorHandler));$$+		}$$+$$+		private static bool Rule16 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	rate	= XPath.Path (context, "spotRate");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		rate	= XPath.path (context, "triggerRate");$$-$$-					if ((rate == null) || isPositive (rate)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"The trigger rate must be positive",$$-							getName (), Types.toString (rate));$$-$$-					result = false;$$-				}$$+				if ((rate == null) || IsPositive (rate)) continue;$$+$$+				errorHandler ("305", context,$$+						"The spot rate must be positive",$$+						name, ToToken (rate));$$$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * Context>: FxLeg (Complex Type)$$-	 * <P>$$-	 * A <CODE>Rule</CODE> that ensures payer and reciever are correct.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule	RULE18$$-		= new Rule (Preconditions.R3_0__LATER, "fx-18")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXLeg"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxLeg"), errorHandler));$$-$$-				return ($$-					  validate (nodeIndex.getElementsByName ("fxSingleLeg"), errorHandler));$$+				result = false;$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$-$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		ccy1Pay	= XPath.path (context, "exchangedCurrency1", "payerPartyReference");$$-					Element		ccy1Rec	= XPath.path (context, "exchangedCurrency1", "receiverPartyReference");$$-					Element		ccy2Pay	= XPath.path (context, "exchangedCurrency2", "payerPartyReference");$$-					Element		ccy2Rec	= XPath.path (context, "exchangedCurrency2", "receiverPartyReference");$$-$$-					if ((ccy1Pay == null) || (ccy1Rec == null) ||$$-						(ccy2Pay == null) || (ccy2Rec == null)) continue;$$-$$-					if (equal (DOM.getAttribute(ccy1Pay, "href"), DOM.getAttribute(ccy2Rec, "href")) &&$$-						equal (DOM.getAttribute(ccy2Pay, "href"), DOM.getAttribute(ccy1Rec, "href"))) continue;$$-$$-					errorHandler.error ("305", context,$$-							"Exchanged currency payers and receivers don't match.",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule17 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return ($$+					  Rule17 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXEuropeanTrigger"), errorHandler)$$+					& Rule17 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxEuropeanTrigger"), errorHandler));$$$$-				return (result);$$+			return ($$+				  Rule17 (name, nodeIndex.GetElementsByName ("fxEuropeanTrigger"), errorHandler));$$+		}$$+$$+		private static bool Rule17 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement context in list) {$$+				XmlElement	rate	= XPath.Path (context, "triggerRate");$$+$$+				if ((rate == null) || IsPositive (rate)) continue;$$+$$+				errorHandler ("305", context,$$+						"The trigger rate must be positive",$$+						name, ToToken (rate));$$+$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * Context: FxLeg (Complex Type)$$-	 * <P>$$-	 * A <CODE>Rule</CODE> that ensures exchanged currencies are different.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule	RULE19$$-		= new Rule (Preconditions.R3_0__LATER, "fx-19")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXLeg"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxLeg"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule18 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxSingleLeg"), errorHandler));$$+					  Rule18 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXLeg"), errorHandler)$$+					& Rule18 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxLeg"), errorHandler));$$+$$+			return ($$+				  Rule18 (name, nodeIndex.GetElementsByName ("fxSingleLeg"), errorHandler));$$+		}$$+$$+		private static bool Rule18 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement context in list) {$$+				XmlElement	ccy1Pay	= XPath.Path (context, "exchangedCurrency1", "payerPartyReference");$$+				XmlElement	ccy1Rec	= XPath.Path (context, "exchangedCurrency1", "receiverPartyReference");$$+				XmlElement	ccy2Pay	= XPath.Path (context, "exchangedCurrency2", "payerPartyReference");$$+				XmlElement	ccy2Rec	= XPath.Path (context, "exchangedCurrency2", "receiverPartyReference");$$+$$+				if ((ccy1Pay == null) || (ccy1Rec == null) ||$$+					(ccy2Pay == null) || (ccy2Rec == null)) continue;$$+$$+				if (Equal (ccy1Pay.GetAttribute("href"), ccy2Rec.GetAttribute("href")) &&$$+					Equal (ccy2Pay.GetAttribute("href"), ccy1Rec.GetAttribute("href"))) continue;$$+$$+				errorHandler ("305", context,$$+						"Exchanged currency payers and receivers don't match.",$$+						name, null);$$+$$+				result = false;$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule19 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return ($$+					  Rule19 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXLeg"), errorHandler)$$+					& Rule19 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxLeg"), errorHandler));$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		ccy1	= XPath.path (context, "exchangedCurrency1", "paymentAmount", "currency");$$-					Element		ccy2	= XPath.path (context, "exchangedCurrency2", "paymentAmount", "currency");$$-$$-					if ((ccy1 == null) || (ccy2 == null)) continue;$$-$$-					// TODO check currency scheme as well$$-					if (notEqual (ccy1, ccy2)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"Exchanged currencies must be different.",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+			return ($$+				  Rule19 (name, nodeIndex.GetElementsByName ("fxSingleLeg"), errorHandler));$$+		}$$+$$+		private static bool Rule19 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement context in list) {$$+				XmlElement	ccy1	= XPath.Path (context, "exchangedCurrency1", "paymentAmount", "currency");$$+				XmlElement	ccy2	= XPath.Path (context, "exchangedCurrency2", "paymentAmount", "currency");$$+$$+				if ((ccy1 == null) || (ccy2 == null) || !IsSameCurrency (ccy1, ccy2)) continue;$$+$$+				errorHandler ("305", context,$$+						"Exchanged currencies must be different.",$$+						name, null);$$$$-				return (result);$$+				result = false;$$}$$-		};$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures split settlement dates are different.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule	RULE20$$-		= new Rule (Preconditions.R3_0__LATER, "fx-20")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXLeg"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxLeg"), errorHandler));$$-$$+		private static bool Rule20 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxSingleLeg"), errorHandler));$$-			}$$+					  Rule20 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXLeg"), errorHandler)$$+					& Rule20 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxLeg"), errorHandler));$$+$$+			return ($$+				  Rule20 (name, nodeIndex.GetElementsByName ("fxSingleLeg"), errorHandler));$$+		}$$+$$+		private static bool Rule20 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement	context in list) {$$+				XmlElement	date1	= XPath.Path (context, "currency1ValueDate");$$+				XmlElement	date2	= XPath.Path (context, "currency2ValueDate");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		date1	= XPath.path (context, "currency1ValueDate");$$-					Element		date2	= XPath.path (context, "currency2ValueDate");$$-$$-					if ((date1 == null) || (date2 == null)) continue;$$-$$-					if (notEqual (toDate (date1), toDate (date2))) continue;$$-$$-					errorHandler.error ("305", context,$$-							"currency1ValueDate and currency2ValueDate must be different.",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+				if ((date1 == null) || (date2 == null) ||$$+					NotEqual (ToDate (date1), ToDate (date2))) continue;$$+$$+				errorHandler ("305", context,$$+						"currency1ValueDate and currency2ValueDate must be different.",$$+						name, null);$$$$-				return (result);$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures non-deliverable forwards contains$$-	 * a specification of the forward points.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule	RULE21$$-		= new Rule (Preconditions.R3_0__LATER, "fx-21")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXLeg"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxLeg"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule21 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxSingleLeg"), errorHandler));$$-			}$$+					  Rule21 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXLeg"), errorHandler)$$+					& Rule21 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxLeg"), errorHandler));$$+$$+			return ($$+				  Rule21 (name, nodeIndex.GetElementsByName ("fxSingleLeg"), errorHandler));$$+		}$$+$$+		private static bool Rule21 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	ndf		= XPath.Path (context, "nonDeliverableForward");$$+				XmlElement	fwd		= XPath.Path (context, "exchangeRate", "forwardPoints");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		ndf		= XPath.path (context, "nonDeliverableForward");$$-					Element		fwd		= XPath.path (context, "exchangeRate", "forwardPoints");$$-$$-					if ((ndf == null) || (fwd != null)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"Non-deliverable forward does not specify forwardPoints.",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+				if ((ndf == null) || (fwd != null)) continue;$$+$$+				errorHandler ("305", context,$$+						"Non-deliverable forward does not specify forwardPoints.",$$+						name, null);$$$$-				return (result);$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures buyer, seller, payer and reciever are correct.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule	RULE22$$-		= new Rule (Preconditions.R3_0__LATER, "fx-22")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXOptionLeg"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxOptionLeg"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule22 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxSimpleOption"), errorHandler)$$-					& validate (nodeIndex.getElementsByName ("fxBarrierOption"), errorHandler));$$-			}$$+					  Rule22 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXOptionLeg"), errorHandler)$$+					& Rule22 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxOptionLeg"), errorHandler));$$+$$+			return ($$+				  Rule22 (name, nodeIndex.GetElementsByName ("fxSimpleOption"), errorHandler)$$+				& Rule22 (name, nodeIndex.GetElementsByName ("fxBarrierOption"), errorHandler));$$+		}$$+$$+		private static bool Rule22 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	buyer	 = XPath.Path (context, "buyerPartyReference");$$+				XmlElement	seller	 = XPath.Path (context, "sellerPartyReference");$$+				XmlElement	payer	 = XPath.Path (context, "fxOptionPremium", "payerPartyReference");$$+				XmlElement	receiver = XPath.Path (context, "fxOptionPremium", "receiverPartyReference");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context  = (Element) list.item (index);$$-					Element		buyer	 = XPath.path (context, "buyerPartyReference");$$-					Element		seller	 = XPath.path (context, "sellerPartyReference");$$-					Element		payer	 = XPath.path (context, "fxOptionPremium", "payerPartyReference");$$-					Element		receiver = XPath.path (context, "fxOptionPremium", "receiverPartyReference");$$-$$-					if ((buyer == null) || (seller == null) ||$$-						(payer == null) || (receiver == null)) continue;$$-$$-					if (equal (DOM.getAttribute(buyer, "href"), DOM.getAttribute(payer, "href")) &&$$-						equal (DOM.getAttribute(seller, "href"), DOM.getAttribute(receiver, "href"))) continue;$$-$$-					errorHandler.error ("305", context,$$-							"Premium payer and receiver don't match with option buyer and seller.",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+				if ((buyer == null) || (seller == null) ||$$+					(payer == null) || (receiver == null)) continue;$$+$$+				if (Equal (buyer.GetAttribute("href"), payer.GetAttribute("href")) &&$$+					Equal (seller.GetAttribute("href"), receiver.GetAttribute("href"))) continue;$$+$$+				errorHandler ("305", context,$$+						"Premium payer and receiver don't match with option buyer and seller.",$$+						name, null);$$$$-				return (result);$$+				result = false;$$}$$-		};$$+$$+			return (result);$$+		}$$$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures the put and call currencies are different.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule	RULE23$$-		= new Rule (Preconditions.R3_0__LATER, "fx-23")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXOptionLeg"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxOptionLeg"), errorHandler));$$-$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule23 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxSimpleOption"), errorHandler)$$-					& validate (nodeIndex.getElementsByName ("fxBarrierOption"), errorHandler));$$-			}$$+					  Rule23 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXOptionLeg"), errorHandler)$$+					& Rule23 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxOptionLeg"), errorHandler));$$+$$+			return ($$+				  Rule23 (name, nodeIndex.GetElementsByName ("fxSimpleOption"), errorHandler)$$+				& Rule23 (name, nodeIndex.GetElementsByName ("fxBarrierOption"), errorHandler));$$+		}$$+$$+		private static bool Rule23 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	ccy1	= XPath.Path (context, "putCurrencyAmount", "currency");$$+				XmlElement	ccy2	= XPath.Path (context, "callCurrencyAmount", "currency");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		ccy1	= XPath.path (context, "putCurrencyAmount", "currency");$$-					Element		ccy2	= XPath.path (context, "callCurrencyAmount", "currency");$$-$$-					if ((ccy1 == null) || (ccy2 == null)) continue;$$-$$-					// TODO check currency scheme as well$$-					if (notEqual (ccy1, ccy2)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"Put and call currencies must be different.",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+				if ((ccy1 == null) || (ccy2 == null) || !IsSameCurrency (ccy1, ccy2)) continue;$$+$$+				errorHandler ("305", context,$$+						"Put and call currencies must be different.",$$+						name, null);$$$$-				return (result);$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures rate is positive.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE24$$-		= new Rule (Preconditions.R3_0__LATER, "fx-24")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXStrikePrice"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxStrikePrice"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule24 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxStrikePrice"), errorHandler));$$-			}$$+					  Rule24 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXStrikePrice"), errorHandler)$$+					& Rule24 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxStrikePrice"), errorHandler));$$+$$+			return ($$+				  Rule24 (name, nodeIndex.GetElementsByName ("fxStrikePrice"), errorHandler));$$+		}$$+$$+		private static bool Rule24 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	rate	= XPath.Path (context, "rate");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		rate	= XPath.path (context, "rate");$$-$$-					if ((rate == null) || isPositive (rate)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"The rate must be positive",$$-							getName (), Types.toString (rate));$$-$$-					result = false;$$-				}$$+				if ((rate == null) || IsPositive (rate)) continue;$$+$$+				errorHandler ("305", context,$$+						"The rate must be positive",$$+						name, ToToken (rate));$$$$-				return (result);$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * Context: FxSwap (Complex Type)$$-	 * <P>$$-	 * A <CODE>Rule</CODE> that ensures two or more legs are present.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE25$$-		= new Rule (Preconditions.R3_0__LATER, "fx-25")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXSwap"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxSwap"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule25 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxSwap"), errorHandler));$$-			}$$+					  Rule25 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXSwap"), errorHandler)$$+					& Rule25 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxSwap"), errorHandler));$$+$$+			return ($$+				  Rule25 (name, nodeIndex.GetElementsByName ("fxSwap"), errorHandler));$$+		}$$+$$+		private static bool Rule25 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlNodeList	legs	= XPath.Paths (context, "fxSingleLeg");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					NodeList	legs	= XPath.paths (context, "fxSingleLeg");$$-$$-					if (count (legs) >= 2) continue;$$-$$-					errorHandler.error ("305", context,$$-							"FX swaps must have at least two legs.",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+				if (Count (legs) >= 2) continue;$$+$$+				errorHandler ("305", context,$$+						"FX swaps must have at least two legs.",$$+						name, null);$$$$-				return (result);$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures if two legs are present they must have$$-	 * different value dates.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE26$$-		= new Rule (Preconditions.R3_0__LATER, "fx-26")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXSwap"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxSwap"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule26 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxSwap"), errorHandler));$$-			}$$+					  Rule26 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXSwap"), errorHandler)$$+					& Rule26 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxSwap"), errorHandler));$$+$$+			return ($$+				  Rule26 (name, nodeIndex.GetElementsByName ("fxSwap"), errorHandler));$$+		}$$+$$+		private static bool Rule26 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlNodeList	legs	= XPath.Paths (context, "fxSingleLeg");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					NodeList	legs	= XPath.paths (context, "fxSingleLeg");$$-$$-					if (count (legs) != 2) continue;$$-$$-					Element 	date1	= XPath.path ((Element) legs.item (0), "valueDate");$$-					Element 	date2	= XPath.path ((Element) legs.item (1), "valueDate");$$-$$-					if (notEqual (toDate (date1), toDate (date2))) continue;$$-$$-					errorHandler.error ("305", context,$$-							"FX swaps legs must settle on different days.",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+				if (Count (legs) != 2) continue;$$$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures two different currencies are specified.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule	RULE27$$-		= new Rule (Preconditions.R3_0__LATER, "fx-27")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "QuotedCurrencyPair"), errorHandler));$$-$$-				return ($$-					  validate (nodeIndex.getElementsByName ("quotedCurrencyPair"), errorHandler));$$+				XmlElement 	date1	= XPath.Path (legs [0] as XmlElement, "valueDate");$$+				XmlElement 	date2	= XPath.Path (legs [1] as XmlElement, "valueDate");$$+$$+				if (NotEqual (ToDate (date1), ToDate (date2))) continue;$$+$$+				errorHandler ("305", context,$$+						"FX swaps legs must settle on different days.",$$+						name, null);$$+$$+				result = false;$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule27 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule27 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "QuotedCurrencyPair"), errorHandler));$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		ccy1	= XPath.path (context, "currency1");$$-					Element		ccy2	= XPath.path (context, "currency2");$$-$$-					if ((ccy1 == null) || (ccy2 == null)) continue;$$-$$-					// TODO check currency scheme as well$$-					if (notEqual (ccy1, ccy2)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"Currencies must be different.",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+			return ($$+				  Rule27 (name, nodeIndex.GetElementsByName ("quotedCurrencyPair"), errorHandler));$$+		}$$+$$+		private static bool Rule27 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement	context in list) {$$+				XmlElement	ccy1	= XPath.Path (context, "currency1");$$+				XmlElement	ccy2	= XPath.Path (context, "currency2");$$$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures triggerRate is positive.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE28$$-		= new Rule (Preconditions.R3_0__LATER, "fx-28")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "SideRate"), errorHandler));$$-$$-				return ($$-					  validate (nodeIndex.getElementsByName ("currency1SideRate"), errorHandler)$$-					& validate (nodeIndex.getElementsByName ("currency2SideRate"), errorHandler));$$+				if ((ccy1 == null) || (ccy2 == null) || !IsSameCurrency (ccy1, ccy2)) continue;$$+$$+				errorHandler ("305", context,$$+						"Currencies must be different.",$$+						name, null);$$+$$+				result = false;$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			return (result);$$+		}$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		rate	= XPath.path (context, "rate");$$-$$-					if ((rate == null) || isPositive (rate)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"The rate must be positive",$$-							getName (), Types.toString (rate));$$-$$-					result = false;$$-				}$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule28 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule28 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "SideRate"), errorHandler));$$$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures that if forwardPoints exists then$$-	 * spotRate should also exist.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE29$$-		= new Rule (Preconditions.R3_0__LATER, "fx-29")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "SideRate"), errorHandler));$$-$$-				return ($$-					  validate (nodeIndex.getElementsByName ("currency1SideRate"), errorHandler)$$-					& validate (nodeIndex.getElementsByName ("currency2SideRate"), errorHandler));$$-			}$$+			return ($$+				  Rule28 (name, nodeIndex.GetElementsByName ("currency1SideRate"), errorHandler)$$+				& Rule28 (name, nodeIndex.GetElementsByName ("currency2SideRate"), errorHandler));$$+		}$$+$$+		private static bool Rule28 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement		rate	= XPath.Path (context, "rate");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element 	forward = XPath.path (context, "forwardPoints");$$-					Element		spot	= XPath.path (context, "spotRate");$$-$$-					if (!((forward != null) && (spot == null))) continue;$$-$$-					errorHandler.error ("305", context,$$-							"If forwardPoints exists then spotRate should also exist.",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+				if ((rate == null) || IsPositive (rate)) continue;$$+$$+				errorHandler ("305", context,$$+						"The rate must be positive",$$+						name, ToToken (rate));$$$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures that if both forwardPoints and spotRate$$-	 * exist then rate equals 'spotRate + forwardRate'.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE30$$-		= new Rule (Preconditions.R3_0__LATER, "fx-30")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "SideRate"), errorHandler));$$-$$-				return ($$-						  validate (nodeIndex.getElementsByName ("currency1SideRate"), errorHandler)$$-						& validate (nodeIndex.getElementsByName ("currency2SideRate"), errorHandler));$$+				result = false;$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule29 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule29 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "SideRate"), errorHandler));$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element 	forward = XPath.path (context, "forwardPoints");$$-					Element		spot	= XPath.path (context, "spotRate");$$-					Element		rate	= XPath.path (context, "rate");$$-$$-					if ((rate == null) || (forward == null) || (spot == null)) continue;$$-$$-					if (toDecimal (rate).equals(toDecimal (spot).add (toDecimal (forward))))$$-						continue;$$-$$-					errorHandler.error ("305", context,$$-							"Sum of spotRate and forwardPoints does not equal rate.",$$-							getName (), Types.toString (rate));$$-$$-					result = false;$$-				}$$+			return ($$+				  Rule29 (name, nodeIndex.GetElementsByName ("currency1SideRate"), errorHandler)$$+				& Rule29 (name, nodeIndex.GetElementsByName ("currency2SideRate"), errorHandler));$$+		}$$+$$+		private static bool Rule29 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement context in list) {$$+				XmlElement 	forward = XPath.Path (context, "forwardPoints");$$+				XmlElement	spot	= XPath.Path (context, "spotRate");$$$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures that side rates are obtained relative$$-	 * to another currency.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE31$$-		= new Rule (Preconditions.R3_0__LATER, "fx-31")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "SideRates"), errorHandler));$$-$$-				return ($$-						  validate (nodeIndex.getElementsByName ("sideRates"), errorHandler));$$+				if (!((forward != null) && (spot == null))) continue;$$+$$+				errorHandler ("305", context,$$+						"If forwardPoints exists then spotRate should also exist.",$$+						name, null);$$+$$+				result = false;$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule30 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule30 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "SideRate"), errorHandler));$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element 	base 	= XPath.path (context, "baseCurrency");$$-					Element		ccy1	= XPath.path (context, "currency1SideRate", "currency");$$-					Element		ccy2	= XPath.path (context, "currency2SideRate", "currency");$$-$$-					if ((base == null) || (ccy1 == null) || (ccy2 == null)) continue;$$-$$-					// TODO handle currency scheme$$-					if (notEqual (base, ccy1) && notEqual (base, ccy2)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"The base currency must be different from the side rate currencies.",$$-							getName (), Types.toString (base));$$-$$-					result = false;$$-				}$$+			return ($$+					  Rule30 (name, nodeIndex.GetElementsByName ("currency1SideRate"), errorHandler)$$+					& Rule30 (name, nodeIndex.GetElementsByName ("currency2SideRate"), errorHandler));$$+		}$$+$$+		private static bool Rule30 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement context in list) {$$+				XmlElement 	forward = XPath.Path (context, "forwardPoints");$$+				XmlElement	spot	= XPath.Path (context, "spotRate");$$+				XmlElement	rate	= XPath.Path (context, "rate");$$+$$+				if ((rate == null) || (forward == null) || (spot == null)) continue;$$+$$+				if (ToDecimal (rate).Equals(ToDecimal (spot) + ToDecimal (forward)))$$+					continue;$$+$$+				errorHandler ("305", context,$$+						"Sum of spotRate and forwardPoints does not equal rate.",$$+						name, ToToken (rate));$$$$-				return (result);$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures the initial payer and reciever$$-	 * are different.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE33$$-		= new Rule (Preconditions.R4_0__LATER, "fx-33")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "TermDeposit"), errorHandler));$$-$$-				return ($$-						  validate (nodeIndex.getElementsByName ("termDeposit"), errorHandler));$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule31 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule31 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "SideRates"), errorHandler));$$+$$+			return ($$+					  Rule31 (name, nodeIndex.GetElementsByName ("sideRates"), errorHandler));$$+		}$$+$$+		private static bool Rule31 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement context in list) {$$+				XmlElement 	baseCcy	= XPath.Path (context, "baseCurrency");$$+				XmlElement	ccy1	= XPath.Path (context, "currency1SideRate", "currency");$$+				XmlElement	ccy2	= XPath.Path (context, "currency2SideRate", "currency");$$+$$+				if ((baseCcy == null) || (ccy1 == null) || (ccy2 == null) ||$$+					(!IsSameCurrency (baseCcy, ccy1) && !IsSameCurrency (baseCcy, ccy2))) continue;$$+$$+				errorHandler ("305", context,$$+						"The base currency must be different from the side rate currencies.",$$+						name, ToToken (baseCcy));$$+$$+				result = false;$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule32 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule32 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "TermDeposit"), errorHandler));$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		payer	 = XPath.path (context, "initialPayerReference");$$-					Element		receiver = XPath.path (context, "initialReceiverReference");$$-$$-					if ((payer == null) || (receiver == null)) continue;$$+			return ($$+					  Rule32 (name, nodeIndex.GetElementsByName ("termDeposit"), errorHandler));$$+		}$$+$$+		private static bool Rule32 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement context in list) {$$+				XmlElement	payer	 = XPath.Path (context, "initialPayerReference");$$+				XmlElement	receiver = XPath.Path (context, "initialReceiverReference");$$+$$+				if ((payer == null) || (receiver == null)) continue;$$$$-					if (notEqual (DOM.getAttribute(payer, "href"),$$-								  DOM.getAttribute(receiver, "href"))) continue;$$-$$-					errorHandler.error ("305", context,$$-							"The initial payer and receiver must be different",$$-							getName (), DOM.getAttribute (payer, "href"));$$-$$-					result = false;$$-				}$$+				if (NotEqual (payer.GetAttribute ("href"),$$+							  receiver.GetAttribute ("href"))) continue;$$$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures the maturity date is after the start date.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE34$$-		= new Rule (Preconditions.R4_0__LATER, "fx-34")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "TermDeposit"), errorHandler));$$-$$-				return ($$-						  validate (nodeIndex.getElementsByName ("termDeposit"), errorHandler));$$+				errorHandler ("305", context,$$+						"The initial payer and receiver must be different",$$+						name, payer.GetAttribute ("href"));$$+$$+				result = false;$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule33 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule33 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "TermDeposit"), errorHandler));$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		start	 = XPath.path (context, "startDate");$$-					Element		maturity = XPath.path (context, "maturityDate");$$-$$-					if ((start == null) || (maturity == null) ||$$-						less (toDate (start), toDate (maturity))) continue;$$-$$-					errorHandler.error ("305", context,$$-							"The maturity date must be after the start date",$$-							getName (), Types.toString (maturity));$$-$$-					result = false;$$-				}$$+			return ($$+					  Rule33 (name, nodeIndex.GetElementsByName ("termDeposit"), errorHandler));$$+		}$$+$$+		private static bool Rule33 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement context in list) {$$+				XmlElement	start	 = XPath.Path (context, "startDate");$$+				XmlElement	maturity = XPath.Path (context, "maturityDate");$$$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures the principal amount is positive.$$-	 * are different.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE35$$-		= new Rule (Preconditions.R4_0__LATER, "fx-35")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "TermDeposit"), errorHandler));$$-$$-				return ($$-						  validate (nodeIndex.getElementsByName ("termDeposit"), errorHandler));$$+				if ((start == null) || (maturity == null) ||$$+					Less (ToDate (start), ToDate (maturity))) continue;$$+$$+				errorHandler ("305", context,$$+						"The maturity date must be after the start date",$$+						name, ToToken (maturity));$$+$$+				result = false;$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			return (result);$$+		}$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		amount	= XPath.path (context, "principal", "amount");$$-$$-					if ((amount == null) || isPositive (amount)) continue;$$+		// --------------------------------------------------------------------$$$$-					errorHandler.error ("305", context,$$-							"The principal amount must be positive",$$-							getName (), Types.toString (amount));$$-$$-					result = false;$$-				}$$+		private static bool Rule34 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule34 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "TermDeposit"), errorHandler));$$$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures the fixed rate is positive.$$-	 * are different.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE36$$-		= new Rule (Preconditions.R4_0__LATER, "fx-36")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "TermDeposit"), errorHandler));$$-$$-				return ($$-						  validate (nodeIndex.getElementsByName ("termDeposit"), errorHandler));$$-			}$$+			return ($$+					  Rule34 (name, nodeIndex.GetElementsByName ("termDeposit"), errorHandler));$$+		}$$+$$+		private static bool Rule34 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	amount	= XPath.Path (context, "principal", "amount");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		rate	= XPath.path (context, "fixedRate");$$-$$-					if ((rate == null) || isPositive (rate)) continue;$$+				if ((amount == null) || IsPositive (amount)) continue;$$$$-					errorHandler.error ("305", context,$$-							"The fixed rate must be positive",$$-							getName (), Types.toString (rate));$$-$$-					result = false;$$-				}$$+				errorHandler ("305", context,$$+						"The principal amount must be positive",$$+						name, ToToken (amount));$$$$-				return (result);$$+				result = false;$$}$$-		};$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule35 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule35 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "TermDeposit"), errorHandler));$$+$$+			return ($$+					  Rule35 (name, nodeIndex.GetElementsByName ("termDeposit"), errorHandler));$$+		}$$$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures expiry date is after trade date.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule	RULE37$$-		= new Rule (Preconditions.R3_0__LATER, "fx-37")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "Trade"), errorHandler));$$-$$-				return ($$-					  validate (nodeIndex.getElementsByName ("trade"), errorHandler));$$+		private static bool Rule35 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement	context in list) {$$+				XmlElement	rate	= XPath.Path (context, "fixedRate");$$+$$+				if ((rate == null) || IsPositive (rate)) continue;$$+$$+				errorHandler ("305", context,$$+						"The fixed rate must be positive",$$+						name, ToToken (rate));$$+$$+				result = false;$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule36 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule36 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "Trade"), errorHandler));$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context  = (Element) list.item (index);$$-					Element		tradeDate	 = XPath.path (context, "tradeHeader", "tradeDate");$$-					Element		expiryDate	 = XPath.path (context, "fxAverageRateOption", "expiryDateTime", "expiryDate");$$-$$-					if ((tradeDate == null) || (expiryDate == null)) continue;$$-$$-					if (less (tradeDate, expiryDate)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"Expiry date must be after trade date.",$$-							getName (), Types.toString (expiryDate));$$-$$-					result = false;$$-				}$$+			return ($$+				  Rule36 (name, nodeIndex.GetElementsByName ("trade"), errorHandler));$$+		}$$+$$+		private static bool Rule36 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement context in list) {$$+				XmlElement	tradeDate	 = XPath.Path (context, "tradeHeader", "tradeDate");$$+				XmlElement	expiryDate	 = XPath.Path (context, "fxAverageRateOption", "expiryDateTime", "expiryDate");$$$$-				return (result);$$+				if ((tradeDate == null) || (expiryDate == null)) continue;$$+$$+				if (Less (ToDate (tradeDate), ToDate (expiryDate))) continue;$$+$$+				errorHandler ("305", context,$$+						"Expiry date must be after trade date.",$$+						name, ToToken (expiryDate));$$+$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures expiry date is after trade date.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule	RULE38$$-		= new Rule (Preconditions.R3_0__LATER, "fx-38")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "Trade"), errorHandler));$$+$$+			return (result);$$+		}$$$$-				return ($$-					  validate (nodeIndex.getElementsByName ("trade"), errorHandler));$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule37 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule37 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "Trade"), errorHandler));$$+$$+			return ($$+				  Rule37 (name, nodeIndex.GetElementsByName ("trade"), errorHandler));$$+		}$$+$$+		private static bool Rule37 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement context in list) {$$+				XmlElement	tradeDate	 = XPath.Path (context, "tradeHeader", "tradeDate");$$+				XmlElement	expiryDate	 = XPath.Path (context, "fxBarrierOption", "expiryDateTime", "expiryDate");$$+$$+				if ((tradeDate == null) || (expiryDate == null)) continue;$$+$$+				if (Less (ToDate (tradeDate), ToDate (expiryDate))) continue;$$+$$+				errorHandler ("305", context,$$+						"Expiry date must be after trade date.",$$+						name, ToToken (expiryDate));$$+$$+				result = false;$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule38 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule38 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "Trade"), errorHandler));$$+$$+			return ($$+				  Rule38 (name, nodeIndex.GetElementsByName ("trade"), errorHandler));$$+		}$$+$$+		private static bool Rule38 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement context in list) {$$+				XmlElement	tradeDate	 = XPath.Path (context, "tradeHeader", "tradeDate");$$+				XmlElement	expiryDate	 = XPath.Path (context, "fxDigitalOption", "expiryDateTime", "expiryDate");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context  = (Element) list.item (index);$$-					Element		tradeDate	 = XPath.path (context, "tradeHeader", "tradeDate");$$-					Element		expiryDate	 = XPath.path (context, "fxBarrierOption", "expiryDateTime", "expiryDate");$$-$$-					if ((tradeDate == null) || (expiryDate == null)) continue;$$-$$-					if (less (tradeDate, expiryDate)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"Expiry date must be after trade date.",$$-							getName (), Types.toString (expiryDate));$$-$$-					result = false;$$-				}$$+				if ((tradeDate == null) || (expiryDate == null)) continue;$$$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures expiry date is after trade date.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule	RULE39$$-		= new Rule (Preconditions.R3_0__LATER, "fx-39")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "Trade"), errorHandler));$$-$$-				return ($$-					  validate (nodeIndex.getElementsByName ("trade"), errorHandler));$$+				if (Less (ToDate (tradeDate), ToDate (expiryDate))) continue;$$+$$+				errorHandler ("305", context,$$+						"Expiry date must be after trade date.",$$+						name, ToToken (expiryDate));$$+$$+				result = false;$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$-$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context  = (Element) list.item (index);$$-					Element		tradeDate	 = XPath.path (context, "tradeHeader", "tradeDate");$$-					Element		expiryDate	 = XPath.path (context, "fxDigitalOption", "expiryDateTime", "expiryDate");$$-$$-					if ((tradeDate == null) || (expiryDate == null)) continue;$$-$$-					if (less (tradeDate, expiryDate)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"Expiry date must be after trade date.",$$-							getName (), Types.toString (expiryDate));$$-$$-					result = false;$$-				}$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule39 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule39 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "Trade"), errorHandler));$$$$-				return (result);$$-			}$$-		};$$+			return ($$+				  Rule39 (name, nodeIndex.GetElementsByName ("trade"), errorHandler));$$+		}$$+$$+		private static bool Rule39 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement context in list) {$$+				XmlElement	tradeDate = XPath.Path (context, "tradeHeader", "tradeDate");$$+				XmlElement	valueDate = XPath.Path (context, "fxSingleLeg", "valueDate");$$+				XmlElement	value1Date = XPath.Path (context, "fxSingleLeg", "currency1ValueDate");$$+				XmlElement	value2Date = XPath.Path (context, "fxSingleLeg", "currency2ValueDate");$$+$$+				if (tradeDate != null) {$$+					if (valueDate != null) {$$+						if (Less (ToDate (tradeDate), ToDate (valueDate))) continue;$$$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures value date is after trade date.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule	RULE40$$-		= new Rule (Preconditions.R3_0__LATER, "fx-40")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "Trade"), errorHandler));$$+						errorHandler ("305", context,$$+								"value date must be after trade date.",$$+								name, ToToken (valueDate));$$+$$+						result = false;$$+					}$$$$-				return ($$-					  validate (nodeIndex.getElementsByName ("trade"), errorHandler));$$+					if (value1Date != null) {$$+						if (Less (ToDate (tradeDate), ToDate (value1Date))) continue;$$+$$+						errorHandler ("305", context,$$+								"value1date must be after trade date.",$$+								name, ToToken (value1Date));$$+$$+						result = false;$$+					}$$+$$+					if (value2Date != null) {$$+						if (Less (ToDate (tradeDate), ToDate (value2Date))) continue;$$+$$+						errorHandler ("305", context,$$+								"value2date must be after trade date.",$$+								name, ToToken (value2Date));$$+$$+						result = false;$$+					}$$+				}$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule40 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule40 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "Trade"), errorHandler));$$+$$+			return ($$+				  Rule40 (name, nodeIndex.GetElementsByName ("trade"), errorHandler));$$+		}$$+$$+		private static bool Rule40 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$+$$+			foreach (XmlElement context in list) {$$+				XmlElement	tradeDate 	= XPath.Path (context, "tradeHeader", "tradeDate");$$+				XmlNodeList	legs	  	= XPath.Paths (context, "fxSwap", "fxSingleLeg");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context  = (Element) list.item (index);$$-					Element		tradeDate = XPath.path (context, "tradeHeader", "tradeDate");$$-					Element		valueDate = XPath.path (context, "fxSingleLeg", "valueDate");$$-					Element		value1Date = XPath.path (context, "fxSingleLeg", "currency1ValueDate");$$-					Element		value2Date = XPath.path (context, "fxSingleLeg", "currency2ValueDate");$$+				foreach (XmlElement leg in legs) {$$+					XmlElement	valueDate 	= XPath.Path (leg, "valueDate");$$+					XmlElement	value1Date 	= XPath.Path (leg, "currency1ValueDate");$$+					XmlElement	value2Date 	= XPath.Path (leg, "currency2ValueDate");$$$$if (tradeDate != null) {$$if (valueDate != null) {$$-							if (less (toDate (tradeDate), toDate (valueDate))) continue;$$+							if (Less (ToDate (tradeDate), ToDate (valueDate))) continue;$$$$-							errorHandler.error ("305", context,$$+							errorHandler ("305", leg,$$"value date must be after trade date.",$$-									getName (), Types.toString (valueDate));$$+									name, ToToken (valueDate));$$$$result = false;$$}$$$$if (value1Date != null) {$$-							if (less (toDate (tradeDate), toDate (value1Date))) continue;$$+							if (Less (ToDate (tradeDate), ToDate (value1Date))) continue;$$$$-							errorHandler.error ("305", context,$$-									"value date must be after trade date.",$$-									getName (), Types.toString (value1Date));$$+							errorHandler ("305", leg,$$+									"value1date must be after trade date.",$$+									name, ToToken (value1Date));$$$$result = false;$$}$$$$if (value2Date != null) {$$-							if (less (toDate (tradeDate), toDate (value2Date))) continue;$$+							if (Less (ToDate (tradeDate), ToDate (value2Date))) continue;$$$$-							errorHandler.error ("305", context,$$-									"value date must be after trade date.",$$-									getName (), Types.toString (value2Date));$$+							errorHandler ("305", leg,$$+									"value2date must be after trade date.",$$+									name, ToToken (value2Date));$$$$result = false;$$}$$}$$}$$-$$-				return (result);$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures all FX swap value dates are after the$$-	 * trade date.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule	RULE41$$-		= new Rule (Preconditions.R3_0__LATER, "fx-41")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "Trade"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule41 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("trade"), errorHandler));$$-			}$$+					  Rule41 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXBarrier"), errorHandler)$$+					& Rule41 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxBarrier"), errorHandler));$$+$$+			return ($$+				  Rule41 (name, nodeIndex.GetElementsByName ("fxBarrier"), errorHandler));$$+		}$$+$$+		private static bool Rule41 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	rate	= XPath.Path (context, "triggerRate");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context  	= (Element) list.item (index);$$-					Element		tradeDate 	= XPath.path (context, "tradeHeader", "tradeDate");$$-					NodeList	legs	  	= XPath.paths (context, "fxSwap", "fxSingleLeg");$$-$$-					for (int count = 0; count < legs.getLength(); ++count) {$$-						Element		leg			= (Element) legs.item (count);$$-						Element		valueDate 	= XPath.path (leg, "valueDate");$$-						Element		value1Date 	= XPath.path (leg, "currency1ValueDate");$$-						Element		value2Date 	= XPath.path (leg, "currency2ValueDate");$$-$$-						if (tradeDate != null) {$$-							if (valueDate != null) {$$-								if (less (toDate (tradeDate), toDate (valueDate))) continue;$$-$$-								errorHandler.error ("305", leg,$$-										"value date must be after trade date.",$$-										getName (), Types.toString (valueDate));$$-$$-								result = false;$$-							}$$-$$-							if (value1Date != null) {$$-								if (less (toDate (tradeDate), toDate (value1Date))) continue;$$-$$-								errorHandler.error ("305", leg,$$-										"value date must be after trade date.",$$-										getName (), Types.toString (value1Date));$$-$$-								result = false;$$-							}$$-$$-							if (value2Date != null) {$$-								if (less (toDate (tradeDate), toDate (value2Date))) continue;$$-$$-								errorHandler.error ("305", leg,$$-										"value date must be after trade date.",$$-										getName (), Types.toString (value2Date));$$-$$-								result = false;$$-							}$$-						}$$-					}$$-				}$$+				if ((rate == null) || IsPositive (rate)) continue;$$+$$+				errorHandler ("305", context,$$+						"The trigger rate must be positive",$$+						name, ToToken (rate));$$$$-				return (result);$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures triggerRate is positive.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE42$$-		= new Rule (Preconditions.R3_0__LATER, "fx-42")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXBarrier"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxBarrier"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule42 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxBarrier"), errorHandler));$$-			}$$+					  Rule42 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXAverageRateOption"), errorHandler)$$+					& Rule42 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxAverageRateOption"), errorHandler));$$+$$+			return ($$+				  Rule42 (name, nodeIndex.GetElementsByName ("fxAverageRateOption"), errorHandler));$$+		}$$+$$+		private static bool Rule42 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlNodeList	nodes	= XPath.Paths (context, "averageRateObservationDate", "observationDate");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		rate	= XPath.path (context, "triggerRate");$$-$$-					if ((rate == null) || isPositive (rate)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"The trigger rate must be positive",$$-							getName (), Types.toString (rate));$$-$$-					result = false;$$-				}$$+				int			limit	= nodes.Count;$$+				Date []		dates	= new Date [limit];$$$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures each averageRateObservationDate/observationDate$$-	 * is unique.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE43$$-		= new Rule (Preconditions.R3_0__LATER, "fx-43")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXAverageRateOption"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxAverageRateOption"), errorHandler));$$-$$-				return ($$-					  validate (nodeIndex.getElementsByName ("fxAverageRateOption"), errorHandler));$$-			}$$-$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+				for (int count = 0; count < limit; ++count)$$+					dates [count] = ToDate (nodes [count]);$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					NodeList	nodes	= XPath.paths (context, "averageRateObservationDate", "observationDate");$$-$$-					int			limit	= nodes.getLength ();$$-					Date []		dates	= new Date [limit];$$-$$-					for (int count = 0; count < limit; ++count)$$-						dates [count] = toDate (nodes.item(count));$$-$$-					for (int outer = 0; outer < (limit - 1); ++outer) {$$-						for (int inner = outer + 1; inner < limit; ++inner) {$$-							if (equal (dates [outer], dates [inner]))$$-								errorHandler.error ("305", nodes.item (inner),$$-										"Duplicate observation date",$$-										getName (), Types.toString(nodes.item (inner)));$$-$$-							result = false;$$-						}$$+				for (int outer = 0; outer < (limit - 1); ++outer) {$$+					for (int inner = outer + 1; inner < limit; ++inner) {$$+						if (Equal (dates [outer], dates [inner]))$$+							errorHandler ("305", nodes [inner],$$+									"Duplicate observation date",$$+									name, ToToken (nodes [inner]));$$+$$+						result = false;$$}$$-					dates = null;$$}$$-$$-				return (result);$$+				dates = null;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures the put and call currencies are different.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule	RULE44$$-		= new Rule (Preconditions.R3_0__LATER, "fx-44")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXAverageRateOption"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxAverageRateOption"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule43 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxAverageRateOption"), errorHandler));$$-			}$$+					  Rule43 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXAverageRateOption"), errorHandler)$$+					& Rule43 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxAverageRateOption"), errorHandler));$$+$$+			return ($$+				  Rule43 (name, nodeIndex.GetElementsByName ("fxAverageRateOption"), errorHandler));$$+		}$$+$$+		private static bool Rule43 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	ccy1	= XPath.Path (context, "putCurrencyAmount", "currency");$$+				XmlElement	ccy2	= XPath.Path (context, "callCurrencyAmount", "currency");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		ccy1	= XPath.path (context, "putCurrencyAmount", "currency");$$-					Element		ccy2	= XPath.path (context, "callCurrencyAmount", "currency");$$-$$-					if ((ccy1 == null) || (ccy2 == null)) continue;$$-$$-					// TODO check currency scheme as well$$-					if (notEqual (ccy1, ccy2)) continue;$$-$$-					errorHandler.error ("305", context,$$-							"Put and call currencies must be different.",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+				if ((ccy1 == null) || (ccy2 == null) || !IsSameCurrency (ccy1, ccy2)) continue;$$+$$+				errorHandler ("305", context,$$+						"Put and call currencies must be different.",$$+						name, null);$$$$-				return (result);$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures buyer, seller, payer and reciever are correct.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule	RULE45$$-		= new Rule (Preconditions.R3_0__LATER, "fx-45")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXAverageRateOption"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxAverageRateOption"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule44 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxAverageRateOption"), errorHandler));$$-			}$$+					  Rule44 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXAverageRateOption"), errorHandler)$$+					& Rule44 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxAverageRateOption"), errorHandler));$$+$$+			return ($$+				  Rule44 (name, nodeIndex.GetElementsByName ("fxAverageRateOption"), errorHandler));$$+		}$$+$$+		private static bool Rule44 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	buyer	 = XPath.Path (context, "buyerPartyReference");$$+				XmlElement	seller	 = XPath.Path (context, "sellerPartyReference");$$+				XmlElement	payer	 = XPath.Path (context, "fxOptionPremium", "payerPartyReference");$$+				XmlElement	receiver = XPath.Path (context, "fxOptionPremium", "receiverPartyReference");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context  = (Element) list.item (index);$$-					Element		buyer	 = XPath.path (context, "buyerPartyReference");$$-					Element		seller	 = XPath.path (context, "sellerPartyReference");$$-					Element		payer	 = XPath.path (context, "fxOptionPremium", "payerPartyReference");$$-					Element		receiver = XPath.path (context, "fxOptionPremium", "receiverPartyReference");$$-$$-					if ((buyer == null) || (seller == null) ||$$-						(payer == null) || (receiver == null)) continue;$$-$$-					if (equal (DOM.getAttribute(buyer, "href"), DOM.getAttribute(payer, "href")) &&$$-						equal (DOM.getAttribute(seller, "href"), DOM.getAttribute(receiver, "href"))) continue;$$-$$-					errorHandler.error ("305", context,$$-							"Premium payer and receiver don't match with option buyer and seller.",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+				if ((buyer == null) || (seller == null) ||$$+					(payer == null) || (receiver == null)) continue;$$$$-				return (result);$$+				if (Equal (buyer.GetAttribute ("href"), payer.GetAttribute ("href")) &&$$+					Equal (seller.GetAttribute ("href"), receiver.GetAttribute ("href"))) continue;$$+$$+				errorHandler ("305", context,$$+						"Premium payer and receiver don't match with option buyer and seller.",$$+						name, null);$$+$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures buyer, seller, payer and reciever are correct.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule	RULE46$$-		= new Rule (Preconditions.R3_0__LATER, "fx-46")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return ($$-						  validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FXDigitalOption"), errorHandler)$$-						& validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "FxDigitalOption"), errorHandler));$$-$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule45 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$return ($$-					  validate (nodeIndex.getElementsByName ("fxDigitalOption"), errorHandler));$$-			}$$+					  Rule45 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FXDigitalOption"), errorHandler)$$+					& Rule45 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "FxDigitalOption"), errorHandler));$$+$$+			return ($$+				  Rule45 (name, nodeIndex.GetElementsByName ("fxDigitalOption"), errorHandler));$$+		}$$+$$+		private static bool Rule45 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	buyer	 = XPath.Path (context, "buyerPartyReference");$$+				XmlElement	seller	 = XPath.Path (context, "sellerPartyReference");$$+				XmlElement	payer	 = XPath.Path (context, "fxOptionPremium", "payerPartyReference");$$+				XmlElement	receiver = XPath.Path (context, "fxOptionPremium", "receiverPartyReference");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context  = (Element) list.item (index);$$-					Element		buyer	 = XPath.path (context, "buyerPartyReference");$$-					Element		seller	 = XPath.path (context, "sellerPartyReference");$$-					Element		payer	 = XPath.path (context, "fxOptionPremium", "payerPartyReference");$$-					Element		receiver = XPath.path (context, "fxOptionPremium", "receiverPartyReference");$$-$$-					if ((buyer == null) || (seller == null) ||$$-						(payer == null) || (receiver == null)) continue;$$-$$-					if (equal (DOM.getAttribute(buyer, "href"), DOM.getAttribute(payer, "href")) &&$$-						equal (DOM.getAttribute(seller, "href"), DOM.getAttribute(receiver, "href"))) continue;$$-$$-					errorHandler.error ("305", context,$$-							"Premium payer and receiver don't match with option buyer and seller.",$$-							getName (), null);$$-$$-					result = false;$$-				}$$+				if ((buyer == null) || (seller == null) ||$$+					(payer == null) || (receiver == null)) continue;$$$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures the side rates definition for currency1$$-	 * uses an appropriate basis.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE47$$-		= new Rule (Preconditions.R3_0__LATER, "fx-47")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "SideRates"), errorHandler));$$-$$-				return ($$-						  validate (nodeIndex.getElementsByName ("sideRates"), errorHandler));$$+				if (Equal (buyer.GetAttribute("href"), payer.GetAttribute("href")) &&$$+					Equal (seller.GetAttribute("href"), receiver.GetAttribute("href"))) continue;$$+$$+				errorHandler ("305", context,$$+						"Premium payer and receiver don't match with option buyer and seller.",$$+						name, null);$$+$$+				result = false;$$}$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$-$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		basis	= XPath.path (context, "currency1SideRate", "sideRateBasis");$$-$$-					if ((basis == null) ||$$-						Types.toString (basis).equalsIgnoreCase ("Currency1perBaseCurrency") ||$$-						Types.toString (basis).equalsIgnoreCase ("BaseCurrencyPerCurrency1")) continue;$$-$$-					errorHandler.error ("305", context,$$-							"Side rate basis for currency1 should not be expressed in terms of currency2.",$$-							getName (), Types.toString (basis));$$-$$-					result = false;$$-				}$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		private static bool Rule46 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule46 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "SideRates"), errorHandler));$$$$-				return (result);$$-			}$$-		};$$-$$-	/**$$-	 * A <CODE>Rule</CODE> that ensures the side rates definition for currency2$$-	 * uses an appropriate basis.$$-	 * <P>$$-	 * Applies to FpML 3.0 and later.$$-	 * @since	TFP 1.2$$-	 */$$-	public static final Rule 	RULE48$$-		= new Rule (Preconditions.R3_0__LATER, "fx-48")$$-		{$$-			public boolean validate (NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$-			{$$-				if (nodeIndex.hasTypeInformation())$$-					return (validate (nodeIndex.getElementsByType (determineNamespace (nodeIndex), "SideRates"), errorHandler));$$-$$-				return ($$-						  validate (nodeIndex.getElementsByName ("sideRates"), errorHandler));$$-			}$$+			return ($$+					  Rule46 (name, nodeIndex.GetElementsByName ("sideRates"), errorHandler));$$+		}$$+$$+		private static bool Rule46 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			private boolean validate (NodeList list, ValidationErrorHandler errorHandler)$$-			{$$-				boolean		result	= true;$$+			foreach (XmlElement context in list) {$$+				XmlElement	basis	= XPath.Path (context, "currency1SideRate", "sideRateBasis");$$$$-				for (int index = 0; index < list.getLength(); ++index) {$$-					Element		context = (Element) list.item (index);$$-					Element		basis	= XPath.path (context, "currency2SideRate", "sideRateBasis");$$-$$-					if ((basis == null) ||$$-						Types.toString (basis).equalsIgnoreCase ("Currency2perBaseCurrency") ||$$-						Types.toString (basis).equalsIgnoreCase ("BaseCurrencyPerCurrency2")) continue;$$-$$-					errorHandler.error ("305", context,$$-							"Side rate basis for currency2 should not be expressed in terms of currency1.",$$-							getName (), Types.toString (basis));$$-$$-					result = false;$$-				}$$+				if ((basis == null) ||$$+					ToToken (basis).ToUpper ().Equals ("CURRENCY1PERBASECURRENCY") ||$$+					ToToken (basis).ToUpper ().Equals ("BASECURRENCYPERCURRENCY1")) continue;$$+$$+				errorHandler ("305", context,$$+						"Side rate basis for currency1 should not be expressed in terms of currency2.",$$+						name, ToToken (basis));$$$$-				return (result);$$+				result = false;$$}$$-		};$$-$$-	/**$$-	 * Provides access to the FX validation rule set.$$-	 *$$-	 * @return	The FX validation rule set.$$-	 * @since	TFP 1.2$$-	 */$$-	public static RuleSet getRules ()$$-	{$$-		return (rules);$$-	}$$+$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$$$-	/**$$-	 * A <CODE>RuleSet</CODE> containing all the standard FpML defined$$-	 * validation rules for interest rate products.$$-	 * @since	TFP 1.2$$-	 */$$-	private static final RuleSet	rules = new RuleSet ();$$-$$-	/**$$-	 * Generates a set of dates according to schedule defined by a start date,$$-	 * an end date, an interval, roll convention and a calendar.$$-	 *$$-	 * @param	start		The start date.$$-	 * @param	end			The end date.$$-	 * @param	frequency	The frequency of the schedule (e.g. 6M).$$-	 * @param	roll		The date roll convention or <CODE>null</CODE>.$$-	 * @param	calendar	The holiday calendar or <CODE>null</CODE>.$$-	 * @return	An array of calculated and adjusted dates.$$-	 * @since	TFP 1.2$$-	 */$$-	protected static Date [] generateSchedule (final Date start, final Date end,$$-			final Interval frequency, final DateRoll roll, final Calendar calendar)$$-	{$$-		Date		current = start;$$-		Vector		found	= new Vector ();$$-		Date []		dates;$$+		private static bool Rule47 (string name, NodeIndex nodeIndex, ValidationErrorHandler errorHandler)$$+		{$$+			if (nodeIndex.HasTypeInformation)$$+				return (Rule47 (name, nodeIndex.GetElementsByType (DetermineNamespace (nodeIndex), "SideRates"), errorHandler));$$+$$+			return ($$+					  Rule47 (name, nodeIndex.GetElementsByName ("sideRates"), errorHandler));$$+		}$$$$-		while (less (current, end)) {$$-			Date		adjusted;$$+		private static bool Rule47 (string name, XmlNodeList list, ValidationErrorHandler errorHandler)$$+		{$$+			bool		result	= true;$$$$-			if (roll != null)$$-				adjusted = roll.adjust(calendar, current);$$-			else$$-				adjusted = current;$$+			foreach (XmlElement context in list) {$$+				XmlElement	basis	= XPath.Path (context, "currency2SideRate", "sideRateBasis");$$+$$+				if ((basis == null) ||$$+					ToToken (basis).ToUpper ().Equals ("CURRENCY2PERBASECURRENCY") ||$$+					ToToken (basis).ToUpper ().Equals ("BASECURRENCYPERCURRENCY2")) continue;$$+$$+				errorHandler ("305", context,$$+						"Side rate basis for currency2 should not be expressed in terms of currency1.",$$+						name, ToToken (basis));$$+$$+				result = false;$$+			}$$$$-			if (!found.contains (adjusted))$$-				found.add (adjusted);$$+			return (result);$$+		}$$+$$+		// --------------------------------------------------------------------$$+$$+		/// <summary>$$+		/// Generates a set of dates according to schedule defined by a start date,$$+		/// an end date, an interval, roll convention and a calendar.$$+		/// </summary>$$+		/// <param name="start">The start date.</param>$$+		/// <param name="end">The end date.</param>$$+		/// <param name="frequency">The frequency of the schedule (e.g. 6M).</param>$$+		/// <param name="roll">The date roll convention or <c>null</c>.</param>$$+		/// <param name="calendar">The holiday calendar or <c>null</c>.</param>$$+		/// <returns>An array of calculated and adjusted dates.</returns>$$+		private static Date [] GenerateSchedule (Date start, Date end,$$+			Interval frequency, DateRoll roll, Calendar calendar)$$+		{$$+			Date		current = start;$$+			ArrayList	found	= new ArrayList ();$$+			Date []		dates;$$$$-			if (frequency.getPeriod () == Period.TERM) {$$-				if (equal (current, start))$$-					current = end;$$+			while (Less (current, end)) {$$+				Date		adjusted;$$+$$+				if (roll != null)$$+					adjusted = roll.Adjust (calendar, current);$$+				else$$+					adjusted = current;$$+$$+				if (!found.Contains (adjusted))$$+					found.Add (adjusted);$$+$$+				if (frequency.Period == Period.TERM) {$$+					if (Equal (current, start))$$+						current = end;$$+					else$$+						break;$$+				}$$else$$-					break;$$+					current = current.Plus (frequency);$$}$$-			else$$-				current = current.plus (frequency);$$+$$+			found.CopyTo (dates  = new Date [found.Count]);$$+			return (dates);$$}$$-$$-		found.copyInto (dates  = new Date [found.size ()]);$$-		return (dates);$$-	}$$-#endif$$-#if false$$-		/// <summary>$$-		/// Initialises the <see cref="RuleSet"/> with copies of all the FpML$$-		/// defined <see cref="Rule"/> instances for Interest Rate Derivatives.$$-		/// </summary>$$-		static FxRules ()$$-		{$$-			Rules.Add (RULE01);$$-	/*		Rules.Add (RULE02);$$-			Rules.Add (RULE03);$$-			Rules.Add (RULE04);$$-			Rules.Add (RULE05);$$-			Rules.Add (RULE06);$$-			Rules.Add (RULE08);$$-			Rules.Add (RULE09);$$-			Rules.Add (RULE10);$$-			Rules.Add (RULE12);$$-			Rules.Add (RULE13);$$-			Rules.Add (RULE14);$$-			Rules.Add (RULE15);$$-			Rules.Add (RULE16);$$-			Rules.Add (RULE17);$$-			Rules.Add (RULE18);$$-			Rules.Add (RULE19);$$-			Rules.Add (RULE20);$$-			Rules.Add (RULE21);$$-			Rules.Add (RULE22);$$-			Rules.Add (RULE23);$$-			Rules.Add (RULE24);$$-			Rules.Add (RULE25); */$$-		}$$-#endif$$}$$}$$\ No newline at end of file$$,1
